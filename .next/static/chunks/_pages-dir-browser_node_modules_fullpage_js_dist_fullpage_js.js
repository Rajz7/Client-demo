/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_fullpage_js_dist_fullpage_js"],{

/***/ "(pages-dir-browser)/./node_modules/fullpage.js/dist/fullpage.js":
/*!***************************************************!*\
  !*** ./node_modules/fullpage.js/dist/fullpage.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*!\n* fullPage 4.0.37\n* https://github.com/alvarotrigo/fullPage.js\n*\n* @license GPLv3 for open source use only\n* or Fullpage Commercial License for commercial use\n* http://alvarotrigo.com/fullPage/pricing/\n*\n* Copyright (C) 2018 http://alvarotrigo.com/fullPage - A project by Alvaro Trigo\n*/\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    // https://tc39.github.io/ecma262/#sec-array.prototype.find\n    if (!Array.prototype.find) {\n      Object.defineProperty(Array.prototype, 'find', {\n        value: function value(predicate) {\n          // 1. Let O be ? ToObject(this value).\n          if (this == null) {\n            throw new TypeError('\"this\" is null or not defined');\n          }\n\n          var o = Object(this); // 2. Let len be ? ToLength(? Get(O, \"length\")).\n\n          var len = o.length >>> 0; // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n\n          if (typeof predicate !== 'function') {\n            throw new TypeError('predicate must be a function');\n          } // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n\n\n          var thisArg = arguments[1]; // 5. Let k be 0.\n\n          var k = 0; // 6. Repeat, while k < len\n\n          while (k < len) {\n            // a. Let Pk be ! ToString(k).\n            // b. Let kValue be ? Get(O, Pk).\n            // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n            // d. If testResult is true, return kValue.\n            var kValue = o[k];\n\n            if (predicate.call(thisArg, kValue, k, o)) {\n              return kValue;\n            } // e. Increase k by 1.\n\n\n            k++;\n          } // 7. Return undefined.\n\n\n          return undefined;\n        }\n      });\n    }\n\n    // Production steps of ECMA-262, Edition 6, 22.1.2.1\n    if (!Array.from) {\n      Array.from = function () {\n        var toStr = Object.prototype.toString;\n\n        var isCallable = function isCallable(fn) {\n          return typeof fn === 'function' || toStr.call(fn) === '[object Function]';\n        };\n\n        var toInteger = function toInteger(value) {\n          var number = Number(value);\n\n          if (isNaN(number)) {\n            return 0;\n          }\n\n          if (number === 0 || !isFinite(number)) {\n            return number;\n          }\n\n          return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n        };\n\n        var maxSafeInteger = Math.pow(2, 53) - 1;\n\n        var toLength = function toLength(value) {\n          var len = toInteger(value);\n          return Math.min(Math.max(len, 0), maxSafeInteger);\n        }; // The length property of the from method is 1.\n\n\n        return function from(arrayLike\n        /*, mapFn, thisArg */\n        ) {\n          // 1. Let C be the this value.\n          var C = this; // 2. Let items be ToObject(arrayLike).\n\n          var items = Object(arrayLike); // 3. ReturnIfAbrupt(items).\n\n          if (arrayLike == null) {\n            throw new TypeError('Array.from requires an array-like object - not null or undefined');\n          } // 4. If mapfn is undefined, then let mapping be false.\n\n\n          var mapFn = arguments.length > 1 ? arguments[1] : void undefined;\n          var T;\n\n          if (typeof mapFn !== 'undefined') {\n            // 5. else\n            // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\n            if (!isCallable(mapFn)) {\n              throw new TypeError('Array.from: when provided, the second argument must be a function');\n            } // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\n\n\n            if (arguments.length > 2) {\n              T = arguments[2];\n            }\n          } // 10. Let lenValue be Get(items, \"length\").\n          // 11. Let len be ToLength(lenValue).\n\n\n          var len = toLength(items.length); // 13. If IsConstructor(C) is true, then\n          // 13. a. Let A be the result of calling the [[Construct]] internal method\n          // of C with an argument list containing the single item len.\n          // 14. a. Else, Let A be ArrayCreate(len).\n\n          var A = isCallable(C) ? Object(new C(len)) : new Array(len); // 16. Let k be 0.\n\n          var k = 0; // 17. Repeat, while k < len… (also steps a - h)\n\n          var kValue;\n\n          while (k < len) {\n            kValue = items[k];\n\n            if (mapFn) {\n              A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);\n            } else {\n              A[k] = kValue;\n            }\n\n            k += 1;\n          } // 18. Let putStatus be Put(A, \"length\", len, true).\n\n\n          A.length = len; // 20. Return A.\n\n          return A;\n        };\n      }();\n    }\n\n    var win = window;\n    var doc = document;\n    var isTouchDevice = navigator.userAgent.match(/(iPhone|iPod|iPad|Android|playbook|silk|BlackBerry|BB10|Windows Phone|Tizen|Bada|webOS|IEMobile|Opera Mini)/) || navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document; // iPad on iOS 13 detection\n\n    var isMacDevice = /(Mac|iPhone|iPod|iPad)/i.test(win.navigator.userAgent); // @ts-ignore\n\n    var isTouch = 'ontouchstart' in win || navigator.msMaxTouchPoints > 0 || navigator.maxTouchPoints;\n    var isIE11 = !!window.MSInputMethodContext && !!document.documentMode; // taken from https://github.com/udacity/ud891/blob/gh-pages/lesson2-focus/07-modals-and-keyboard-traps/solution/modal.js\n\n    var focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex=\"0\"], summary:not([disabled]), [contenteditable]'; // cache common elements\n\n    var FP = {\n      test: {},\n      shared: {}\n    };\n    var extensions = ['parallax', 'scrollOverflowReset', 'dragAndMove', 'offsetSections', 'fadingEffect', 'responsiveSlides', 'continuousHorizontal', 'interlockedSlides', 'scrollHorizontally', 'resetSliders', 'cards', 'dropEffect', 'waterEffect'];\n    var isInsideIframe = function () {\n      var inIframe = window.self !== window.top;\n      return function () {\n        return inIframe;\n      };\n    }();\n\n    /**\n    * forEach polyfill for IE\n    * https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach#Browser_Compatibility\n    */\n\n    if (win.NodeList && !NodeList.prototype.forEach) {\n      NodeList.prototype.forEach = function (callback, thisArg) {\n        thisArg = thisArg || window;\n\n        for (var i = 0; i < this.length; i++) {\n          callback.call(thisArg, this[i], i, this);\n        }\n      };\n    }\n\n    if (typeof Object.assign != 'function') {\n      // Must be writable: true, enumerable: false, configurable: true\n      Object.defineProperty(Object, 'assign', {\n        value: function assign(target, varArgs) {\n\n          if (target == null) {\n            // TypeError if undefined or null\n            throw new TypeError('Cannot convert undefined or null to object');\n          }\n\n          var to = Object(target);\n\n          for (var index = 1; index < arguments.length; index++) {\n            var nextSource = arguments[index];\n\n            if (nextSource != null) {\n              // Skip over if undefined or null\n              for (var nextKey in nextSource) {\n                // Avoid bugs when hasOwnProperty is shadowed\n                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                  to[nextKey] = nextSource[nextKey];\n                }\n              }\n            }\n          }\n\n          return to;\n        },\n        writable: true,\n        configurable: true\n      });\n    }\n\n    // https://stackoverflow.com/questions/51719553/padstart-not-working-in-ie11\n    // https://github.com/behnammodi/polyfill/blob/master/string.polyfill.js\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart\n    if (!String.prototype.padStart) {\n      String.prototype.padStart = function padStart(targetLength, padString) {\n        targetLength = targetLength >> 0; //truncate if number or convert non-number to 0;\n\n        padString = String(typeof padString !== 'undefined' ? padString : ' ');\n\n        if (this.length > targetLength) {\n          return String(this);\n        } else {\n          targetLength = targetLength - this.length;\n\n          if (targetLength > padString.length) {\n            padString += Array.apply(null, Array(targetLength)).map(function () {\n              return padString;\n            }).join(\"\");\n          }\n\n          return padString.slice(0, targetLength) + String(this);\n        }\n      };\n    }\n\n    //utils\n    /**\n    * Shows a message in the console of the given type.\n    */\n\n    function showError(type, text) {\n      win.console && win.console[type] && win.console[type]('fullPage: ' + text);\n    }\n    function isVisible(el) {\n      var style = win.getComputedStyle(el);\n      return style.display !== 'none';\n    }\n    function getVisible(elements) {\n      return Array.from(elements).filter(function (e) {\n        return isVisible(e);\n      });\n    }\n    /**\n    * Equivalent of jQuery function $().\n    */\n\n    function $(selector, context) {\n      context = arguments.length > 1 ? context : document;\n      return context ? context.querySelectorAll(selector) : null;\n    }\n    /**\n    * Extends a given Object properties and its childs.\n    */\n\n    function deepExtend(out) {\n      out = out || {};\n\n      for (var i = 1, len = arguments.length; i < len; ++i) {\n        var obj = arguments[i];\n\n        if (!obj) {\n          continue;\n        }\n\n        for (var key in obj) {\n          if (!obj.hasOwnProperty(key) || key == '__proto__' || key == 'constructor') {\n            continue;\n          } // based on https://javascriptweblog.wordpress.com/2011/08/08/fixing-the-javascript-typeof-operator/\n\n\n          if (Object.prototype.toString.call(obj[key]) === '[object Object]') {\n            out[key] = deepExtend(out[key], obj[key]);\n            continue;\n          }\n\n          out[key] = obj[key];\n        }\n      }\n\n      return out;\n    }\n    /**\n    * Checks if the passed element contains the passed class.\n    */\n\n    function hasClass(el, className) {\n      if (el == null) {\n        return false;\n      }\n\n      return el.classList.contains(className);\n    }\n    /**\n    * Gets the window height. Crossbrowser.\n    */\n\n    function getWindowHeight() {\n      return 'innerHeight' in win ? win.innerHeight : doc.documentElement.offsetHeight;\n    }\n    /**\n    * Gets the window width.\n    */\n\n    function getWindowWidth() {\n      return win.innerWidth;\n    }\n    /**\n    * Set's the CSS properties for the passed item/s.\n    * @param {NodeList|HTMLElement|Object} items\n    * @param {Object} props css properties and values.\n    */\n\n    function css(items, props) {\n      items = getList(items);\n      var key;\n\n      for (key in props) {\n        if (props.hasOwnProperty(key)) {\n          if (key !== null) {\n            for (var i = 0; i < items.length; i++) {\n              var item = items[i];\n              item.style[key] = props[key];\n            }\n          }\n        }\n      }\n\n      return items;\n    }\n    /**\n    * Gets the previous element to the passed element.\n    */\n\n    function prev(item) {\n      return item.previousElementSibling;\n    }\n    /**\n    * Gets the next element to the passed element.\n    */\n\n    function next(item) {\n      return item.nextElementSibling;\n    }\n    /**\n    * Gets the last element from the passed list of elements.\n    */\n\n    function last(item) {\n      return item[item.length - 1];\n    }\n    /**\n    * Gets index from the passed element.\n    * @param {String} selector is optional.\n    */\n\n    function index(item, selector) {\n      item = isArrayOrList(item) ? item[0] : item;\n      var children = selector != null ? $(selector, item.parentNode) : item.parentNode.childNodes;\n      var num = 0;\n\n      for (var i = 0; i < children.length; i++) {\n        if (children[i] == item) return num;\n        if (children[i].nodeType == 1) num++;\n      }\n\n      return -1;\n    }\n    /**\n    * Gets an iterable element for the passed element/s\n    */\n\n    function getList(item) {\n      return !isArrayOrList(item) ? [item] : item;\n    }\n    /**\n    * Adds the display=none property for the passed element/s\n    */\n\n    function hide(el) {\n      el = getList(el);\n\n      for (var i = 0; i < el.length; i++) {\n        el[i].style.display = 'none';\n      }\n\n      return el;\n    }\n    /**\n    * Adds the display=block property for the passed element/s\n    */\n\n    function show(el) {\n      el = getList(el);\n\n      for (var i = 0; i < el.length; i++) {\n        el[i].style.display = 'block';\n      }\n\n      return el;\n    }\n    /**\n    * Checks if the passed element is an iterable element or not\n    */\n\n    function isArrayOrList(el) {\n      return Object.prototype.toString.call(el) === '[object Array]' || Object.prototype.toString.call(el) === '[object NodeList]';\n    }\n    /**\n    * Adds the passed class to the passed element/s\n    */\n\n    function addClass(el, className) {\n      el = getList(el);\n\n      for (var i = 0; i < el.length; i++) {\n        var item = el[i];\n        item.classList.add(className);\n      }\n\n      return el;\n    }\n    /**\n    * Removes the passed class to the passed element/s\n    * @param {String} `className` can be multiple classnames separated by whitespace\n    */\n\n    function removeClass(el, className) {\n      el = getList(el);\n      var classNames = className.split(' ');\n\n      for (var a = 0; a < classNames.length; a++) {\n        className = classNames[a];\n\n        for (var i = 0; i < el.length; i++) {\n          var item = el[i];\n          item.classList.remove(className);\n        }\n      }\n\n      return el;\n    }\n    /**\n    * Appends the given element ot the given parent.\n    */\n\n    function appendTo(el, parent) {\n      parent.appendChild(el);\n    }\n    /**\n    Usage:\n\n    var wrapper = document.createElement('div');\n    wrapper.className = 'fp-slides';\n    wrap($('.slide'), wrapper);\n\n    https://jsfiddle.net/qwzc7oy3/15/ (vanilla)\n    https://jsfiddle.net/oya6ndka/1/ (jquery equivalent)\n    */\n\n    function wrap(toWrap, wrapper, isWrapAll) {\n      var newParent;\n      wrapper = wrapper || doc.createElement('div');\n\n      for (var i = 0; i < toWrap.length; i++) {\n        var item = toWrap[i];\n\n        if (isWrapAll && !i || !isWrapAll) {\n          newParent = wrapper.cloneNode(true);\n          item.parentNode.insertBefore(newParent, item);\n        }\n\n        newParent.appendChild(item);\n      }\n\n      return toWrap;\n    }\n    /**\n    Usage:\n    var wrapper = document.createElement('div');\n    wrapper.className = 'fp-slides';\n    wrap($('.slide'), wrapper);\n\n    https://jsfiddle.net/qwzc7oy3/27/ (vanilla)\n    https://jsfiddle.net/oya6ndka/4/ (jquery equivalent)\n    */\n\n    function wrapAll(toWrap, wrapper) {\n      wrap(toWrap, wrapper, true);\n    }\n    /**\n    * Usage:\n    * wrapInner(document.querySelector('#pepe'), '<div class=\"test\">afdas</div>');\n    * wrapInner(document.querySelector('#pepe'), element);\n    *\n    * https://jsfiddle.net/zexxz0tw/6/\n    *\n    * https://stackoverflow.com/a/21817590/1081396\n    */\n\n    function wrapInner(parent, wrapper) {\n      parent.appendChild(wrapper);\n\n      while (parent.firstChild !== wrapper) {\n        wrapper.appendChild(parent.firstChild);\n      }\n    }\n    /**\n    * Usage:\n    * unwrap(document.querySelector('#pepe'));\n    * unwrap(element);\n    *\n    * https://jsfiddle.net/szjt0hxq/1/\n    *\n    */\n\n    function unwrap(wrapper) {\n      var wrapperContent = doc.createDocumentFragment();\n\n      while (wrapper.firstChild) {\n        wrapperContent.appendChild(wrapper.firstChild);\n      }\n\n      wrapper.parentNode.replaceChild(wrapperContent, wrapper);\n    }\n    /**\n    * http://stackoverflow.com/questions/22100853/dom-pure-javascript-solution-to-jquery-closest-implementation\n    * Returns the element or `false` if there's none\n    */\n\n    function closest(el, selector) {\n      if (el && el.nodeType === 1) {\n        if (matches(el, selector)) {\n          return el;\n        }\n\n        return closest(el.parentNode, selector);\n      }\n\n      return null;\n    }\n    /**\n    * Places one element (rel) after another one or group of them (reference).\n    * @param {HTMLElement} reference\n    * @param {HTMLElement|NodeList|String|Array} el\n    * https://jsfiddle.net/9s97hhzv/1/\n    */\n\n    function after(reference, el) {\n      insertBefore(reference, reference.nextSibling, el);\n    }\n    /**\n    * Places one element (rel) before another one or group of them (reference).\n    * @param {HTMLElement} reference\n    * @param {HTMLElement|NodeList|String|Array} el\n    * https://jsfiddle.net/9s97hhzv/1/\n    */\n\n    function before(reference, el) {\n      insertBefore(reference, reference, el);\n    }\n    /**\n    * Based in https://stackoverflow.com/a/19316024/1081396\n    * and https://stackoverflow.com/a/4793630/1081396\n    */\n\n    function insertBefore(reference, beforeElement, el) {\n      if (!isArrayOrList(el)) {\n        if (typeof el == 'string') {\n          el = createElementFromHTML(el);\n        }\n\n        el = [el];\n      }\n\n      for (var i = 0; i < el.length; i++) {\n        reference.parentNode.insertBefore(el[i], beforeElement);\n      }\n    } //http://stackoverflow.com/questions/3464876/javascript-get-window-x-y-position-for-scroll\n\n    function getScrollTop() {\n      var docElement = doc.documentElement;\n      return (win.pageYOffset || docElement.scrollTop) - (docElement.clientTop || 0);\n    }\n    /**\n    * Gets the siblings of the passed element\n    */\n\n    function siblings(el) {\n      return Array.prototype.filter.call(el.parentNode.children, function (child) {\n        return child !== el;\n      });\n    }\n    function preventDefault(event) {\n      event.preventDefault();\n    }\n    function getAttr(el, attr) {\n      return el.getAttribute(attr);\n    }\n    function docAddEvent(event, callback, options) {\n      doc.addEventListener(event, callback, options === 'undefined' ? null : options);\n    }\n    function windowAddEvent(event, callback, options) {\n      win.addEventListener(event, callback, options === 'undefined' ? null : options);\n    }\n    function docRemoveEvent(event, callback, options) {\n      doc.removeEventListener(event, callback, options === 'undefined' ? null : options);\n    }\n    function windowRemoveEvent(event, callback, options) {\n      win.removeEventListener(event, callback, options === 'undefined' ? null : options);\n    }\n    /**\n    * Determines whether the passed item is of function type.\n    */\n\n    function isFunction(item) {\n      if (typeof item === 'function') {\n        return true;\n      }\n\n      var type = Object.prototype.toString.call(item);\n      return type === '[object Function]' || type === '[object GeneratorFunction]';\n    }\n    /**\n    * Trigger custom events\n    */\n\n    function trigger(el, eventName, data) {\n      var event;\n      data = typeof data === 'undefined' ? {} : data; // Native\n\n      if (typeof win.CustomEvent === \"function\") {\n        event = new CustomEvent(eventName, {\n          detail: data\n        });\n      } else {\n        event = doc.createEvent('CustomEvent');\n        event.initCustomEvent(eventName, true, true, data);\n      }\n\n      el.dispatchEvent(event);\n    }\n    /**\n    * Polyfill of .matches()\n    */\n\n    function matches(el, selector) {\n      return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\n    }\n    /**\n    * Toggles the visibility of the passed element el.\n    */\n\n    function toggle(el, value) {\n      if (typeof value === \"boolean\") {\n        for (var i = 0; i < el.length; i++) {\n          el[i].style.display = value ? 'block' : 'none';\n        }\n      } //we don't use it in other way, so no else :)\n\n\n      return el;\n    }\n    /**\n    * Creates a HTMLElement from the passed HTML string.\n    * https://stackoverflow.com/a/494348/1081396\n    */\n\n    function createElementFromHTML(htmlString) {\n      var div = doc.createElement('div');\n      div.innerHTML = htmlString.trim(); // Change this to div.childNodes to support multiple top-level nodes\n\n      return div.firstChild;\n    }\n    /**\n    * Removes the passed item/s from the DOM.\n    */\n\n    function remove(items) {\n      items = getList(items);\n\n      for (var i = 0; i < items.length; i++) {\n        var item = items[i];\n\n        if (item && item.parentElement) {\n          item.parentNode.removeChild(item);\n        }\n      }\n    } //https://jsfiddle.net/w1rktecz/\n\n    function untilAll(item, selector, fn) {\n      var sibling = item[fn];\n      var siblings = [];\n\n      while (sibling) {\n        if (matches(sibling, selector) || selector == null) {\n          siblings.push(sibling);\n        }\n\n        sibling = sibling[fn];\n      }\n\n      return siblings;\n    }\n    /**\n    * Gets all next elements matching the passed selector.\n    */\n\n    function nextAll(item, selector) {\n      return untilAll(item, selector, 'nextElementSibling');\n    }\n    /**\n    * Gets all previous elements matching the passed selector.\n    */\n\n    function prevAll(item, selector) {\n      return untilAll(item, selector, 'previousElementSibling');\n    }\n    /**\n    * Converts an object to an array.\n    */\n\n    function toArray(objectData) {\n      return Object.keys(objectData).map(function (key) {\n        return objectData[key];\n      });\n    }\n    function getLast(items) {\n      return items[items.length - 1];\n    }\n    /**\n    * Gets the average of the last `number` elements of the given array.\n    */\n\n    function getAverage(elements, number) {\n      var sum = 0; //taking `number` elements from the end to make the average, if there are not enought, 1\n\n      var lastElements = elements.slice(Math.max(elements.length - number, 1));\n\n      for (var i = 0; i < lastElements.length; i++) {\n        sum = sum + lastElements[i];\n      }\n\n      return Math.ceil(sum / number);\n    }\n    /**\n    * Sets the value for the given attribute from the `data-` attribute with the same suffix\n    * ie: data-srcset ==> srcset  |  data-src ==> src\n    */\n\n    function setSrc(element, attribute) {\n      element.setAttribute(attribute, getAttr(element, 'data-' + attribute));\n      element.removeAttribute('data-' + attribute);\n    }\n    function getParentsUntil(item, topParentSelector) {\n      var parents = [item];\n\n      do {\n        item = item.parentNode;\n        parents.push(item);\n      } while (!matches(item, topParentSelector));\n\n      return parents;\n    }\n    function isInsideInput() {\n      var activeElement = doc.activeElement;\n      return matches(activeElement, 'textarea') || matches(activeElement, 'input') || matches(activeElement, 'select') || getAttr(activeElement, 'contentEditable') == \"true\" || getAttr(activeElement, 'contentEditable') == '';\n    } //utils are public, so we can use it wherever we want\n    // @ts-ignore\n\n    window[\"fp_utils\"] = {\n      \"$\": $,\n      \"deepExtend\": deepExtend,\n      \"hasClass\": hasClass,\n      \"getWindowHeight\": getWindowHeight,\n      \"css\": css,\n      \"prev\": prev,\n      \"next\": next,\n      \"last\": last,\n      \"index\": index,\n      \"getList\": getList,\n      \"hide\": hide,\n      \"show\": show,\n      \"isArrayOrList\": isArrayOrList,\n      \"addClass\": addClass,\n      \"removeClass\": removeClass,\n      \"appendTo\": appendTo,\n      \"wrap\": wrap,\n      \"wrapAll\": wrapAll,\n      \"unwrap\": unwrap,\n      \"closest\": closest,\n      \"after\": after,\n      \"before\": before,\n      \"insertBefore\": insertBefore,\n      \"getScrollTop\": getScrollTop,\n      \"siblings\": siblings,\n      \"preventDefault\": preventDefault,\n      \"isFunction\": isFunction,\n      \"trigger\": trigger,\n      \"matches\": matches,\n      \"toggle\": toggle,\n      \"createElementFromHTML\": createElementFromHTML,\n      \"remove\": remove,\n      // \"filter\": filter,\n      \"untilAll\": untilAll,\n      \"nextAll\": nextAll,\n      \"prevAll\": prevAll,\n      \"showError\": showError\n    };\n\n    var utils = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        showError: showError,\n        isVisible: isVisible,\n        getVisible: getVisible,\n        $: $,\n        deepExtend: deepExtend,\n        hasClass: hasClass,\n        getWindowHeight: getWindowHeight,\n        getWindowWidth: getWindowWidth,\n        css: css,\n        prev: prev,\n        next: next,\n        last: last,\n        index: index,\n        getList: getList,\n        hide: hide,\n        show: show,\n        isArrayOrList: isArrayOrList,\n        addClass: addClass,\n        removeClass: removeClass,\n        appendTo: appendTo,\n        wrap: wrap,\n        wrapAll: wrapAll,\n        wrapInner: wrapInner,\n        unwrap: unwrap,\n        closest: closest,\n        after: after,\n        before: before,\n        insertBefore: insertBefore,\n        getScrollTop: getScrollTop,\n        siblings: siblings,\n        preventDefault: preventDefault,\n        getAttr: getAttr,\n        docAddEvent: docAddEvent,\n        windowAddEvent: windowAddEvent,\n        docRemoveEvent: docRemoveEvent,\n        windowRemoveEvent: windowRemoveEvent,\n        isFunction: isFunction,\n        trigger: trigger,\n        matches: matches,\n        toggle: toggle,\n        createElementFromHTML: createElementFromHTML,\n        remove: remove,\n        untilAll: untilAll,\n        nextAll: nextAll,\n        prevAll: prevAll,\n        toArray: toArray,\n        getLast: getLast,\n        getAverage: getAverage,\n        setSrc: setSrc,\n        getParentsUntil: getParentsUntil,\n        isInsideInput: isInsideInput\n    });\n\n    function _typeof(obj) {\n      \"@babel/helpers - typeof\";\n\n      if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n        _typeof = function (obj) {\n          return typeof obj;\n        };\n      } else {\n        _typeof = function (obj) {\n          return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        };\n      }\n\n      return _typeof(obj);\n    }\n\n    var EventEmitter = {\n      events: {},\n      on: function on(event, listener) {\n        var _this = this;\n\n        if (_typeof(this.events[event]) !== 'object') {\n          this.events[event] = [];\n        }\n\n        this.events[event].push(listener);\n        return function () {\n          return _this.removeListener(event, listener);\n        };\n      },\n      removeListener: function removeListener(event, listener) {\n        if (_typeof(this.events[event]) === 'object') {\n          var idx = this.events[event].indexOf(listener);\n\n          if (idx > -1) {\n            this.events[event].splice(idx, 1);\n          }\n        }\n      },\n      emit: function emit(event) {\n        var _this2 = this;\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        if (_typeof(this.events[event]) === 'object') {\n          this.events[event].forEach(function (listener) {\n            return listener.apply(_this2, args);\n          });\n        }\n      },\n      once: function once(event, listener) {\n        var _this3 = this;\n\n        var remove = this.on(event, function () {\n          remove();\n\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          listener.apply(_this3, args);\n        });\n      }\n    };\n\n    var defaultState = {\n      numSections: 0,\n      numSlides: 0,\n      slides: [],\n      sections: [],\n      activeSection: null,\n      scrollTrigger: null,\n      isBeyondFullpage: false,\n      aboutToScrollToFullPage: false,\n      slideMoving: false,\n      isResizing: false,\n      isScrolling: false,\n      lastScrolledDestiny: undefined,\n      lastScrolledSlide: undefined,\n      activeAnimation: false,\n      canScroll: true,\n      touchDirection: 'none',\n      wheelDirection: 'none',\n      isGrabbing: false,\n      isUsingWheel: false,\n      isWindowFocused: true,\n      previousDestTop: 0,\n      windowsHeight: getWindowHeight(),\n      isDoingContinousVertical: false,\n      timeouts: {},\n      scrollY: 0,\n      scrollX: 0,\n      isFullpageInitDone: false\n    };\n    var state = Object.assign({}, defaultState); // @ts-ignore\n\n    win.state = state;\n    function setState(props) {\n      Object.assign(state, props);\n    }\n    function getState() {\n      return state;\n    }\n    function getActivePanel() {\n      return state.activeSection && state.activeSection.activeSlide ? state.activeSection.activeSlide : state.activeSection;\n    }\n    function resetState() {\n      setState(defaultState);\n    }\n\n    var events = {\n      onAfterRenderNoAnchor: 'onAfterRenderNoAnchor',\n      onClickOrTouch: 'onClickOrTouch',\n      moveSlideLeft: 'moveSlideLeft',\n      moveSlideRight: 'moveSlideRight',\n      onInitialise: 'onInitialise',\n      beforeInit: 'beforeInit',\n      bindEvents: 'bindEvents',\n      onDestroy: 'onDestroy',\n      onDestroyAll: 'onDestroyAll',\n      contentChanged: 'contentChanged',\n      onScrollOverflowScrolled: 'onScrollOverflowScrolled',\n      onScrollPageAndSlide: 'onScrollPageAndSlide',\n      onKeyDown: 'onKeyDown',\n      onMenuClick: 'onMenuClick',\n      scrollPage: 'scrollPage',\n      landscapeScroll: 'landscapeScroll',\n      scrollBeyondFullpage: 'scrollBeyondFullpage',\n      onPerformMovement: 'onPerformMovement',\n      onSlideLeave: 'onSlideLeave',\n      onLeave: 'onLeave',\n      afterSectionLoads: 'afterSectionLoads',\n      afterSlideLoads: 'afterSlideLoads'\n    };\n\n    EventEmitter.on(events.bindEvents, bindEvents$c);\n\n    function bindEvents$c() {\n      //Scrolls to the section when clicking the navigation bullet\n      //simulating the jQuery .on('click') event using delegation\n      ['click', 'touchstart'].forEach(function (eventName) {\n        docAddEvent(eventName, delegatedEvents);\n      });\n      windowAddEvent('focus', focusHandler);\n      internalEvents();\n    }\n\n    function internalEvents() {\n      EventEmitter.on(events.onDestroy, onDestroy$9);\n    }\n\n    function delegatedEvents(e) {\n      EventEmitter.emit(events.onClickOrTouch, {\n        e: e,\n        target: e.target\n      });\n    }\n\n    function onDestroy$9() {\n      ['click', 'touchstart'].forEach(function (eventName) {\n        docRemoveEvent(eventName, delegatedEvents);\n      });\n    } // changing isWindowFocused to true on focus event\n\n\n    function focusHandler() {\n      setState({\n        isWindowFocused: true\n      });\n    }\n\n    // keeping central set of classnames and selectors\n    var WRAPPER = 'fullpage-wrapper';\n    var WRAPPER_SEL = '.' + WRAPPER; // slimscroll\n\n    var SCROLLABLE = 'fp-scrollable';\n\n    var RESPONSIVE = 'fp-responsive';\n    var NO_TRANSITION = 'fp-notransition';\n    var DESTROYED = 'fp-destroyed';\n    var ENABLED = 'fp-enabled';\n    var VIEWING_PREFIX = 'fp-viewing';\n    var ACTIVE = 'active';\n    var ACTIVE_SEL = '.' + ACTIVE;\n    var COMPLETELY = 'fp-completely';\n    var COMPLETELY_SEL = '.' + COMPLETELY;\n    var LOADED = 'fp-loaded';\n\n    var SECTION_DEFAULT_SEL = '.section';\n    var SECTION = 'fp-section';\n    var SECTION_SEL = '.' + SECTION;\n    var SECTION_ACTIVE_SEL = SECTION_SEL + ACTIVE_SEL;\n    var TABLE_CELL = 'fp-tableCell';\n    var TABLE_CELL_SEL = '.' + TABLE_CELL;\n    var AUTO_HEIGHT = 'fp-auto-height';\n    var AUTO_HEIGHT_SEL = '.' + AUTO_HEIGHT;\n    var AUTO_HEIGHT_RESPONSIVE = 'fp-auto-height-responsive';\n    var AUTO_HEIGHT_RESPONSIVE_SEL = '.' + AUTO_HEIGHT_RESPONSIVE;\n    var NORMAL_SCROLL = 'fp-normal-scroll';\n\n    var SECTION_NAV = 'fp-nav';\n    var SECTION_NAV_SEL = '#' + SECTION_NAV;\n    var SECTION_NAV_TOOLTIP = 'fp-tooltip';\n    var SECTION_NAV_TOOLTIP_SEL = '.' + SECTION_NAV_TOOLTIP;\n    var SHOW_ACTIVE_TOOLTIP = 'fp-show-active'; // slide\n\n    var SLIDE_DEFAULT_SEL = '.slide';\n    var SLIDE = 'fp-slide';\n    var SLIDE_SEL = '.' + SLIDE;\n    var SLIDE_ACTIVE_SEL = SLIDE_SEL + ACTIVE_SEL;\n    var SLIDES_WRAPPER = 'fp-slides';\n    var SLIDES_WRAPPER_SEL = '.' + SLIDES_WRAPPER;\n    var SLIDES_CONTAINER = 'fp-slidesContainer';\n    var SLIDES_CONTAINER_SEL = '.' + SLIDES_CONTAINER;\n    var TABLE = 'fp-table';\n    var OVERFLOW = 'fp-overflow';\n    var OVERFLOW_SEL = '.' + OVERFLOW;\n    var IS_OVERFLOW = 'fp-is-overflow'; // slide nav\n\n    var SLIDES_NAV = 'fp-slidesNav';\n    var SLIDES_NAV_SEL = '.' + SLIDES_NAV;\n    var SLIDES_NAV_LINK_SEL = SLIDES_NAV_SEL + ' a';\n    var SLIDES_STYLED_ARROW = 'fp-arrow';\n    var SLIDES_ARROW = 'fp-controlArrow';\n    var SLIDES_ARROW_SEL = '.' + SLIDES_ARROW;\n    var SLIDES_PREV = 'fp-prev';\n    var SLIDES_PREV_SEL = '.' + SLIDES_PREV;\n    var SLIDES_ARROW_PREV_SEL = SLIDES_ARROW_SEL + SLIDES_PREV_SEL;\n    var SLIDES_NEXT = 'fp-next';\n    var SLIDES_NEXT_SEL = '.' + SLIDES_NEXT;\n    var SLIDES_ARROW_NEXT_SEL = SLIDES_ARROW_SEL + SLIDES_NEXT_SEL; // Watermark\n\n    var WATERMARK = 'fp-watermark';\n    var WATERMARK_SEL = '.' + WATERMARK;\n\n    var defaultOptions = {\n      //navigation\n      menu: false,\n      anchors: [],\n      lockAnchors: false,\n      navigation: false,\n      navigationPosition: 'right',\n      navigationTooltips: [],\n      showActiveTooltip: false,\n      slidesNavigation: false,\n      slidesNavPosition: 'bottom',\n      scrollBar: false,\n      hybrid: false,\n      licenseKey: '',\n      credits: {\n        \"enabled\": true,\n        \"label\": 'Made with fullPage.js',\n        \"position\": 'right'\n      },\n      //scrolling\n      css3: true,\n      scrollingSpeed: 700,\n      autoScrolling: true,\n      fitToSection: true,\n      fitToSectionDelay: 600,\n      easing: 'easeInOutCubic',\n      easingcss3: 'ease',\n      loopBottom: false,\n      loopTop: false,\n      loopHorizontal: true,\n      continuousVertical: false,\n      continuousHorizontal: false,\n      scrollHorizontally: false,\n      interlockedSlides: false,\n      dragAndMove: false,\n      offsetSections: false,\n      resetSliders: false,\n      fadingEffect: false,\n      normalScrollElements: null,\n      scrollOverflow: true,\n      scrollOverflowReset: false,\n      skipIntermediateItems: false,\n      touchSensitivity: 5,\n      touchWrapper: null,\n      bigSectionsDestination: null,\n      adjustOnNavChange: true,\n      //Accessibility\n      keyboardScrolling: true,\n      animateAnchor: true,\n      recordHistory: true,\n      allowCorrectDirection: false,\n      //design\n      scrollOverflowMacStyle: true,\n      controlArrows: true,\n      controlArrowsHTML: ['<div class=\"' + SLIDES_STYLED_ARROW + '\"></div>', '<div class=\"' + SLIDES_STYLED_ARROW + '\"></div>'],\n      controlArrowColor: '#fff',\n      verticalCentered: true,\n      sectionsColor: [],\n      paddingTop: 0,\n      paddingBottom: 0,\n      fixedElements: null,\n      responsive: 0,\n      //backwards compabitility with responsiveWiddth\n      responsiveWidth: 0,\n      responsiveHeight: 0,\n      responsiveSlides: false,\n      parallax: false,\n      parallaxOptions: {\n        type: 'reveal',\n        percentage: 62,\n        property: 'translate'\n      },\n      cards: false,\n      cardsOptions: {\n        perspective: 100,\n        fadeContent: true,\n        fadeBackground: true\n      },\n      //Custom selectors\n      sectionSelector: SECTION_DEFAULT_SEL,\n      slideSelector: SLIDE_DEFAULT_SEL,\n      //events\n      afterLoad: null,\n      beforeLeave: null,\n      onLeave: null,\n      afterRender: null,\n      afterResize: null,\n      afterReBuild: null,\n      afterSlideLoad: null,\n      onSlideLeave: null,\n      afterResponsive: null,\n      onScrollOverflow: null,\n      lazyLoading: true,\n      lazyLoadThreshold: 0,\n      observer: true,\n      scrollBeyondFullpage: true\n    };\n\n    var container = null;\n    var g_initialAnchorsInDom = false;\n    var originals = deepExtend({}, defaultOptions); //deep copy\n\n    var g_options = null;\n    function getInitialAnchorsInDom() {\n      return g_initialAnchorsInDom;\n    }\n    function setContainer(value) {\n      container = value;\n    }\n    function getContainer(value) {\n      return container;\n    }\n    function getOptions() {\n      return g_options || defaultOptions;\n    }\n    function setOptions(options) {\n      g_options = deepExtend({}, defaultOptions, options);\n      originals = Object.assign({}, g_options);\n    }\n    function getOriginals() {\n      return originals;\n    }\n    function setOption(name, value) {\n      defaultOptions[name] = value;\n    }\n    /*\n    * Sets the state for a variable with multiple states (original, and temporal)\n    * Some variables such as `autoScrolling` or `recordHistory` might change automatically its state when using `responsive` or `autoScrolling:false`.\n    * This function is used to keep track of both states, the original and the temporal one.\n    * If type is not 'internal', then we assume the user is globally changing the variable.\n    */\n\n    function setVariableState(variable, value, type) {\n      g_options[variable] = value;\n\n      if (type !== 'internal') {\n        originals[variable] = value;\n      }\n    }\n    /**\n    * Setting options from DOM elements if they are not provided.\n    */\n\n    function setOptionsFromDOM() {\n      //no anchors option? Checking for them in the DOM attributes\n      if (!getOptions().anchors.length) {\n        var anchorsAttribute = '[data-anchor]';\n        var anchors = $(getOptions().sectionSelector.split(',').join(anchorsAttribute + ',') + anchorsAttribute, container);\n\n        if (anchors.length && anchors.length === $(getOptions().sectionSelector, container).length) {\n          g_initialAnchorsInDom = true;\n          anchors.forEach(function (item) {\n            getOptions().anchors.push(getAttr(item, 'data-anchor').toString());\n          });\n        }\n      } //no tooltips option? Checking for them in the DOM attributes\n\n\n      if (!getOptions().navigationTooltips.length) {\n        var tooltipsAttribute = '[data-tooltip]';\n        var tooltips = $(getOptions().sectionSelector.split(',').join(tooltipsAttribute + ',') + tooltipsAttribute, container);\n\n        if (tooltips.length) {\n          tooltips.forEach(function (item) {\n            getOptions().navigationTooltips.push(getAttr(item, 'data-tooltip').toString());\n          });\n        }\n      }\n    }\n\n    var plainItem = function plainItem(panel) {\n      this.anchor = panel.anchor;\n      this.item = panel.item;\n      this.index = panel.index();\n      this.isLast = this.index === panel.item.parentElement.querySelectorAll(panel.selector).length - 1;\n      this.isFirst = !this.index;\n      this.isActive = panel.isActive;\n    };\n    /**\n    * Item. Slide or Section objects share the same properties.\n    */\n\n    var Item = function Item(el, selector) {\n      this.parent = this.parent || null;\n      this.selector = selector;\n      this.anchor = getAttr(el, 'data-anchor') || getOptions().anchors[index(el, getOptions().sectionSelector)];\n      this.item = el;\n      this.isVisible = isVisible(el);\n      this.isActive = hasClass(el, ACTIVE);\n      this.hasScroll = hasClass(el, OVERFLOW) || $(OVERFLOW_SEL, el)[0] != null;\n      this.isSection = selector === getOptions().sectionSelector;\n      this.container = closest(el, SLIDES_CONTAINER_SEL) || closest(el, WRAPPER_SEL);\n\n      this.index = function () {\n        return this.siblings().indexOf(this);\n      };\n    };\n\n    Item.prototype.siblings = function () {\n      if (this.isSection) {\n        if (this.isVisible) {\n          return state.sections;\n        } else {\n          return state.sectionsIncludingHidden;\n        }\n      }\n\n      return this.parent ? this.parent.slides : 0;\n    };\n\n    Item.prototype.prev = function () {\n      var siblings = this.siblings();\n      var currentIndex = this.isSection ? siblings.indexOf(this) : this.parent.slides.indexOf(this);\n      var prevIndex = currentIndex - 1;\n\n      if (prevIndex >= 0) {\n        return siblings[prevIndex];\n      }\n\n      return null;\n    };\n\n    Item.prototype.next = function () {\n      var siblings = this.siblings();\n      var currentIndex = this.isSection ? siblings.indexOf(this) : this.parent.slides.indexOf(this);\n      var nextIndex = currentIndex + 1;\n\n      if (nextIndex < siblings.length) {\n        return siblings[nextIndex];\n      }\n\n      return null;\n    };\n\n    Item.prototype[\"prevPanel\"] = function () {\n      return this.prev() || (this.parent ? this.parent.prev() : null);\n    };\n\n    Item.prototype[\"nextPanel\"] = function () {\n      return this.next() || (this.parent ? this.parent.next() : null);\n    };\n\n    Item.prototype.getSiblings = function () {\n      if (this.isSection) {\n        return state.sections;\n      }\n\n      return state.panels;\n    };\n\n    function getNodes(panels) {\n      return panels.map(function (panel) {\n        return panel.item;\n      });\n    }\n    function getPanelByElement(panels, el) {\n      return panels.find(function (panel) {\n        return panel.item === el;\n      });\n    }\n    var Section = function Section(el) {\n      plainItem.call(this, el);\n    };\n    var Slide = function Slide(el) {\n      plainItem.call(this, el);\n    };\n\n    /**\n    * Gets the active slide (or section) for the given section\n    */\n\n    function getSlideOrSection(destiny) {\n      var slide = $(SLIDE_ACTIVE_SEL, destiny);\n\n      if (slide.length) {\n        destiny = slide[0];\n      }\n\n      return destiny;\n    }\n    function getSlideOrSectionPanel(panel) {\n      if (!panel) {\n        return null;\n      }\n\n      return panel.activeSlide ? panel.activeSlide : panel;\n    }\n    function isFullPageAbove() {\n      return getContainer().getBoundingClientRect().bottom >= 0;\n    }\n    /**\n    * Gets the scrolling settings depending on the plugin autoScrolling option\n    */\n\n    function getScrollSettings(top) {\n      var options = getOptions();\n      var position;\n      var element; //top property animation\n\n      if (options.autoScrolling && !options.scrollBar) {\n        position = -top;\n        element = $(WRAPPER_SEL)[0];\n      } //window real scrolling\n      else {\n        position = top;\n        element = window;\n      }\n\n      return {\n        options: position,\n        element: element\n      };\n    }\n    /**\n    * Scrolls the page / slider the given number of pixels.\n    * It will do it one or another way dependiong on the library's config.\n    */\n\n    function setScrolling(element, val) {\n      if (!getOptions().autoScrolling || getOptions().scrollBar || element.self != window && hasClass(element, SLIDES_WRAPPER)) {\n        //scrolling horizontally through the slides?\n        if (element.self != window && hasClass(element, SLIDES_WRAPPER)) {\n          element.scrollLeft = val;\n        } //vertical scroll\n        else {\n          element.scrollTo(0, val);\n        }\n      } else {\n        element.style.top = val + 'px';\n      }\n    }\n    /**\n    * Adds transition animations for the given element\n    */\n\n    function addAnimation(element) {\n      var transition = 'transform ' + getOptions().scrollingSpeed + 'ms ' + getOptions().easingcss3;\n      removeClass(element, NO_TRANSITION);\n      return css(element, {\n        '-webkit-transition': transition,\n        'transition': transition\n      });\n    }\n    /**\n    * Retuns `up` or `down` depending on the scrolling movement to reach its destination\n    * from the current section.\n    */\n\n    function getYmovement(activeSection, destiny) {\n      var fromIndex = activeSection.index();\n      var toIndex = index(destiny, SECTION_SEL);\n\n      if (fromIndex == toIndex) {\n        return 'none';\n      }\n\n      if (fromIndex > toIndex) {\n        return 'up';\n      }\n\n      return 'down';\n    }\n    /**\n    * Remove transition animations for the given element\n    */\n\n    function removeAnimation(element) {\n      return addClass(element, NO_TRANSITION);\n    }\n    /**\n    * Returns the cross-browser transform string.\n    */\n\n    function getTransforms(translate3d) {\n      return {\n        '-webkit-transform': translate3d,\n        '-moz-transform': translate3d,\n        '-ms-transform': translate3d,\n        'transform': translate3d\n      };\n    }\n\n    var silentScrollId;\n    /**\n    * Adds a css3 transform property to the container class with or without animation depending on the animated param.\n    */\n\n    function transformContainer(translate3d, animated) {\n      if (animated) {\n        addAnimation(getContainer());\n      } else {\n        removeAnimation(getContainer());\n      }\n\n      clearTimeout(silentScrollId);\n      css(getContainer(), getTransforms(translate3d));\n      FP.test.translate3d = translate3d; //syncronously removing the class after the animation has been applied.\n\n      silentScrollId = setTimeout(function () {\n        removeClass(getContainer(), NO_TRANSITION);\n      }, 10);\n    }\n\n    /**\n    * Scrolls silently (with no animation) the page to the given Y position.\n    */\n\n    function silentScroll(top) {\n      // The first section can have a negative value in iOS 10. Not quite sure why: -0.0142822265625\n      // that's why we round it to 0.\n      var roundedTop = Math.round(top);\n\n      if (getOptions().css3 && getOptions().autoScrolling && !getOptions().scrollBar) {\n        var translate3d = 'translate3d(0px, -' + roundedTop + 'px, 0px)';\n        transformContainer(translate3d, false);\n      } else if (getOptions().autoScrolling && !getOptions().scrollBar) {\n        css(getContainer(), {\n          'top': -roundedTop + 'px'\n        });\n        FP.test.top = -roundedTop + 'px';\n      } else {\n        var scrollSettings = getScrollSettings(roundedTop);\n        setScrolling(scrollSettings.element, scrollSettings.options);\n      }\n    }\n\n    FP.setScrollingSpeed = setScrollingSpeed;\n    /**\n    * Defines the scrolling speed\n    */\n\n    function setScrollingSpeed(value, type) {\n      setVariableState('scrollingSpeed', value, type);\n    }\n\n    var $body = null;\n    var $html = null;\n    var $htmlBody = null; // caching common elements\n\n    function setCache() {\n      $body = $('body')[0];\n      $html = $('html')[0];\n      $htmlBody = $('html, body');\n    }\n\n    //@ts-check\n\n    var _g_animateScroll;\n    /**\n    * Simulates the animated scrollTop of jQuery. Used when css3:false or scrollBar:true or autoScrolling:false\n    * http://stackoverflow.com/a/16136789/1081396\n    */\n\n\n    function scrollTo(element, to, duration, callback) {\n      var start = getScrolledPosition(element);\n      var change = to - start;\n      var isCallbackFired = false;\n      var startTime;\n      var wasAnimationActive = state.activeAnimation;\n      setState({\n        activeAnimation: true\n      }); // Cancelling any possible previous animations (io: clicking on nav dots very fast)\n\n      if (_g_animateScroll) {\n        window.cancelAnimationFrame(_g_animateScroll);\n      }\n\n      _g_animateScroll = function g_animateScroll(timestamp) {\n        if (!startTime) {\n          startTime = timestamp;\n        }\n\n        var currentTime = Math.floor(timestamp - startTime);\n\n        if (state.activeAnimation) {\n          //in order to stope it from other function whenever we want\n          var val = to;\n\n          if (duration) {\n            // @ts-ignore\n            val = win.fp_easings[getOptions().easing](currentTime, start, change, duration);\n          }\n\n          if (currentTime <= duration) {\n            setScrolling(element, val);\n          }\n\n          if (currentTime < duration) {\n            window.requestAnimationFrame(_g_animateScroll);\n          } else if (typeof callback !== 'undefined' && !isCallbackFired) {\n            setScrolling(element, to);\n            callback();\n            setState({\n              activeAnimation: false\n            });\n            isCallbackFired = true;\n          }\n        } else if (!isCallbackFired && !wasAnimationActive) {\n          callback();\n          setState({\n            activeAnimation: false\n          });\n          isCallbackFired = true;\n        }\n      };\n\n      window.requestAnimationFrame(_g_animateScroll);\n    }\n    /**\n    * Getting the position of the element to scroll when using jQuery animations\n    */\n\n    function getScrolledPosition(element) {\n      var position; //is not the window element and is a slide?\n\n      if (element.self != win && hasClass(element, SLIDES_WRAPPER)) {\n        position = element.scrollLeft;\n      } else if (!getOptions().autoScrolling || getOptions().scrollBar) {\n        position = getScrollTop();\n      } else {\n        position = element.offsetTop;\n      } //gets the top property of the wrapper\n\n\n      return position;\n    }\n\n    /**\n    * Makes sure to only create a Panel object if the element exist\n    */\n\n    function nullOrSection(el) {\n      if (el && !el.item) {\n        return new Section(new SectionPanel(el));\n      }\n\n      return el ? new Section(el) : null;\n    }\n\n    function nullOrSlide(el) {\n      return el ? new Slide(el) : null;\n    }\n\n    /**\n    * Dispatch events & callbacks\n    */\n\n    function fireCallback(eventName, v) {\n      var eventData = getEventData(eventName, v);\n      trigger(getContainer(), eventName, eventData);\n\n      if (getOptions()[eventName].apply(eventData[Object.keys(eventData)[0]], toArray(eventData)) === false) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n    * Gets the event's data for the given event on the right format.\n    */\n\n    function getEventData(eventName, v) {\n      //using functions to run only the necessary bits within the object\n      var paramsPerEvent = {\n        afterRender: function afterRender() {\n          return {\n            section: nullOrSection(getState().activeSection),\n            slide: nullOrSlide(getState().activeSection.activeSlide)\n          };\n        },\n        onLeave: function onLeave() {\n          return {\n            origin: nullOrSection(v.items.origin),\n            destination: nullOrSection(v.items.destination),\n            direction: v.direction,\n            trigger: getState().scrollTrigger\n          };\n        },\n        afterLoad: function afterLoad() {\n          return paramsPerEvent.onLeave();\n        },\n        afterSlideLoad: function afterSlideLoad() {\n          return {\n            section: nullOrSection(v.items.section),\n            origin: nullOrSection(v.items.origin),\n            destination: nullOrSection(v.items.destination),\n            direction: v.direction,\n            trigger: getState().scrollTrigger\n          };\n        },\n        onSlideLeave: function onSlideLeave() {\n          return paramsPerEvent.afterSlideLoad();\n        },\n        beforeLeave: function beforeLeave() {\n          return paramsPerEvent.onLeave();\n        },\n        onScrollOverflow: function onScrollOverflow() {\n          return {\n            section: nullOrSection(getState().activeSection),\n            slide: nullOrSlide(getState().activeSection.activeSlide),\n            position: v.position,\n            direction: v.direction\n          };\n        }\n      };\n      return paramsPerEvent[eventName]();\n    }\n\n    function hasAutoPlay(item) {\n      return item.hasAttribute('data-autoplay') || item.hasAttribute('autoplay');\n    }\n    /**\n    * Plays video and audio elements.\n    */\n\n\n    function playMedia(destiny) {\n      var panel = getSlideOrSection(destiny); //playing HTML5 media elements\n\n      $('video, audio', panel).forEach(function (element) {\n        if (hasAutoPlay(element) && typeof element.play === 'function') {\n          element.play();\n        }\n      }); //youtube videos\n\n      $('iframe[src*=\"youtube.com/embed/\"]', panel).forEach(function (element) {\n        if (hasAutoPlay(element)) {\n          playYoutube(element);\n        } //in case the URL was not loaded yet. On page load we need time for the new URL (with the API string) to load.\n\n\n        element.onload = function () {\n          if (hasAutoPlay(element)) {\n            playYoutube(element);\n          }\n        };\n      });\n    }\n    /**\n    * Plays a youtube video\n    */\n\n    function playYoutube(element) {\n      element.contentWindow.postMessage('{\"event\":\"command\",\"func\":\"playVideo\",\"args\":\"\"}', '*');\n    }\n    /**\n    * Stops video and audio elements.\n    */\n\n\n    function stopMedia(destiny) {\n      var panel = getSlideOrSection(destiny); //stopping HTML5 media elements\n\n      $('video, audio', panel).forEach(function (element) {\n        if (!element.hasAttribute('data-keepplaying') && typeof element.pause === 'function') {\n          element.pause();\n        }\n      }); //youtube videos\n\n      $('iframe[src*=\"youtube.com/embed/\"]', panel).forEach(function (element) {\n        if (/youtube\\.com\\/embed\\//.test(getAttr(element, 'src')) && !element.hasAttribute('data-keepplaying')) {\n          element.contentWindow.postMessage('{\"event\":\"command\",\"func\":\"pauseVideo\",\"args\":\"\"}', '*');\n        }\n      });\n    }\n    /*\n    * Enables the Youtube videos API so we can control their flow if necessary.\n    */\n\n    function enableYoutubeAPI() {\n      $('iframe[src*=\"youtube.com/embed/\"]', getContainer()).forEach(function (item) {\n        addURLParam(item, 'enablejsapi=1');\n      });\n    }\n    /**\n    * Adds a new parameter and its value to the `src` of a given element\n    */\n\n    function addURLParam(element, newParam) {\n      var originalSrc = getAttr(element, 'src');\n      element.setAttribute('src', originalSrc + getUrlParamSign(originalSrc) + newParam);\n    }\n    /*\n    * Returns the prefix sign to use for a new parameter in an existen URL.\n    *\n    * @return {String}  ? | &\n    */\n\n\n    function getUrlParamSign(url) {\n      return !/\\?/.test(url) ? '?' : '&';\n    }\n\n    /**\n    * Lazy loads image, video and audio elements.\n    */\n\n    function lazyLoad(destiny) {\n      if (!getOptions().lazyLoading) {\n        return;\n      }\n\n      var panel = getSlideOrSection(destiny);\n      $('img[data-src], img[data-srcset], source[data-src], source[data-srcset], video[data-src], audio[data-src], iframe[data-src]', panel).forEach(function (element) {\n        ['src', 'srcset'].forEach(function (type) {\n          var attribute = getAttr(element, 'data-' + type);\n\n          if (attribute != null && attribute) {\n            setSrc(element, type);\n            element.addEventListener('load', function () {\n            });\n          }\n        });\n\n        if (matches(element, 'source')) {\n          var elementToPlay = closest(element, 'video, audio');\n\n          if (elementToPlay) {\n            elementToPlay.load();\n\n            elementToPlay.onloadeddata = function () {\n            };\n          }\n        }\n      }); // Add fp-loaded class to the panel after lazy loading\n\n      addClass(panel, LOADED);\n    }\n    function lazyLoadPanels(panel) {\n      var lazyLoadThresold = getOptions().lazyLoadThreshold;\n      lazyLoad(panel.item);\n\n      if (lazyLoadThresold) {\n        lazyLoadDirection(panel, 'prev', lazyLoadThresold);\n        lazyLoadDirection(panel, 'next', lazyLoadThresold);\n      }\n    } // Lazy load \"count\" number of panels in a specific direction\n\n    function lazyLoadDirection(startPanel, direction, count) {\n      var currentPanel = startPanel;\n\n      for (var i = 0; i < count && (currentPanel = currentPanel[direction]()); i++) {\n        console.log(currentPanel.item);\n        lazyLoad(currentPanel.item);\n      }\n    }\n\n    /**\n    * Sets a class for the body of the page depending on the active section / slide\n    */\n\n    function setBodyClass() {\n      var section = getState().activeSection.item;\n      var slide = getState().activeSection.activeSlide;\n      var sectionAnchor = getAnchor(section);\n      var text = String(sectionAnchor);\n\n      if (slide) {\n        var slideAnchor = getAnchor(slide.item);\n        text = text + '-' + slideAnchor;\n      } //changing slash for dash to make it a valid CSS style\n\n\n      text = text.replace('/', '-').replace('#', '').replace(/\\s/g, ''); //removing previous anchor classes\n\n      var classRe = new RegExp('\\\\b\\\\s?' + VIEWING_PREFIX + '-[^\\\\s]+\\\\b', \"g\");\n      $body.className = $body.className.replace(classRe, ''); //adding the current anchor\n\n      addClass($body, VIEWING_PREFIX + '-' + text);\n    }\n    /**\n    * Gets the anchor for the given slide / section. Its index will be used if there's none.\n    */\n\n    function getAnchor(element) {\n      if (!element) {\n        return null;\n      }\n\n      var anchor = getAttr(element, 'data-anchor');\n      var elementIndex = index(element); //Slide without anchor link? We take the index instead.\n\n      if (anchor == null) {\n        anchor = elementIndex;\n      }\n\n      return anchor;\n    }\n\n    EventEmitter.on(events.onDestroyAll, onDestroyAll$1);\n\n    function onDestroyAll$1() {\n      setUrlHash('');\n    }\n    /**\n    * Sets the state of the website depending on the active section/slide.\n    * It changes the URL hash when needed and updates the body class.\n    */\n\n\n    function setPageStatus(slideIndex, slideAnchor, anchorLink) {\n      var sectionHash = '';\n\n      if (getOptions().anchors.length && !getOptions().lockAnchors) {\n        //isn't it the first slide?\n        if (slideIndex) {\n          if (anchorLink != null) {\n            sectionHash = anchorLink;\n          } //slide without anchor link? We take the index instead.\n\n\n          if (slideAnchor == null) {\n            slideAnchor = slideIndex;\n          }\n\n          setState({\n            lastScrolledSlide: slideAnchor\n          });\n          setUrlHash(sectionHash + '/' + slideAnchor); //first slide won't have slide anchor, just the section one\n        } else if (slideIndex != null) {\n          setState({\n            lastScrolledSlide: slideAnchor\n          });\n          setUrlHash(anchorLink);\n        } //section without slides\n        else {\n          setUrlHash(anchorLink);\n        }\n      }\n\n      setBodyClass();\n    }\n    /**\n    * Sets the URL hash.\n    */\n\n    function setUrlHash(url) {\n      if (getOptions().recordHistory) {\n        location.hash = url;\n      } else {\n        win.history.replaceState(undefined, undefined, '#' + url);\n      }\n    }\n\n    /**\n    * Gets the name for screen readers for a section/slide navigation bullet.\n    */\n\n    function getBulletLinkName(i, defaultName, item) {\n      var anchor = defaultName === 'Section' ? getOptions().anchors[i] : getAttr(item, 'data-anchor');\n      return encodeURI(getOptions().navigationTooltips[i] || anchor || defaultName + ' ' + (i + 1));\n    }\n\n    function slideBulletHandler(e) {\n      // not all events are cancellable \n      // https://www.uriports.com/blog/easy-fix-for-intervention-ignored-attempt-to-cancel-a-touchmove-event-with-cancelable-false/\n      if (e.cancelable) {\n        preventDefault(e);\n      }\n\n      setState({\n        scrollTrigger: 'horizontalNav'\n      });\n      /*jshint validthis:true */\n\n      var sectionElem = closest(this, SECTION_SEL);\n      var slides = $(SLIDES_WRAPPER_SEL, closest(this, SECTION_SEL))[0];\n      var section = getPanelByElement(getState().sections, sectionElem);\n      var destiny = section.slides[index(closest(this, 'li'))];\n      EventEmitter.emit(events.landscapeScroll, {\n        slides: slides,\n        destination: destiny.item\n      });\n    }\n    /**\n    * Sets the state for the horizontal bullet navigations.\n    */\n\n    function activeSlidesNavigation(slidesNav, slideIndex) {\n      if (getOptions().slidesNavigation && slidesNav != null) {\n        removeClass($(ACTIVE_SEL, slidesNav), ACTIVE);\n        addClass($('a', $('li', slidesNav)[slideIndex]), ACTIVE);\n      }\n    }\n    /**\n    * Creates a landscape navigation bar with dots for horizontal sliders.\n    */\n\n    function addSlidesNavigation(section) {\n      var sectionElem = section.item;\n      var numSlides = section.slides.length;\n      appendTo(createElementFromHTML('<div class=\"' + SLIDES_NAV + '\"><ul></ul></div>'), sectionElem);\n      var nav = $(SLIDES_NAV_SEL, sectionElem)[0]; //top or bottom\n\n      addClass(nav, 'fp-' + getOptions().slidesNavPosition);\n\n      for (var i = 0; i < numSlides; i++) {\n        var slide = $(SLIDE_SEL, sectionElem)[i];\n        appendTo(createElementFromHTML('<li><a href=\"#\"><span class=\"fp-sr-only\">' + getBulletLinkName(i, 'Slide', slide) + '</span><span></span></a></li>'), $('ul', nav)[0]);\n      } //centering it\n\n\n      css(nav, {\n        'margin-left': '-' + nav.innerWidth / 2 + 'px'\n      });\n      var activeSlideIndex = section.activeSlide ? section.activeSlide.index() : 0;\n      addClass($('a', $('li', nav)[activeSlideIndex]), ACTIVE);\n    }\n\n    var isScrollAllowed = {};\n    isScrollAllowed.m = {\n      'up': true,\n      'down': true,\n      'left': true,\n      'right': true\n    };\n    isScrollAllowed.k = deepExtend({}, isScrollAllowed.m);\n    /**\n    * Allowing or disallowing the mouse/swipe scroll in a given direction. (not for keyboard)\n    * @param type m (mouse) or k (keyboard)\n    */\n\n    function setIsScrollAllowed(value, direction, type) {\n      //up, down, left, right\n      if (direction !== 'all') {\n        isScrollAllowed[type][direction] = value;\n      } //all directions?\n      else {\n        Object.keys(isScrollAllowed[type]).forEach(function (key) {\n          isScrollAllowed[type][key] = value;\n        });\n      }\n    }\n    function getIsScrollAllowed() {\n      return isScrollAllowed;\n    }\n\n    EventEmitter.on(events.onClickOrTouch, onClickOrTouch$2);\n\n    function onClickOrTouch$2(params) {\n      var target = params.target;\n\n      if (matches(target, SLIDES_ARROW_SEL) || closest(target, SLIDES_ARROW_SEL)) {\n        slideArrowHandler.call(target, params);\n      }\n    } //Scrolling horizontally when clicking on the slider controls.\n\n\n    function slideArrowHandler() {\n      /*jshint validthis:true */\n      var section = closest(this, SECTION_SEL);\n      var isPrevArrow = hasClass(this, SLIDES_PREV) || closest(this, SLIDES_PREV_SEL);\n      /*jshint validthis:true */\n\n      if (isPrevArrow) {\n        if (getIsScrollAllowed().m.left) {\n          setState({\n            scrollTrigger: 'slideArrow'\n          });\n          EventEmitter.emit(events.moveSlideLeft, {\n            section: section\n          });\n        }\n      } else {\n        if (getIsScrollAllowed().m.right) {\n          setState({\n            scrollTrigger: 'slideArrow'\n          });\n          EventEmitter.emit(events.moveSlideRight, {\n            section: section\n          });\n        }\n      }\n    }\n    /**\n    * Creates the control arrows for the given section\n    */\n\n\n    function createSlideArrows(section) {\n      var sectionElem = section.item;\n      var arrows = [createElementFromHTML(getOptions().controlArrowsHTML[0]), createElementFromHTML(getOptions().controlArrowsHTML[1])];\n      after($(SLIDES_WRAPPER_SEL, sectionElem)[0], arrows);\n      addClass(arrows, SLIDES_ARROW);\n      addClass(arrows[0], SLIDES_PREV);\n      addClass(arrows[1], SLIDES_NEXT);\n\n      if (getOptions().controlArrowColor !== '#fff') {\n        css($(SLIDES_ARROW_NEXT_SEL, sectionElem), {\n          'border-color': 'transparent transparent transparent ' + getOptions().controlArrowColor\n        });\n        css($(SLIDES_ARROW_PREV_SEL, sectionElem), {\n          'border-color': 'transparent ' + getOptions().controlArrowColor + ' transparent transparent'\n        });\n      }\n\n      if (!getOptions().loopHorizontal) {\n        hide($(SLIDES_ARROW_PREV_SEL, sectionElem));\n      }\n    }\n    function toggleControlArrows(v) {\n      if (!getOptions().loopHorizontal && getOptions().controlArrows) {\n        //hidding it for the fist slide, showing for the rest\n        toggle($(SLIDES_ARROW_PREV_SEL, v.section), v.slideIndex !== 0); //hidding it for the last slide, showing for the rest\n\n        toggle($(SLIDES_ARROW_NEXT_SEL, v.section), next(v.destiny) != null);\n      }\n    }\n\n    FP.setRecordHistory = setRecordHistory;\n    /**\n    * Defines wheter to record the history for each hash change in the URL.\n    */\n\n    function setRecordHistory(value, type) {\n      setVariableState('recordHistory', value, type);\n    }\n\n    FP.setAutoScrolling = setAutoScrolling;\n    FP.test.setAutoScrolling = setAutoScrolling;\n    /**\n    * Sets the autoScroll option.\n    * It changes the scroll bar visibility and the history of the site as a result.\n    */\n\n    function setAutoScrolling(value, type) {\n      //removing the transformation\n      if (!value) {\n        silentScroll(0);\n      }\n\n      setVariableState('autoScrolling', value, type);\n      var element = getState().activeSection.item;\n\n      if (getOptions().autoScrolling && !getOptions().scrollBar) {\n        css($htmlBody, {\n          'overflow': 'hidden',\n          'height': '100%'\n        });\n        removeClass($body, SCROLLABLE);\n        setRecordHistory(getOriginals().recordHistory, 'internal'); //for IE touch devices\n\n        css(getContainer(), {\n          '-ms-touch-action': 'none',\n          'touch-action': 'none'\n        });\n\n        if (element != null) {\n          //moving the container up\n          silentScroll(element.offsetTop);\n        }\n      } else {\n        css($htmlBody, {\n          'overflow': 'visible',\n          'height': 'initial'\n        });\n        addClass($body, SCROLLABLE);\n        var recordHistory = !getOptions().autoScrolling ? false : getOriginals().recordHistory;\n        setRecordHistory(recordHistory, 'internal'); //for IE touch devices\n\n        css(getContainer(), {\n          '-ms-touch-action': '',\n          'touch-action': ''\n        }); //scrolling the page to the section with no animation\n\n        if (element != null) {\n          var scrollSettings = getScrollSettings(element.offsetTop);\n          scrollSettings.element.scrollTo(0, scrollSettings.options);\n        }\n      }\n    }\n\n    function getTmpPosition(v) {\n      return hasClass(getState().activeSection.item, AUTO_HEIGHT) ? getDestinationPosition(getState().activeSection.item) : getState().activeSection.item.offsetTop;\n    }\n    function getDestinationPosForInfiniteScroll(v) {\n      // forcing the scroll to the bottom of the fp-auto-height section when scrolling up\n      if (v.isMovementUp && hasClass(v.element, AUTO_HEIGHT)) {\n        return getDestinationPosition(v.element) - getWindowHeight() + v.element.offsetHeight;\n      }\n\n      return v.element.offsetTop;\n    }\n\n    //@ts-check\n    /**\n    * Adds sections before or after the current one to create the infinite effect.\n    */\n\n    function createInfiniteSections(v) {\n      setState({\n        isDoingContinousVertical: true\n      });\n      var activeSectionItem = getState().activeSection.item; // Scrolling down\n\n      if (!v.isMovementUp) {\n        // Move all previous sections to after the active section\n        var prevSectionsReversed = prevAll(activeSectionItem, SECTION_SEL).reverse();\n        after(activeSectionItem, prevSectionsReversed[0]);\n      } else {\n        // Scrolling up\n        // Move all next sections to before the active section\n        before(activeSectionItem, nextAll(activeSectionItem, SECTION_SEL));\n      } // Maintain the displayed position (now that we changed the element order)\n\n\n      silentScroll(getTmpPosition()); // Maintain the active slides visible in the viewport\n\n      keepSlidesPosition$1(); // save for later the elements that still need to be reordered\n\n      v.wrapAroundElements = activeSectionItem; // Recalculate animation variables\n\n      v.dtop = getDestinationPosForInfiniteScroll(v);\n      v.yMovement = getYmovement(getState().activeSection, v.element);\n      return v;\n    }\n    /**\n    * Maintains the active slides in the viewport\n    * (Because the `scroll` animation might get lost with some actions, such as when using continuousVertical)\n    */\n\n    function keepSlidesPosition$1() {\n      var activeSlides = $(SLIDE_ACTIVE_SEL);\n\n      for (var i = 0; i < activeSlides.length; i++) {\n        silentLandscapeScroll(activeSlides[i], 'internal');\n      }\n    }\n\n    //@ts-check\n    /**\n    * Maintains the active slides in the viewport\n    * (Because the `scroll` animation might get lost with some actions, such as when using continuousVertical)\n    */\n\n    function keepSlidesPosition() {\n      var activeSlides = $(SLIDE_ACTIVE_SEL);\n\n      for (var i = 0; i < activeSlides.length; i++) {\n        silentLandscapeScroll(activeSlides[i], 'internal');\n      }\n    }\n    /**\n    * Fix section order after continuousVertical changes have been animated\n    */\n\n\n    function continuousVerticalFixSectionOrder(v) {\n      // If continuousVertical is in effect (and autoScrolling would also be in effect then),\n      // finish moving the elements around so the direct navigation will function more simply\n      if (v.wrapAroundElements == null) {\n        return;\n      }\n\n      if (v.isMovementUp) {\n        before($(SECTION_SEL)[0], v.wrapAroundElements);\n      } else {\n        after($(SECTION_SEL)[getState().sections.length - 1], prevAll(v.element, SECTION_SEL).reverse());\n      }\n\n      silentScroll(getTmpPosition()); // Maintain the active slides visible in the viewport\n\n      keepSlidesPosition();\n      setState({\n        isDoingContinousVertical: false\n      });\n    }\n\n    /**\n    * Makes sure lazyload is done for other sections in the viewport that are not the\n    * active one. \n    */\n\n    function lazyLoadOthers() {\n      var hasAutoHeightSections = $(AUTO_HEIGHT_SEL)[0] || isResponsiveMode() && $(AUTO_HEIGHT_RESPONSIVE_SEL)[0]; //quitting when it doesn't apply\n\n      if (!getOptions().lazyLoading || !hasAutoHeightSections) {\n        return;\n      } //making sure to lazy load auto-height sections that are in the viewport\n\n\n      $(SECTION_SEL + ':not(' + ACTIVE_SEL + ')').forEach(function (section) {\n        if (isSectionInViewport(section)) {\n          lazyLoadPanels(getPanelByElement(getState().sections, section));\n        }\n      });\n    }\n    /**\n    * Determines whether a section is in the viewport or not.\n    */\n\n    function isSectionInViewport(el) {\n      var rect = el.getBoundingClientRect();\n      var top = rect.top;\n      var bottom = rect.bottom; //sometimes there's a 1px offset on the bottom of the screen even when the \n      //section's height is the window.innerHeight one. I guess because pixels won't allow decimals.\n      //using this prevents from lazyLoading the section that is not yet visible \n      //(only 1 pixel offset is)\n\n      var pixelOffset = 2;\n      var isTopInView = top + pixelOffset < state.windowsHeight && top > 0;\n      var isBottomInView = bottom > pixelOffset && bottom < state.windowsHeight;\n      return isTopInView || isBottomInView;\n    }\n\n    function tooltipTextHandler() {\n      /*jshint validthis:true */\n      trigger(prev(this), 'click');\n    }\n    /**\n    * Activating the vertical navigation bullets according to the given slide name.\n    */\n\n    function activateNavDots(name, sectionIndex) {\n      var nav = $(SECTION_NAV_SEL)[0];\n\n      if (getOptions().navigation && nav != null && nav.style.display !== 'none') {\n        removeClass($(ACTIVE_SEL, nav), ACTIVE);\n\n        if (name) {\n          addClass($('a[href=\"#' + name + '\"]', nav), ACTIVE);\n        } else {\n          addClass($('a', $('li', nav)[sectionIndex]), ACTIVE);\n        }\n      }\n    }\n    /**\n    * Creates a vertical navigation bar.\n    */\n\n    function addVerticalNavigation() {\n      remove($(SECTION_NAV_SEL));\n      var navigation = doc.createElement('div');\n      navigation.setAttribute('id', SECTION_NAV);\n      var divUl = doc.createElement('ul');\n      navigation.appendChild(divUl);\n      appendTo(navigation, $body);\n      var nav = $(SECTION_NAV_SEL)[0];\n      addClass(nav, 'fp-' + getOptions().navigationPosition);\n\n      if (getOptions().showActiveTooltip) {\n        addClass(nav, SHOW_ACTIVE_TOOLTIP);\n      }\n\n      var li = '';\n\n      for (var i = 0; i < getState().sections.length; i++) {\n        var section = getState().sections[i];\n        var link = '';\n\n        if (getOptions().anchors.length) {\n          link = section.anchor;\n        }\n\n        li += '<li><a href=\"#' + encodeURI(link) + '\"><span class=\"fp-sr-only\">' + getBulletLinkName(section.index(), 'Section') + '</span><span></span></a>'; // Only add tooltip if needed (defined by user)\n\n        var tooltip = getOptions().navigationTooltips[section.index()];\n\n        if (typeof tooltip !== 'undefined' && tooltip !== '') {\n          li += '<div class=\"' + SECTION_NAV_TOOLTIP + ' fp-' + getOptions().navigationPosition + '\">' + tooltip + '</div>';\n        }\n\n        li += '</li>';\n      }\n\n      $('ul', nav)[0].innerHTML = li; //activating the current active section\n\n      var bullet = $('li', $(SECTION_NAV_SEL)[0])[getState().activeSection.index()];\n      addClass($('a', bullet), ACTIVE);\n    } //Scrolls to the section when clicking the navigation bullet\n\n    function sectionBulletHandler(e) {\n      if (e.preventDefault) {\n        preventDefault(e);\n      }\n\n      setState({\n        scrollTrigger: 'verticalNav'\n      });\n      /*jshint validthis:true */\n      // @ts-ignore\n\n      var indexBullet = index(closest(this, SECTION_NAV_SEL + ' li'));\n      EventEmitter.emit(events.scrollPage, {\n        destination: getState().sections[indexBullet]\n      });\n    }\n\n    /**\n    * Sets to active the current menu and vertical nav items.\n    */\n\n    function activateMenuAndNav(anchor, index) {\n      activateMenuElement(anchor);\n      activateNavDots(anchor, index);\n    }\n    /**\n    * Activating the website main menu elements according to the given slide name.\n    */\n\n    function activateMenuElement(name) {\n      if (getOptions().menu && getOptions().menu.length) {\n        $(getOptions().menu).forEach(function (menu) {\n          if (menu != null) {\n            removeClass($(ACTIVE_SEL, menu), ACTIVE);\n            addClass($('[data-menuanchor=\"' + name + '\"]', menu), ACTIVE);\n          }\n        });\n      }\n    }\n\n    new Date().getTime();\n    /**\n     * Triggers the callback once per scroll wheel action.\n     * Based on scrolling speed delay.\n     */\n\n    var oncePerScroll = function () {\n      var canTriggerEvent = true;\n      var prevWheelTime = new Date().getTime();\n      var result;\n      var isScrollingOnInit = !win.fullpage_api;\n      return function (scrollTrigger, callback) {\n        var currentTime = new Date().getTime();\n        var timeThreshold = scrollTrigger === 'wheel' ? getOptions().scrollingSpeed : 100;\n        canTriggerEvent = isScrollingOnInit || currentTime - prevWheelTime >= timeThreshold;\n        isScrollingOnInit = !win.fullpage_api;\n\n        if (canTriggerEvent) {\n          result = callback();\n          prevWheelTime = currentTime;\n        }\n\n        return typeof result !== 'undefined' ? result : true;\n      };\n    }();\n\n    /**\n    * Fires the wheel event once per mouse wheel trigger.\n    */\n\n    function fireCallbackOncePerScroll(callbackName, params) {\n      if (!isFunction(getOptions().beforeLeave)) {\n        return;\n      }\n\n      var result = oncePerScroll(getState().scrollTrigger, function () {\n        return fireCallback(callbackName, params);\n      });\n      return result;\n    }\n\n    FP.moveTo = moveTo;\n\n    FP.getScrollY = function () {\n      return state.scrollY;\n    };\n\n    var g_afterSectionLoadsId;\n    var g_transitionLapseId;\n    EventEmitter.on(events.onDestroy, onDestroy$8);\n    /**\n    * Scrolls the site to the given element and scrolls to the slide if a callback is given.\n    */\n\n    function scrollPage(section, callback, isMovementUp) {\n      var element = section.item;\n\n      if (element == null) {\n        return;\n      } //there's no element to scroll, leaving the function\n\n\n      var dtop = getDestinationPosition(element);\n      var slideAnchorLink;\n      var slideIndex; //local variables\n\n      var v = {\n        \"element\": element,\n        \"callback\": callback,\n        \"isMovementUp\": isMovementUp,\n        \"dtop\": dtop,\n        \"yMovement\": getYmovement(getState().activeSection, element),\n        \"anchorLink\": section.anchor,\n        \"sectionIndex\": section.index(),\n        \"activeSlide\": section.activeSlide ? section.activeSlide.item : null,\n        \"leavingSection\": getState().activeSection.index() + 1,\n        //caching the value of isResizing at the momment the function is called\n        //because it will be checked later inside a setTimeout and the value might change\n        \"localIsResizing\": state.isResizing,\n        \"items\": {\n          \"origin\": getState().activeSection,\n          \"destination\": section\n        },\n        \"direction\": null\n      }; //quiting when destination scroll is the same as the current one\n\n      if (getState().activeSection.item == element && !state.isResizing || getOptions().scrollBar && getScrollTop() === v.dtop && !hasClass(element, AUTO_HEIGHT)) {\n        return;\n      }\n\n      if (v.activeSlide != null) {\n        slideAnchorLink = getAttr(v.activeSlide, 'data-anchor');\n        slideIndex = index(v.activeSlide, null);\n      } //callback (onLeave) if the site is not just resizing and readjusting the slides\n\n\n      if (!v.localIsResizing) {\n        var direction = v.yMovement; //required for continousVertical\n\n        if (typeof isMovementUp !== 'undefined') {\n          direction = isMovementUp ? 'up' : 'down';\n        } //for the callback\n\n\n        v.direction = direction;\n\n        if (isFunction(getOptions().beforeLeave)) {\n          if (fireCallbackOncePerScroll('beforeLeave', v) === false) {\n            return;\n          }\n        }\n\n        if (isFunction(getOptions().onLeave)) {\n          if (!fireCallback('onLeave', v)) {\n            return;\n          }\n        }\n      } // If continuousVertical && we need to wrap around\n\n\n      if (getOptions().autoScrolling && getOptions().continuousVertical && typeof v.isMovementUp !== \"undefined\" && (!v.isMovementUp && v.yMovement == 'up' || // Intending to scroll down but about to go up or\n      v.isMovementUp && v.yMovement == 'down')) {\n        // intending to scroll up but about to go down\n        v = createInfiniteSections(v);\n      } //pausing media of the leaving section (if we are not just resizing, as destinatino will be the same one)\n\n\n      if (!v.localIsResizing) {\n        stopMedia(getState().activeSection.item);\n      }\n\n      addClass(element, ACTIVE);\n      removeClass(siblings(element), ACTIVE);\n      updateState();\n      lazyLoadPanels(section); //preventing from activating the MouseWheelHandler event\n      //more than once if the page is scrolling\n\n      setState({\n        canScroll: FP.test.isTesting\n      });\n      setPageStatus(slideIndex, slideAnchorLink, v.anchorLink);\n      EventEmitter.emit(events.onLeave, v);\n      performMovement(v); //flag to avoid callingn `scrollPage()` twice in case of using anchor links\n\n      setState({\n        lastScrolledDestiny: v.anchorLink\n      }); //avoid firing it twice (as it does also on scroll)\n\n      activateMenuAndNav(v.anchorLink, v.sectionIndex);\n    }\n\n    function onDestroy$8() {\n      clearTimeout(g_afterSectionLoadsId);\n      clearTimeout(g_transitionLapseId);\n    }\n    /**\n    * Returns the destination Y position based on the scrolling direction and\n    * the height of the section.\n    */\n\n\n    function getDestinationPosition(element) {\n      var elementHeight = element.offsetHeight;\n      var elementTop = element.offsetTop; //top of the desination will be at the top of the viewport\n\n      var position = elementTop;\n      var isScrollingDown = elementTop > state.previousDestTop;\n      var sectionBottom = position - getWindowHeight() + elementHeight;\n      var bigSectionsDestination = getOptions().bigSectionsDestination; //is the destination element bigger than the viewport?\n\n      if (elementHeight > getWindowHeight()) {\n        //scrolling up?\n        if (!isScrollingDown && !bigSectionsDestination || bigSectionsDestination === 'bottom') {\n          position = sectionBottom;\n        }\n      } //sections equal or smaller than the viewport height && scrolling down? ||  is resizing and its in the last section\n      else if (isScrollingDown || state.isResizing && next(element) == null) {\n        //The bottom of the destination will be at the bottom of the viewport\n        position = sectionBottom;\n      }\n      /*\n      Keeping record of the last scrolled position to determine the scrolling direction.\n      No conventional methods can be used as the scroll bar might not be present\n      AND the section might not be active if it is auto-height and didnt reach the middle\n      of the viewport.\n      */\n\n\n      setState({\n        previousDestTop: position\n      });\n      return position;\n    }\n    /**\n    * Performs the vertical movement (by CSS3 or by jQuery)\n    */\n\n    function performMovement(v) {\n      setState({\n        touchDirection: 'none',\n        scrollY: Math.round(v.dtop)\n      });\n      EventEmitter.emit(events.onPerformMovement, v);\n      var isFastSpeed = getOptions().scrollingSpeed < 700;\n      var transitionLapse = isFastSpeed ? 700 : getOptions().scrollingSpeed; // using CSS3 translate functionality\n\n      if (getOptions().css3 && getOptions().autoScrolling && !getOptions().scrollBar) {\n        // The first section can have a negative value in iOS 10. Not quite sure why: -0.0142822265625\n        // that's why we round it to 0.\n        var translate3d = 'translate3d(0px, -' + Math.round(v.dtop) + 'px, 0px)';\n        transformContainer(translate3d, true); //even when the scrollingSpeed is 0 there's a little delay, which might cause the\n        //scrollingSpeed to change in case of using silentMoveTo();ç\n\n        if (getOptions().scrollingSpeed) {\n          clearTimeout(g_afterSectionLoadsId);\n          g_afterSectionLoadsId = setTimeout(function () {\n            afterSectionLoads$1(v); //disabling canScroll when using fastSpeed\n\n            setState({\n              canScroll: !isFastSpeed || FP.test.isTesting\n            });\n          }, getOptions().scrollingSpeed);\n        } else {\n          afterSectionLoads$1(v);\n        }\n      } // using JS to animate\n      else {\n        var scrollSettings = getScrollSettings(v.dtop);\n        FP.test.top = -v.dtop + 'px';\n        clearTimeout(g_afterSectionLoadsId);\n        scrollTo(scrollSettings.element, scrollSettings.options, getOptions().scrollingSpeed, function () {\n          if (getOptions().scrollBar) {\n            /* Hack!\n            The timeout prevents setting the most dominant section in the viewport as \"active\" when the user\n            scrolled to a smaller section by using the mousewheel (auto scrolling) rather than draging the scroll bar.\n             When using scrollBar:true It seems like the scroll events still getting propagated even after the scrolling animation has finished.\n            */\n            g_afterSectionLoadsId = setTimeout(function () {\n              afterSectionLoads$1(v);\n            }, 30);\n          } else {\n            afterSectionLoads$1(v); //disabling canScroll when using fastSpeed\n\n            setState({\n              canScroll: !isFastSpeed || FP.test.isTesting\n            });\n          }\n        });\n      } // enabling canScroll after the minimum transition laps\n\n\n      if (isFastSpeed) {\n        clearTimeout(g_transitionLapseId);\n        g_transitionLapseId = setTimeout(function () {\n          setState({\n            canScroll: true\n          });\n        }, transitionLapse);\n      }\n    }\n    /**\n    * Actions to do once the section is loaded.\n    */\n\n\n    function afterSectionLoads$1(v) {\n      setState({\n        isBeyondFullpage: false\n      });\n      continuousVerticalFixSectionOrder(v); //callback (afterLoad) if the site is not just resizing and readjusting the slides\n\n      if (isFunction(getOptions().afterLoad) && !v.localIsResizing) {\n        fireCallback('afterLoad', v);\n      }\n\n      updateState();\n\n      if (!v.localIsResizing) {\n        playMedia(v.element);\n      }\n\n      addClass(v.element, COMPLETELY);\n      removeClass(siblings(v.element), COMPLETELY);\n      lazyLoadOthers();\n      setState({\n        canScroll: true\n      });\n      EventEmitter.emit(events.afterSectionLoads, v);\n\n      if (isFunction(v.callback)) {\n        v.callback();\n      }\n    }\n\n    FP.setFitToSection = setFitToSection;\n    FP.fitToSection = fitToSection;\n    /**\n    * Sets fitToSection\n    */\n\n    function setFitToSection(value, type) {\n      setVariableState('fitToSection', value, type);\n    }\n    /**\n    * Fits the site to the nearest active section\n    */\n\n    function fitToSection() {\n      //checking fitToSection again in case it was set to false before the timeout delay\n      if (state.canScroll && getOptions().fitToSection) {\n        //allows to scroll to an active section and\n        //if the section is already active, we prevent firing callbacks\n        setState({\n          isResizing: true\n        });\n        scrollPage(state.activeSection);\n        setState({\n          isResizing: false\n        });\n      }\n    }\n\n    FP.setResponsive = setResponsive;\n    /**\n    * Checks if the site needs to get responsive and disables autoScrolling if so.\n    * A class `fp-responsive` is added to the plugin's container in case the user wants to use it for his own responsive CSS.\n    */\n\n    function responsive() {\n      var widthLimit = getOptions().responsive || getOptions().responsiveWidth; //backwards compatiblity\n\n      var heightLimit = getOptions().responsiveHeight; //only calculating what we need. Remember its called on the resize event.\n\n      var isBreakingPointWidth = widthLimit && win.innerWidth < widthLimit;\n      var isBreakingPointHeight = heightLimit && win.innerHeight < heightLimit;\n\n      if (widthLimit && heightLimit) {\n        setResponsive(isBreakingPointWidth || isBreakingPointHeight);\n      } else if (widthLimit) {\n        setResponsive(isBreakingPointWidth);\n      } else if (heightLimit) {\n        setResponsive(isBreakingPointHeight);\n      }\n    }\n    /**\n    * Turns fullPage.js to normal scrolling mode when the viewport `width` or `height`\n    * are smaller than the set limit values.\n    */\n\n    function setResponsive(active) {\n      var isResponsive = isResponsiveMode();\n\n      if (active) {\n        if (!isResponsive) {\n          setAutoScrolling(false, 'internal');\n          setFitToSection(false, 'internal');\n          hide($(SECTION_NAV_SEL));\n          addClass($body, RESPONSIVE);\n\n          if (isFunction(getOptions().afterResponsive)) {\n            getOptions().afterResponsive.call(getContainer(), active);\n          }\n        }\n      } else if (isResponsive) {\n        setAutoScrolling(getOriginals().autoScrolling, 'internal');\n        setFitToSection(getOriginals().autoScrolling, 'internal');\n        show($(SECTION_NAV_SEL));\n        removeClass($body, RESPONSIVE);\n\n        if (isFunction(getOptions().afterResponsive)) {\n          getOptions().afterResponsive.call(getContainer(), active);\n        }\n      }\n    }\n    /**\n    * Determines whether fullpage.js is in responsive mode or not.\n    */\n\n\n    function isResponsiveMode() {\n      return hasClass($body, RESPONSIVE);\n    }\n\n    function addTableClass(element) {\n      if (!getOptions().verticalCentered) {\n        return;\n      } // Overflowing sections when scrollOverflow is disabled will be autoHeight\n      // and won't require vertical aligment\n\n\n      if (!getOptions().scrollOverflow && scrollOverflowHandler.shouldBeScrollable(element.item)) {\n        return;\n      }\n\n      if (!scrollOverflowHandler.isScrollable(element)) {\n        //In case we are styling for the 2nd time as in with reponsiveSlides\n        if (!hasClass(element.item, TABLE)) {\n          addClass(element.item, TABLE);\n        }\n      }\n    }\n\n    var startingSection = null;\n    FP.getActiveSection = getActiveSection;\n    function getStartingSection() {\n      return startingSection;\n    }\n    /**\n    * Styling vertical sections\n    */\n\n    function styleSection(section) {\n      var sectionElem = section.item;\n      var hasSlides = section.allSlidesItems.length;\n      var index = section.index(); //if no active section is defined, the 1st one will be the default one\n\n      if (!getState().activeSection && section.isVisible) {\n        addClass(sectionElem, ACTIVE);\n        updateState();\n      }\n\n      if (!startingSection && section.isVisible) {\n        startingSection = getState().activeSection.item;\n      }\n\n      if (getOptions().paddingTop) {\n        css(sectionElem, {\n          'padding-top': getOptions().paddingTop\n        });\n      }\n\n      if (getOptions().paddingBottom) {\n        css(sectionElem, {\n          'padding-bottom': getOptions().paddingBottom\n        });\n      }\n\n      if (typeof getOptions().sectionsColor[index] !== 'undefined') {\n        css(sectionElem, {\n          'background-color': getOptions().sectionsColor[index]\n        });\n      }\n\n      if (typeof getOptions().anchors[index] !== 'undefined') {\n        sectionElem.setAttribute('data-anchor', section.anchor);\n      }\n\n      if (!hasSlides) {\n        addTableClass(section);\n      }\n    }\n    /**\n    * Gets the active section.\n    */\n\n    function getActiveSection() {\n      return getState().activeSection;\n    }\n\n    function getSectionFromPanel(panel) {\n      return panel.isSection ? panel : panel.parent;\n    }\n\n    var g_focusScrollableId;\n    EventEmitter.on(events.bindEvents, bindEvents$b);\n\n    function bindEvents$b() {\n      // We can't focus scrollOverflow before scrolling\n      // to the anchor (if we need to)\n      EventEmitter.on(events.onAfterRenderNoAnchor, afterRender);\n      EventEmitter.on(events.onLeave, scrollOverflowHandler.onLeave);\n      EventEmitter.on(events.onSlideLeave, scrollOverflowHandler.onLeave);\n      EventEmitter.on(events.afterSlideLoads, scrollOverflowHandler.afterLoad);\n      EventEmitter.on(events.afterSectionLoads, scrollOverflowHandler.afterLoad);\n      EventEmitter.on(events.onDestroy, onDestroy$7);\n      docAddEvent('keyup', scrollOverflowHandler.keyUpHandler);\n    }\n\n    function afterRender() {\n      if (getOptions().scrollOverflow && !getOptions().scrollBar) {\n        scrollOverflowHandler.makeScrollable();\n        scrollOverflowHandler.focusScrollable();\n      }\n    }\n\n    function onDestroy$7() {\n      EventEmitter.removeListener(events.onAfterRenderNoAnchor, afterRender);\n      docRemoveEvent('keyup', scrollOverflowHandler.keyUpHandler);\n    }\n\n    var scrollOverflowHandler = {\n      focusedElem: null,\n      shouldFocusScrollable: true,\n      isInnerScrollAllowed: true,\n      timeBeforeReachingLimit: null,\n      timeLastScroll: null,\n      preventScrollWithMouseWheel: function preventScrollWithMouseWheel(e) {\n        var activeSection = getState().activeSection;\n\n        if (!state.canScroll || isInsideIframe() && getOptions().scrollOverflow && scrollOverflowHandler.isScrollable(activeSection) && scrollOverflowHandler.isScrolled(getState().wheelDirection, activeSection.item)) {\n          preventDefault(e);\n          return false;\n        }\n      },\n      preventScrollWithKeyboard: function preventScrollWithKeyboard(e) {\n        if (!isInsideInput() && getOptions().keyboardScrolling) {\n          var directionKeys = [38, 33, 32, 40, 34, 36, 35];\n\n          if (directionKeys.indexOf(e.keyCode) > -1 && !scrollOverflowHandler.isInnerScrollAllowed) {\n            preventDefault(e);\n            return false;\n          }\n        }\n      },\n      keyUpHandler: function keyUpHandler() {\n        scrollOverflowHandler.shouldFocusScrollable = state.canScroll;\n      },\n      // Leaving sections or slides\n      onLeave: function onLeave() {\n        clearTimeout(g_focusScrollableId);\n        scrollOverflowHandler.isInnerScrollAllowed = false;\n      },\n      // Loading sections or slides\n      afterLoad: function afterLoad() {\n        scrollOverflowHandler.isInnerScrollAllowed = false; // Delaying it to avoid issues on Safari when focusing elements #4484 & #4493\n\n        clearTimeout(g_focusScrollableId);\n        g_focusScrollableId = setTimeout(function () {\n          scrollOverflowHandler.shouldFocusScrollable = state.canScroll;\n        }, 200);\n      },\n      // Unfocusing the scrollable element from the orgin section/slide\n      unfocusScrollable: function unfocusScrollable() {\n        if (doc.activeElement === this.focusedElem) {\n          // @ts-ignore\n          this.focusedElem.blur();\n          scrollOverflowHandler.isInnerScrollAllowed = false;\n        }\n      },\n      focusScrollable: function focusScrollable() {\n        if (!getOptions().scrollOverflow || !scrollOverflowHandler.shouldFocusScrollable) {\n          return;\n        }\n\n        scrollOverflowHandler.unfocusScrollable();\n        var scrollableItem = scrollOverflowHandler.getScrollableItem(getState().activeSection.item); // On desktop we focus the scrollable to be able to use the mouse wheel\n        // We avoid it on mobile due to a bug in iOS Safari\n\n        if (scrollableItem && !isTouchDevice && !isTouch) {\n          this.focusedElem = scrollableItem; // Forcing the focus on the next paint \n          // to avoid issue #4484 & #4493 on Safari\n\n          requestAnimationFrame(function () {\n            scrollableItem.focus({\n              preventScroll: true\n            });\n            scrollOverflowHandler.isInnerScrollAllowed = true;\n          });\n        }\n\n        scrollOverflowHandler.shouldFocusScrollable = false;\n      },\n      makeScrollable: function makeScrollable() {\n        if (getOptions().scrollOverflowMacStyle && !isMacDevice) {\n          addClass($body, 'fp-scroll-mac');\n        }\n\n        getState().panels.forEach(function (el) {\n          if (el.slides && el.slides.length) {\n            return;\n          }\n\n          if (hasClass(el.item, AUTO_HEIGHT_RESPONSIVE) && isResponsiveMode()) {\n            return;\n          } else {\n            var item = getSlideOrSection(el.item);\n            var shouldBeScrollable = scrollOverflowHandler.shouldBeScrollable(el.item);\n            var section = getSectionFromPanel(el);\n\n            if (isIE11) {\n              var toggleAction = shouldBeScrollable ? 'addClass' : 'removeClass';\n              utils[toggleAction](section.item, IS_OVERFLOW);\n              utils[toggleAction](el.item, IS_OVERFLOW);\n            } else {\n              addClass(section.item, IS_OVERFLOW);\n              addClass(el.item, IS_OVERFLOW);\n            }\n\n            if (!el.hasScroll) {\n              scrollOverflowHandler.createWrapper(item);\n              scrollOverflowHandler.bindEvents(item);\n            } // updating the state now in case \n            // this is executed on page load (after images load)\n\n\n            el.hasScroll = true;\n          }\n        });\n      },\n      bindEvents: function bindEvents(item) {\n        scrollOverflowHandler.getScrollableItem(item).addEventListener('scroll', scrollOverflowHandler.onPanelScroll);\n        item.addEventListener('wheel', scrollOverflowHandler.preventScrollWithMouseWheel, {\n          passive: false\n        });\n        item.addEventListener('keydown', scrollOverflowHandler.preventScrollWithKeyboard, {\n          passive: false\n        });\n      },\n      createWrapper: function createWrapper(item) {\n        var overflowWrapper = document.createElement('div');\n        overflowWrapper.className = OVERFLOW;\n        wrapInner(item, overflowWrapper);\n        overflowWrapper.setAttribute('tabindex', '-1');\n      },\n      destroyWrapper: function destroyWrapper(item) {\n        var overflowWrapper = $(OVERFLOW_SEL, item)[0];\n\n        if (overflowWrapper) {\n          unwrap(overflowWrapper);\n          item.removeAttribute('tabindex');\n        }\n      },\n      getScrollableItem: function getScrollableItem(sectionItem) {\n        var panel = getSlideOrSection(sectionItem);\n        return $(OVERFLOW_SEL, panel)[0] || panel;\n      },\n      hasScroll: function hasScroll(panelItem) {\n        return hasClass(panelItem, OVERFLOW) || $(OVERFLOW_SEL, panelItem)[0] != null;\n      },\n      isScrollable: function isScrollable(panel) {\n        return panel.isSection && panel.activeSlide ? panel.activeSlide.hasScroll : panel.hasScroll;\n      },\n      shouldBeScrollable: function shouldBeScrollable(item) {\n        var scrollable = scrollOverflowHandler.getScrollableItem(item);\n        return scrollable.scrollHeight > win.innerHeight;\n      },\n      isScrolled: function isScrolled(direction, el) {\n        if (!state.canScroll) {\n          return false;\n        } // we won't allow scrolloverflow on scrollBar:true\n\n\n        if (getOptions().scrollBar) {\n          return true;\n        }\n\n        var scrollableItem = scrollOverflowHandler.getScrollableItem(el);\n\n        if (!getOptions().scrollOverflow || !hasClass(scrollableItem, OVERFLOW) || // Checking the section first \n        // In case they apply to both section + slide #4505\n        hasClass(el, 'fp-noscroll') || // Checking the slide (in case it has)\n        hasClass(getSlideOrSection(el), 'fp-noscroll')) {\n          return true;\n        } // ie11 wrongly calculates scrollHeight when using the CSS style\n        // overflow: auto   It adds 1 more pixel compared to offsetHeight\n\n\n        var ie11offset = isIE11 ? 1 : 0;\n        var positionY = scrollableItem.scrollTop;\n        var isTopReached = direction === 'up' && positionY <= 0;\n        var isBottomReached = direction === 'down' && scrollableItem.scrollHeight <= Math.ceil(scrollableItem.offsetHeight + positionY) + ie11offset;\n        var isScrolled = isTopReached || isBottomReached;\n\n        if (!isScrolled && direction !== 'none') {\n          this.timeBeforeReachingLimit = new Date().getTime();\n        }\n\n        return isScrolled;\n      },\n      shouldMovePage: function shouldMovePage() {\n        this.timeLastScroll = new Date().getTime();\n        var timeDiff = this.timeLastScroll - scrollOverflowHandler.timeBeforeReachingLimit;\n        var isUsingTouch = isTouchDevice || isTouch;\n        var isGrabbing = isUsingTouch && state.isGrabbing;\n        var isNotFirstTimeReachingLimit = state.isUsingWheel && timeDiff > 600;\n        return isGrabbing && timeDiff > 400 || isNotFirstTimeReachingLimit;\n      },\n      onPanelScroll: function () {\n        var prevPosition = 0;\n        return function (e) {\n          var currentPosition = e.target.scrollTop;\n          var direction = state.touchDirection !== 'none' ? state.touchDirection : prevPosition < currentPosition ? 'down' : 'up';\n          prevPosition = currentPosition;\n\n          if (isFunction(getOptions().onScrollOverflow)) {\n            fireCallback('onScrollOverflow', {\n              position: currentPosition,\n              direction: direction\n            });\n          }\n\n          if (hasClass(e.target, OVERFLOW) && state.canScroll) {\n            if (scrollOverflowHandler.isScrolled(direction, e.target) && scrollOverflowHandler.shouldMovePage()) {\n              // Checking again if we have a scrollable content\n              // To avoid issues like #4479 where the scroll event gets\n              // triggered after removing/hidding content if this was scrolled\n              if (scrollOverflowHandler.shouldBeScrollable(getState().activeSection.item)) {\n                EventEmitter.emit(events.onScrollOverflowScrolled, {\n                  direction: direction\n                });\n              }\n            }\n          }\n        };\n      }()\n    };\n\n    var g_afterSlideLoadsId;\n    FP.landscapeScroll = landscapeScroll;\n    EventEmitter.on(events.bindEvents, bindEvents$a);\n\n    function bindEvents$a() {\n      EventEmitter.on(events.onPerformMovement, onPerformMovement);\n    }\n\n    function onPerformMovement() {\n      clearTimeout(g_afterSlideLoadsId);\n      setState({\n        slideMoving: false\n      });\n    }\n    /**\n    * Scrolls horizontal sliders.\n    */\n\n\n    function landscapeScroll(slides, destiny, direction) {\n      var sectionElem = closest(slides, SECTION_SEL);\n      var section = getState().sections.filter(function (section) {\n        return section.item == sectionElem;\n      })[0];\n      var slide = section.slides.filter(function (slide) {\n        return slide.item == destiny;\n      })[0];\n      var v = {\n        \"slides\": slides,\n        \"destiny\": destiny,\n        \"direction\": direction,\n        \"destinyPos\": {\n          \"left\": destiny.offsetLeft\n        },\n        \"slideIndex\": slide.index(),\n        \"section\": sectionElem,\n        \"sectionIndex\": section.index(),\n        \"anchorLink\": section.anchor,\n        \"slidesNav\": $(SLIDES_NAV_SEL, sectionElem)[0],\n        \"slideAnchor\": slide.anchor,\n        \"prevSlide\": section.activeSlide.item,\n        \"prevSlideIndex\": section.activeSlide.index(),\n        \"items\": {\n          \"section\": section,\n          \"origin\": section.activeSlide,\n          \"destination\": slide\n        },\n        //caching the value of isResizing at the momment the function is called\n        //because it will be checked later inside a setTimeout and the value might change\n        \"localIsResizing\": state.isResizing\n      };\n      v.xMovement = getXmovement(v.prevSlideIndex, v.slideIndex);\n      v.direction = v.direction ? v.direction : v.xMovement; //important!! Only do it when not resizing\n\n      if (!v.localIsResizing) {\n        //preventing from scrolling to the next/prev section when using scrollHorizontally\n        setState({\n          canScroll: false\n        });\n      }\n\n      if (getOptions().onSlideLeave) {\n        //if the site is not just resizing and readjusting the slides\n        if (!v.localIsResizing && v.xMovement !== 'none') {\n          if (isFunction(getOptions().onSlideLeave)) {\n            if (fireCallback('onSlideLeave', v) === false) {\n              setState({\n                slideMoving: false\n              });\n              return;\n            }\n          }\n        }\n      }\n\n      addClass(destiny, ACTIVE);\n      removeClass(siblings(destiny), ACTIVE);\n      updateState();\n\n      if (!v.localIsResizing) {\n        stopMedia(v.prevSlide);\n        lazyLoadPanels(slide);\n      }\n\n      toggleControlArrows(v); //only changing the URL if the slides are in the current section (not for resize re-adjusting)\n\n      if (section.isActive && !v.localIsResizing) {\n        setPageStatus(v.slideIndex, v.slideAnchor, v.anchorLink);\n      }\n\n      EventEmitter.emit(events.onSlideLeave, v);\n      performHorizontalMove(slides, v, true);\n    }\n    /**\n    * Performs the horizontal movement. (CSS3 or jQuery)\n    *\n    * @param fireCallback {Boolean} - determines whether or not to fire the callback\n    */\n\n    function performHorizontalMove(slides, v, fireCallback) {\n      var destinyPos = v.destinyPos;\n      activeSlidesNavigation(v.slidesNav, v.slideIndex);\n      setState({\n        scrollX: Math.round(destinyPos.left)\n      });\n\n      if (getOptions().css3) {\n        var translate3d = 'translate3d(-' + Math.round(destinyPos.left) + 'px, 0px, 0px)';\n        FP.test.translate3dH[v.sectionIndex] = translate3d;\n        css(addAnimation($(SLIDES_CONTAINER_SEL, slides)), getTransforms(translate3d));\n        clearTimeout(g_afterSlideLoadsId);\n        g_afterSlideLoadsId = setTimeout(function () {\n          if (fireCallback) {\n            afterSlideLoads(v);\n          }\n        }, getOptions().scrollingSpeed);\n      } else {\n        FP.test.left[v.sectionIndex] = Math.round(destinyPos.left);\n        scrollTo(slides, Math.round(destinyPos.left), getOptions().scrollingSpeed, function () {\n          if (fireCallback) {\n            afterSlideLoads(v);\n          }\n        });\n      }\n    }\n    /**\n    * Retuns `right` or `left` depending on the scrolling movement to reach its destination\n    * from the current slide.\n    */\n\n\n    function getXmovement(fromIndex, toIndex) {\n      if (fromIndex == toIndex) {\n        return 'none';\n      }\n\n      if (fromIndex > toIndex) {\n        return 'left';\n      }\n\n      return 'right';\n    }\n\n    function onDestroy$6() {\n      clearTimeout(g_afterSlideLoadsId);\n    }\n\n    function afterSlideLoads(v) {\n      //if the site is not just resizing and readjusting the slides\n      if (!v.localIsResizing) {\n        if (isFunction(getOptions().afterSlideLoad)) {\n          fireCallback('afterSlideLoad', v);\n        } //needs to be inside the condition to prevent problems with continuousVertical and scrollHorizontally\n        //and to prevent double scroll right after a windows resize\n\n\n        setState({\n          canScroll: true\n        });\n        playMedia(v.destiny);\n        EventEmitter.emit(events.afterSlideLoads, v);\n      } //letting them slide again\n\n\n      setState({\n        slideMoving: false\n      });\n    }\n\n    /**\n    * Slides silently (with no animation) the active slider to the given slide.\n    * @param noCallback {bool} true or defined -> no callbacks\n    */\n\n    function silentLandscapeScroll(activeSlide, noCallbacks) {\n      setScrollingSpeed(0, 'internal');\n\n      if (typeof noCallbacks !== 'undefined') {\n        //preventing firing callbacks afterSlideLoad etc.\n        setState({\n          isResizing: true\n        });\n      }\n\n      landscapeScroll(closest(activeSlide, SLIDES_WRAPPER_SEL), activeSlide);\n\n      if (typeof noCallbacks !== 'undefined') {\n        setState({\n          isResizing: false\n        });\n      }\n\n      setScrollingSpeed(getOriginals().scrollingSpeed, 'internal');\n    }\n\n    var g_prevActiveSectionIndex = null;\n    var g_prevActiveSlideIndex = null;\n    EventEmitter.on(events.onDestroyAll, onDestroyAll);\n\n    function onDestroyAll() {\n      g_prevActiveSectionIndex = null;\n      g_prevActiveSlideIndex = null;\n    }\n    /** \n     * Updates the state of the app.\n     */\n\n\n    function updateState() {\n      state.activeSection = null;\n      state.sections.map(function (section) {\n        var isActive = hasClass(section.item, ACTIVE);\n        section.isActive = isActive;\n        section.hasScroll = scrollOverflowHandler.hasScroll(section.item);\n\n        if (isActive) {\n          state.activeSection = section;\n        }\n\n        if (section.slides.length) {\n          section.activeSlide = null;\n          section.slides.map(function (slide) {\n            var isActiveSlide = hasClass(slide.item, ACTIVE);\n            slide.hasScroll = scrollOverflowHandler.hasScroll(section.item);\n            slide.isActive = isActiveSlide;\n\n            if (isActiveSlide) {\n              section.activeSlide = slide;\n            }\n          });\n        }\n      });\n      scrollToNewActivePanel();\n    }\n    function updateStructuralState() {\n      var allSectionItems = $(getOptions().sectionSelector, getContainer());\n      var sectionsItems = getVisible(allSectionItems);\n      var allSections = Array.from(allSectionItems).map(function (item) {\n        return new SectionPanel(item);\n      });\n      var sections = allSections.filter(function (item) {\n        return item.isVisible;\n      });\n      var slides = sections.reduce(function (acc, section) {\n        return acc.concat(section.slides);\n      }, []); // keeping track of the previously active section\n\n      g_prevActiveSectionIndex = getPrevActivePanelIndex(state.activeSection);\n      g_prevActiveSlideIndex = getPrevActivePanelIndex(state.activeSection ? state.activeSection.activeSlide : null);\n      state.numSections = sectionsItems.length;\n      state.numSlides = sections.reduce(function (acc, section) {\n        return acc + section.slides.length;\n      }, 0);\n      state.sections = sections;\n      state.sectionsIncludingHidden = allSections;\n      state.slides = slides;\n      state.panels = state.sections.concat(state.slides);\n    }\n\n    function getPrevActivePanelIndex(activePanel) {\n      if (!activePanel) {\n        return null;\n      }\n\n      var prevActivePanelItem = activePanel ? activePanel.item : null;\n      var hiddenPanels = activePanel.isSection ? state.sectionsIncludingHidden : state.activeSection.slidesIncludingHidden;\n\n      if (prevActivePanelItem) {\n        var panel = getPanelByElement(hiddenPanels, prevActivePanelItem);\n        return panel ? panel.index() : null;\n      }\n\n      return null;\n    }\n    /**\n     * When changes in the DOM take place there's a change \n     * the active section is now hidden or removed. \n     * fullPage.js will scroll to the closest section nearby.\n     */\n\n\n    function scrollToNewActivePanel() {\n      var activeSection = state.activeSection;\n      var activeSectionHasSlides = state.activeSection ? state.activeSection.slides.length : false;\n      var activeSlide = state.activeSection ? state.activeSection.activeSlide : null; // Hidding / removing the active section ?\n\n      if (!activeSection && state.sections.length && !getState().isBeyondFullpage && g_prevActiveSectionIndex !== null) {\n        var newActiveSection = getNewActivePanel(g_prevActiveSectionIndex, state.sections);\n\n        if (newActiveSection) {\n          state.activeSection = newActiveSection;\n          state.activeSection.isActive = true;\n          addClass(state.activeSection.item, ACTIVE);\n        }\n\n        if (state.activeSection) {\n          silentScroll(state.activeSection.item.offsetTop);\n        }\n      }\n\n      if (activeSectionHasSlides && !activeSlide && g_prevActiveSlideIndex !== null) {\n        var newActiveSlide = getNewActivePanel(g_prevActiveSlideIndex, state.activeSection.slides);\n\n        if (newActiveSlide) {\n          state.activeSection.activeSlide = newActiveSlide;\n          state.activeSection.activeSlide.isActive = true;\n          addClass(state.activeSection.activeSlide.item, ACTIVE);\n        }\n\n        if (state.activeSection.activeSlide) {\n          silentLandscapeScroll(state.activeSection.activeSlide.item, 'internal');\n        }\n      }\n    }\n\n    function getNewActivePanel(prevActivePanelIndex, siblings) {\n      var newActiveSection;\n      var prevIndex = prevActivePanelIndex - 1;\n      var nextIndex = prevActivePanelIndex;\n\n      do {\n        newActiveSection = siblings[prevIndex] || siblings[nextIndex];\n\n        if (newActiveSection) {\n          break;\n        }\n\n        prevIndex = prevIndex - 1;\n        nextIndex = nextIndex + 1;\n      } while (prevIndex >= 0 || nextIndex < siblings.length);\n\n      return newActiveSection;\n    }\n    /**\n    * Section object\n    */\n\n\n    var SectionPanel = function SectionPanel(el) {\n      var _this = this;\n\n      [].push.call(arguments, getOptions().sectionSelector);\n      Item.apply(this, arguments);\n      this.allSlidesItems = $(getOptions().slideSelector, el);\n      this.slidesIncludingHidden = Array.from(this.allSlidesItems).map(function (item) {\n        return new SlidePanel(item, _this);\n      });\n      this.slides = this.slidesIncludingHidden.filter(function (slidePanel) {\n        return slidePanel.isVisible;\n      });\n      this.activeSlide = this.slides.length ? this.slides.filter(function (slide) {\n        return slide.isActive;\n      })[0] || this.slides[0] : null;\n    };\n    SectionPanel.prototype = Item.prototype;\n    SectionPanel.prototype.constructor = SectionPanel;\n    /**\n    * Slide object\n    */\n\n    var SlidePanel = function SlidePanel(el, section) {\n      this.parent = section;\n      Item.call(this, el, getOptions().slideSelector);\n    };\n\n    SlidePanel.prototype = Item.prototype;\n    SlidePanel.prototype.constructor = SectionPanel;\n\n    /**\n    * Adds internal classes to be able to provide customizable selectors\n    * keeping the link with the style sheet.\n    */\n\n    function addInternalSelectors() {\n      addClass($(getOptions().sectionSelector, getContainer()), SECTION);\n      addClass($(getOptions().slideSelector, getContainer()), SLIDE);\n    }\n\n    /**\n    * Styles the horizontal slides for a section.\n    */\n\n    function styleSlides(section) {\n      var numSlides = section.slides.length;\n      var slidesElems = section.allSlidesItems;\n      var slides = section.slides;\n      var sliderWidth = numSlides * 100;\n      var slideWidth = 100 / numSlides;\n\n      if (!$(SLIDES_WRAPPER_SEL, section.item)[0]) {\n        var slidesWrapper = doc.createElement('div');\n        slidesWrapper.className = SLIDES_WRAPPER; //fp-slides\n\n        wrapAll(slidesElems, slidesWrapper);\n        var slidesContainer = doc.createElement('div');\n        slidesContainer.className = SLIDES_CONTAINER; //fp-slidesContainer\n\n        wrapAll(slidesElems, slidesContainer);\n      }\n\n      css($(SLIDES_CONTAINER_SEL, section.item), {\n        'width': sliderWidth + '%'\n      });\n\n      if (numSlides > 1) {\n        if (getOptions().controlArrows) {\n          createSlideArrows(section);\n        }\n\n        if (getOptions().slidesNavigation) {\n          addSlidesNavigation(section);\n        }\n      }\n\n      slides.forEach(function (slide) {\n        css(slide.item, {\n          'width': slideWidth + '%'\n        });\n\n        if (getOptions().verticalCentered) {\n          addTableClass(slide);\n        }\n      });\n      var startingSlide = section.activeSlide || null; //if the slide won't be an starting point, the default will be the first one\n      //the active section isn't the first one? Is not the first slide of the first section? Then we load that section/slide by default.\n\n      if (startingSlide != null && state.activeSection && (state.activeSection.index() !== 0 || state.activeSection.index() === 0 && startingSlide.index() !== 0)) {\n        silentLandscapeScroll(startingSlide.item, 'internal');\n      } else {\n        addClass(slidesElems[0], ACTIVE);\n      }\n    }\n\n    var g_wrapperObserver;\n    var g_wrapperObserveConfig = {\n      attributes: false,\n      subtree: true,\n      childList: true,\n      characterData: true\n    };\n    EventEmitter.on(events.bindEvents, bindEvents$9);\n    EventEmitter.on(events.onDestroy, unbindEvents);\n    FP[\"render\"] = onContentChange;\n\n    function bindEvents$9() {\n      if (getOptions().observer && \"MutationObserver\" in window && $(WRAPPER_SEL)[0]) {\n        g_wrapperObserver = createObserver($(WRAPPER_SEL)[0], onContentChange, g_wrapperObserveConfig);\n      }\n\n      EventEmitter.on(events.contentChanged, onContentChange);\n    }\n\n    function unbindEvents() {\n      if (g_wrapperObserver) {\n        g_wrapperObserver.disconnect();\n        g_wrapperObserver = null;\n      }\n    }\n    /**\n     * Creates a Mutation observer.\n     */\n\n\n    function createObserver(target, callback, config) {\n      var observer = new MutationObserver(callback);\n      observer.observe(target, config);\n      return observer;\n    }\n\n    function didSlidesChange() {\n      return getVisible($(getOptions().slideSelector, getContainer())).length !== getState().numSlides;\n    }\n\n    function didSectionsChange() {\n      return getVisible($(getOptions().sectionSelector, getContainer())).length !== getState().numSections;\n    }\n\n    function didSectionsOrSlidesChange() {\n      return didSlidesChange() || didSectionsChange();\n    }\n    /**\n     * Listen to changes on sections and fires reBuild\n     * when those changes affect the section height.\n     */\n\n\n    function onContentChange(mutations) {\n      var _didSlidesChange = didSlidesChange();\n\n      if (didSectionsOrSlidesChange() && !state.isDoingContinousVertical) {\n        if (getOptions().observer && g_wrapperObserver) {\n          // Temporally disabling the observer while \n          // we modidy the DOM again\n          g_wrapperObserver.disconnect();\n        }\n\n        updateStructuralState();\n        updateState(); // Removing navs and anchors options\n\n        getOptions().anchors = [];\n        remove($(SECTION_NAV_SEL));\n        addInternalSelectors();\n        setOptionsFromDOM();\n\n        if (getOptions().navigation) {\n          addVerticalNavigation();\n        }\n\n        if (_didSlidesChange) {\n          remove($(SLIDES_NAV_SEL));\n          remove($(SLIDES_ARROW_SEL));\n        }\n\n        getState().sections.forEach(function (section) {\n          if (section.slides.length) {\n            if (_didSlidesChange) {\n              styleSlides(section);\n            }\n          } else {\n            styleSection(section);\n          }\n        });\n      }\n\n      if (getOptions().observer && g_wrapperObserver && $(WRAPPER_SEL)[0]) {\n        g_wrapperObserver.observe($(WRAPPER_SEL)[0], g_wrapperObserveConfig);\n      }\n    }\n\n    var supportsPassiveEvents = function () {\n      //cheks for passive event support\n      var g_supportsPassive = false;\n\n      try {\n        var opts = Object.defineProperty({}, 'passive', {\n          get: function get() {\n            g_supportsPassive = true;\n          }\n        });\n        windowAddEvent(\"testPassive\", null, opts);\n        windowRemoveEvent(\"testPassive\", null, opts);\n      } catch (e) {}\n\n      return function () {\n        return g_supportsPassive;\n      };\n    }();\n\n    function getPassiveOptionsIfPossible() {\n      return supportsPassiveEvents() ? {\n        passive: false\n      } : false;\n    }\n\n    var wheelDataHandler = function () {\n      var _prevTime = new Date().getTime();\n\n      var _scrollings = [];\n      var isScrollingVertically;\n      var direction;\n      return {\n        registerEvent: function registerEvent(e) {\n          e = e || win.event;\n          var value = e.wheelDelta || -e.deltaY || -e.detail;\n          var delta = Math.max(-1, Math.min(1, value));\n          var horizontalDetection = typeof e.wheelDeltaX !== 'undefined' || typeof e.deltaX !== 'undefined';\n          isScrollingVertically = Math.abs(e.wheelDeltaX) < Math.abs(e.wheelDelta) || Math.abs(e.deltaX) < Math.abs(e.deltaY) || !horizontalDetection;\n          var curTime = new Date().getTime();\n          direction = delta < 0 ? 'down' : 'up'; //Limiting the array to 150 (lets not waste memory!)\n\n          if (_scrollings.length > 149) {\n            _scrollings.shift();\n          } //keeping record of the previous scrollings\n\n\n          _scrollings.push(Math.abs(value)); //time difference between the last scroll and the current one\n\n\n          var timeDiff = curTime - _prevTime;\n          _prevTime = curTime; //haven't they scrolled in a while?\n          //(enough to be consider a different scrolling action to scroll another section)\n\n          if (timeDiff > 200) {\n            //emptying the array, we dont care about old scrollings for our averages\n            _scrollings = [];\n          }\n        },\n        isAccelerating: function isAccelerating() {\n          var averageEnd = getAverage(_scrollings, 10);\n          var averageMiddle = getAverage(_scrollings, 70);\n          var isAccelerating = averageEnd >= averageMiddle;\n          return _scrollings.length ? isAccelerating && isScrollingVertically : false;\n        },\n        getDirection: function getDirection() {\n          return direction;\n        }\n      };\n    }();\n\n    function scrollBeyondFullPage() {\n      var dtop = getDestinationOffset();\n      var scrollSettings = getScrollSettings(dtop);\n      FP.test.top = -dtop + 'px';\n      setState({\n        canScroll: false\n      });\n      scrollTo(scrollSettings.element, scrollSettings.options, getOptions().scrollingSpeed, function () {\n        setTimeout(function () {\n          setState({\n            isBeyondFullpage: true\n          });\n          setState({\n            canScroll: true\n          });\n        }, 30);\n      });\n    }\n    function onKeyDown() {\n      if (!isFullPageAbove()) {\n        return;\n      } else {\n        scrollUpToFullpage();\n      }\n    }\n    function scrollUpToFullpage() {\n      var scrollSettings = getScrollSettings(getLast(getState().sections).item.offsetTop);\n      setState({\n        canScroll: false\n      });\n      scrollTo(scrollSettings.element, scrollSettings.options, getOptions().scrollingSpeed, function () {\n        setState({\n          canScroll: true\n        });\n        setState({\n          isBeyondFullpage: false\n        });\n        setState({\n          isAboutToScrollToFullPage: false\n        });\n      });\n    }\n\n    function getDestinationOffset() {\n      if (!getOptions().css3) {\n        return getLast(getState().sections).item.offsetTop + getLast(getState().sections).item.offsetHeight;\n      }\n\n      return getScrollTop() + getWindowHeight();\n    }\n\n    function beyondFullPageHandler(container, e) {\n      new Date().getTime();\n      var pauseScroll = getState().isBeyondFullpage && container.getBoundingClientRect().bottom >= 0 && wheelDataHandler.getDirection() === 'up';\n      var g_isAboutToScrollToFullPage = getState().isAboutToScrollToFullPage;\n\n      if (g_isAboutToScrollToFullPage) {\n        preventDefault(e);\n        return false;\n      }\n\n      if (getState().isBeyondFullpage) {\n        if (!pauseScroll) {\n          keyframeTime('set', 'beyondFullpage', 1000);\n        } else {\n          var shouldSetFixedPosition = !g_isAboutToScrollToFullPage && (!keyframeTime('isNewKeyframe', 'beyondFullpage') || !wheelDataHandler.isAccelerating());\n          var scrollSettings;\n\n          if (shouldSetFixedPosition) {\n            scrollSettings = getScrollSettings(getLast(getState().sections).item.offsetTop + getLast(getState().sections).item.offsetHeight);\n            scrollSettings.element.scrollTo(0, scrollSettings.options);\n            setState({\n              isAboutToScrollToFullPage: false\n            });\n            preventDefault(e);\n            return false;\n          } else if (wheelDataHandler.isAccelerating()) {\n            pauseScroll = false;\n            setState({\n              isAboutToScrollToFullPage: true\n            });\n            setState({\n              scrollTrigger: 'wheel'\n            });\n            scrollUpToFullpage();\n            preventDefault(e);\n            return false;\n          }\n        }\n\n        if (!g_isAboutToScrollToFullPage) {\n          // allow normal scrolling, but quitting\n          if (!pauseScroll) {\n            return true;\n          }\n        }\n      }\n    }\n\n    var keyframeTime = function () {\n      var isNew = false;\n      var frames = {};\n      var timeframes = {};\n      return function (action, name, timeframe) {\n        switch (action) {\n          case 'set':\n            frames[name] = new Date().getTime();\n            timeframes[name] = timeframe;\n            break;\n\n          case 'isNewKeyframe':\n            var current = new Date().getTime();\n            isNew = current - frames[name] > timeframes[name];\n            break;\n        }\n\n        return isNew;\n      };\n    }();\n\n    FP.moveSectionDown = moveSectionDown;\n    /**\n    * Moves the page down one section.\n    */\n\n    function moveSectionDown() {\n      var next = getState().activeSection.next(); //looping to the top if there's no more sections below\n\n      if (!next && (getOptions().loopBottom || getOptions().continuousVertical)) {\n        next = getState().sections[0];\n      }\n\n      if (next != null) {\n        scrollPage(next, null, false);\n      } else if (hasContentBeyondFullPage()) {\n        EventEmitter.emit(events.scrollBeyondFullpage);\n      }\n    }\n\n    function hasContentBeyondFullPage() {\n      return getContainer().scrollHeight < $body.scrollHeight && getOptions().scrollBar && getOptions().scrollBeyondFullpage;\n    }\n\n    FP.moveSectionUp = moveSectionUp;\n    /**\n    * Moves the page up one section.\n    */\n\n    function moveSectionUp() {\n      var prev = getState().activeSection.prev(); //looping to the bottom if there's no more sections above\n\n      if (!prev && (getOptions().loopTop || getOptions().continuousVertical)) {\n        prev = getLast(getState().sections);\n      }\n\n      if (prev != null) {\n        scrollPage(prev, null, true);\n      }\n    }\n\n    var oldPageY = 0;\n    /**\n    * Detecting the direction of the mouse movement.\n    * Used only for the middle button of the mouse.\n    */\n\n    function mouseMoveHandler(e) {\n      if (!getOptions().autoScrolling) {\n        return;\n      }\n\n      if (state.canScroll) {\n        // moving up\n        if (e.pageY < oldPageY && getIsScrollAllowed().m.up) {\n          moveSectionUp();\n        } // moving down\n        else if (e.pageY > oldPageY && getIsScrollAllowed().m.down) {\n          moveSectionDown();\n        }\n      }\n\n      oldPageY = e.pageY;\n    }\n    function setOldPageY(value) {\n      oldPageY = value;\n    }\n\n    /**\n    * Determines the way of scrolling up or down:\n    * by 'automatically' scrolling a section or by using the default and normal scrolling.\n    */\n\n    function scrolling(type) {\n      if (!getIsScrollAllowed().m[type]) {\n        return;\n      }\n\n      var scrollSection = type === 'down' ? moveSectionDown : moveSectionUp;\n\n      if (getOptions().scrollOverflow && scrollOverflowHandler.isScrollable(getState().activeSection)) {\n        //is the scrollbar at the start/end of the scroll?\n        if (scrollOverflowHandler.isScrolled(type, getState().activeSection.item) && scrollOverflowHandler.shouldMovePage()) {\n          scrollSection();\n        }\n      } else {\n        scrollSection();\n      }\n    }\n\n    var touchStartY = 0;\n    var touchStartX = 0;\n    var touchEndY = 0;\n    var touchEndX = 0;\n    var MSPointer = getMSPointer();\n    var pointers = {\n      touchmove: 'ontouchmove' in window ? 'touchmove' : MSPointer ? MSPointer.move : null,\n      touchstart: 'ontouchstart' in window ? 'touchstart' : MSPointer ? MSPointer.down : null\n    };\n    /**\n    * Adds the possibility to auto scroll through sections on touch devices.\n    */\n\n    function addTouchHandler() {\n      if (!pointers.touchmove) {\n        return;\n      }\n\n      if (isTouchDevice || isTouch) {\n        if (getOptions().autoScrolling) {\n          $body.removeEventListener(pointers.touchmove, preventBouncing, {\n            passive: false\n          });\n          $body.addEventListener(pointers.touchmove, preventBouncing, {\n            passive: false\n          });\n        }\n\n        var touchWrapper = getOptions().touchWrapper;\n        touchWrapper.removeEventListener(pointers.touchstart, touchStartHandler);\n        touchWrapper.removeEventListener(pointers.touchmove, touchMoveHandler, {\n          passive: false\n        });\n        touchWrapper.addEventListener(pointers.touchstart, touchStartHandler);\n        touchWrapper.addEventListener(pointers.touchmove, touchMoveHandler, {\n          passive: false\n        });\n      }\n    }\n    /**\n    * Removes the auto scrolling for touch devices.\n    */\n\n    function removeTouchHandler() {\n      if (!pointers.touchmove) {\n        return;\n      }\n\n      if (isTouchDevice || isTouch) {\n        // normalScrollElements requires it off #2691\n        if (getOptions().autoScrolling) {\n          $body.removeEventListener(pointers.touchmove, touchMoveHandler, {\n            passive: false\n          });\n          $body.removeEventListener(pointers.touchmove, preventBouncing, {\n            passive: false\n          });\n        }\n\n        var touchWrapper = getOptions().touchWrapper;\n        touchWrapper.removeEventListener(pointers.touchstart, touchStartHandler);\n        touchWrapper.removeEventListener(pointers.touchmove, touchMoveHandler, {\n          passive: false\n        });\n      }\n    }\n    /* Detecting touch events\n\n    * As we are changing the top property of the page on scrolling, we can not use the traditional way to detect it.\n    * This way, the touchstart and the touch moves shows an small difference between them which is the\n    * used one to determine the direction.\n    */\n\n    function touchMoveHandler(e) {\n      var activeSection = closest(e.target, SECTION_SEL) || getState().activeSection.item;\n      var hasActiveSectionOverflow = scrollOverflowHandler.isScrollable(getState().activeSection);\n\n      if (isReallyTouch(e)) {\n        setState({\n          isGrabbing: true,\n          isUsingWheel: false\n        });\n\n        if (getOptions().autoScrolling) {\n          if (hasActiveSectionOverflow && !state.canScroll || getOptions().scrollBar) {\n            //preventing the easing on iOS devices\n            preventDefault(e);\n          }\n        }\n\n        var touchEvents = getEventsPage(e);\n        touchEndY = touchEvents.y;\n        touchEndX = touchEvents.x;\n        var isVerticalMovementEnough = Math.abs(touchStartY - touchEndY) > win.innerHeight / 100 * getOptions().touchSensitivity;\n        var isHorizontalMovementEnough = Math.abs(touchStartX - touchEndX) > getWindowWidth() / 100 * getOptions().touchSensitivity;\n        var isHorizontalPredominantMove = $(SLIDES_WRAPPER_SEL, activeSection).length && Math.abs(touchStartX - touchEndX) > Math.abs(touchStartY - touchEndY);\n        var directionH = touchStartX > touchEndX ? 'right' : 'left';\n        var directionV = touchStartY > touchEndY ? 'down' : 'up';\n        var direction = isHorizontalPredominantMove ? directionH : directionV;\n        setState({\n          touchDirection: direction\n        }); //if movement in the X axys is greater than in the Y and the currect section has slides...\n\n        if (isHorizontalPredominantMove) {\n          //is the movement greater than the minimum resistance to scroll?\n          if (!state.slideMoving && isHorizontalMovementEnough) {\n            if (touchStartX > touchEndX) {\n              if (getIsScrollAllowed().m.right) {\n                EventEmitter.emit(events.moveSlideRight, {\n                  section: activeSection\n                });\n              }\n            } else {\n              if (getIsScrollAllowed().m.left) {\n                EventEmitter.emit(events.moveSlideLeft, {\n                  section: activeSection\n                });\n              }\n            }\n          }\n        } //vertical scrolling (only when autoScrolling is enabled)\n        else if (getOptions().autoScrolling && state.canScroll) {\n          //is the movement greater than the minimum resistance to scroll?\n          if (isVerticalMovementEnough) {\n            scrolling(directionV);\n          }\n        }\n      }\n    }\n    /**\n    * As IE >= 10 fires both touch and mouse events when using a mouse in a touchscreen\n    * this way we make sure that is really a touch event what IE is detecting.\n    */\n\n\n    function isReallyTouch(e) {\n      //if is not IE   ||  IE is detecting `touch` or `pen`\n      return typeof e.pointerType === 'undefined' || e.pointerType != 'mouse';\n    }\n    /**\n    * Handler for the touch start event.\n    */\n\n\n    function touchStartHandler(e) {\n      //stopping the auto scroll to adjust to a section\n      if (getOptions().fitToSection) {\n        setState({\n          activeAnimation: false\n        });\n      }\n\n      if (isReallyTouch(e)) {\n        var touchEvents = getEventsPage(e);\n        touchStartY = touchEvents.y;\n        touchStartX = touchEvents.x;\n      }\n\n      windowAddEvent('touchend', touchEndHandler);\n    }\n    /**\n    * Handler for the touch end event.\n    */\n\n\n    function touchEndHandler() {\n      windowRemoveEvent('touchend', touchEndHandler);\n      setState({\n        isGrabbing: false\n      });\n    }\n    /**\n    * Gets the pageX and pageY properties depending on the browser.\n    * https://github.com/alvarotrigo/fullPage.js/issues/194#issuecomment-34069854\n    */\n\n\n    function getEventsPage(e) {\n      var events = {};\n      events.y = typeof e.pageY !== 'undefined' && (e.pageY || e.pageX) ? e.pageY : e.touches[0].pageY;\n      events.x = typeof e.pageX !== 'undefined' && (e.pageY || e.pageX) ? e.pageX : e.touches[0].pageX; //in touch devices with scrollBar:true, e.pageY is detected, but we have to deal with touch events. #1008\n\n      if (isTouch && isReallyTouch(e) && getOptions().scrollBar && typeof e.touches !== 'undefined') {\n        events.y = e.touches[0].pageY;\n        events.x = e.touches[0].pageX;\n      }\n\n      return events;\n    }\n    /*\n    * Returns and object with Microsoft pointers (for IE<11 and for IE >= 11)\n    * http://msdn.microsoft.com/en-us/library/ie/dn304886(v=vs.85).aspx\n    */\n\n\n    function getMSPointer() {\n      var pointer; //IE >= 11 & rest of browsers\n\n      if (win.PointerEvent) {\n        pointer = {\n          down: 'pointerdown',\n          move: 'pointermove'\n        };\n      }\n\n      return pointer;\n    }\n    /*\n    * Preventing bouncing in iOS #2285\n    */\n\n\n    function preventBouncing(e) {\n      if (getOptions().autoScrolling && isReallyTouch(e) && getIsScrollAllowed().m.up) {\n        //preventing the easing on iOS devices\n        if (!state.canScroll) {\n          preventDefault(e);\n        }\n      }\n    }\n\n    FP.moveSlideLeft = moveSlideLeft;\n    FP.moveSlideRight = moveSlideRight;\n    /**\n    * Slides a slider to the given direction.\n    * Optional `section` param.\n    */\n\n    function moveSlide(direction, section) {\n      var activeSectionItem = section == null ? getState().activeSection.item : section;\n      var activeSection = getPanelByElement(state.sections, activeSectionItem);\n      var slides = $(SLIDES_WRAPPER_SEL, activeSectionItem)[0]; // more than one slide needed and nothing should be sliding\n\n      if (slides == null || state.slideMoving || activeSection.slides.length < 2) {\n        return;\n      }\n\n      var currentSlide = activeSection.activeSlide;\n      var destiny = direction === 'left' ? currentSlide.prev() : currentSlide.next(); //isn't there a next slide in the secuence?\n\n      if (!destiny) {\n        //respect loopHorizontal setting\n        if (!getOptions().loopHorizontal) return;\n        destiny = direction === 'left' ? getLast(activeSection.slides) : activeSection.slides[0];\n      }\n\n      setState({\n        slideMoving: !FP.test.isTesting\n      });\n      landscapeScroll(slides, destiny.item, direction);\n    }\n    /**\n    * Slides left the slider of the active section.\n    * Optional `section` param.\n    */\n\n    function moveSlideLeft(section) {\n      moveSlide('left', section);\n    }\n    /**\n    * Slides right the slider of the active section.\n    * Optional `section` param.\n    */\n\n    function moveSlideRight(section) {\n      moveSlide('right', section);\n    }\n\n    /**\n    * Gets a section by its anchor / index\n    */\n\n    function getSectionByAnchor(sectionAnchor) {\n      var section = getState().sections.filter(function (section) {\n        return section.anchor === sectionAnchor;\n      })[0];\n\n      if (!section) {\n        var sectionIndex = typeof sectionAnchor !== 'undefined' ? sectionAnchor - 1 : 0;\n        section = getState().sections[sectionIndex];\n      }\n\n      return section;\n    }\n\n    /**\n    * Scrolls the slider to the given slide destination for the given section\n    */\n\n    function scrollSlider(slideElem) {\n      if (slideElem != null) {\n        landscapeScroll(closest(slideElem, SLIDES_WRAPPER_SEL), slideElem);\n      }\n    }\n\n    /**\n    * Scrolls to the given section and slide anchors\n    */\n\n    function scrollPageAndSlide(sectionAnchor, slideAnchor) {\n      var section = getSectionByAnchor(sectionAnchor); //do nothing if there's no section with the given anchor name\n\n      if (section == null) return;\n      var slideElem = getSlideByAnchor(slideAnchor, section); //we need to scroll to the section and then to the slide\n\n      if ((!section.anchor || section.anchor !== state.lastScrolledDestiny) && !hasClass(section.item, ACTIVE)) {\n        scrollPage(section, function () {\n          scrollSlider(slideElem);\n        });\n      } //if we were already in the section\n      else {\n        scrollSlider(slideElem);\n      }\n    }\n    /**\n    * Gets a slide inside a given section by its anchor / index\n    */\n\n    function getSlideByAnchor(slideAnchor, section) {\n      var slide = section.slides.filter(function (slide) {\n        return slide.anchor === slideAnchor;\n      })[0];\n\n      if (slide == null) {\n        slideAnchor = typeof slideAnchor !== 'undefined' ? slideAnchor : 0;\n        slide = section.slides[slideAnchor];\n      }\n\n      return slide ? slide.item : null;\n    }\n\n    FP.moveTo = moveTo$1;\n    /**\n    * Moves the page to the given section and slide.\n    * Anchors or index positions can be used as params.\n    */\n\n    function moveTo$1(sectionAnchor, slideAnchor) {\n      var destiny = getSectionByAnchor(sectionAnchor);\n\n      if (typeof slideAnchor !== 'undefined') {\n        scrollPageAndSlide(sectionAnchor, slideAnchor);\n      } else if (destiny != null) {\n        scrollPage(destiny);\n      }\n    }\n\n    //@ts-check\n    var g_controlPressed;\n    var g_keydownId;\n    var g_elToFocus;\n    EventEmitter.on(events.bindEvents, bindEvents$8);\n\n    function bindEvents$8() {\n      //when opening a new tab (ctrl + t), `control` won't be pressed when coming back.\n      windowAddEvent('blur', blurHandler); //Sliding with arrow keys, both, vertical and horizontal\n\n      docAddEvent('keydown', keydownHandler); //to prevent scrolling while zooming\n\n      docAddEvent('keyup', keyUpHandler);\n      EventEmitter.on(events.onDestroy, onDestroy$5);\n      EventEmitter.on(events.afterSlideLoads, onAfterSlideLoads);\n      EventEmitter.on(events.afterSectionLoads, afterSectionLoads);\n    }\n\n    function onDestroy$5() {\n      clearTimeout(g_keydownId);\n      docRemoveEvent('keydown', keydownHandler);\n      docRemoveEvent('keyup', keyUpHandler);\n    } //Sliding with arrow keys, both, vertical and horizontal\n\n\n    function keydownHandler(e) {\n      clearTimeout(g_keydownId);\n      var keyCode = e.keyCode;\n      var isPressingHorizontalArrows = [37, 39].indexOf(keyCode) > -1;\n      var canScrollWithKeyboard = getOptions().autoScrolling || getOptions().fitToSection || isPressingHorizontalArrows; //tab?\n\n      if (keyCode === 9) {\n        onTab(e);\n      } else if (!isInsideInput() && getOptions().keyboardScrolling && canScrollWithKeyboard) {\n        g_controlPressed = e.ctrlKey;\n        g_keydownId = setTimeout(function () {\n          onkeydown(e);\n        }, 0);\n      }\n    }\n    /**\n    * Keydown event\n    */\n\n\n    function onkeydown(e) {\n      var shiftPressed = e.shiftKey;\n      var activeElement = doc.activeElement;\n      var isMediaFocused = matches(activeElement, 'video') || matches(activeElement, 'audio');\n      var isScrolled = {\n        up: scrollOverflowHandler.isScrolled('up', getState().activeSection.item),\n        down: scrollOverflowHandler.isScrolled('down', getState().activeSection.item)\n      };\n      var isUsingHorizontalArrowKeys = [37, 39].indexOf(e.keyCode) > -1;\n      cancelDirectionKeyEvents(e); //do nothing if we can not scroll or we are not using horizotnal key arrows.\n\n      if (!state.canScroll && !isUsingHorizontalArrowKeys) {\n        return;\n      }\n\n      setState({\n        scrollTrigger: 'keydown'\n      });\n\n      switch (e.keyCode) {\n        //up\n        case 38:\n        case 33:\n          if (getIsScrollAllowed().k.up && isScrolled.up) {\n            if (state.isBeyondFullpage) {\n              EventEmitter.emit(events.onKeyDown, {\n                e: e\n              });\n            } else {\n              moveSectionUp();\n            }\n          } else {\n            scrollOverflowHandler.focusScrollable();\n          }\n\n          break;\n        //down\n\n        case 32:\n          //spacebar\n          if (shiftPressed && getIsScrollAllowed().k.up && !isMediaFocused && isScrolled.up) {\n            moveSectionUp();\n            break;\n          }\n\n        /* falls through */\n\n        case 40:\n        case 34:\n          if (getIsScrollAllowed().k.down && isScrolled.down) {\n            if (state.isBeyondFullpage) {\n              return;\n            } // space bar?\n\n\n            if (e.keyCode !== 32 || !isMediaFocused) {\n              moveSectionDown();\n            }\n          } else {\n            scrollOverflowHandler.focusScrollable();\n          }\n\n          break;\n        //Home\n\n        case 36:\n          if (getIsScrollAllowed().k.up) {\n            moveTo$1(1);\n          }\n\n          break;\n        //End\n\n        case 35:\n          if (getIsScrollAllowed().k.down) {\n            moveTo$1(getState().sections.length);\n          }\n\n          break;\n        //left\n\n        case 37:\n          if (getIsScrollAllowed().k.left) {\n            moveSlideLeft();\n          }\n\n          break;\n        //right\n\n        case 39:\n          if (getIsScrollAllowed().k.right) {\n            moveSlideRight();\n          }\n\n          break;\n\n        default:\n          return;\n        // exit this handler for other keys\n      }\n    } //to prevent scrolling while zooming\n\n\n    function keyUpHandler(e) {\n      if (state.isWindowFocused) {\n        //the keyup gets fired on new tab ctrl + t in Firefox\n        g_controlPressed = e.ctrlKey;\n      }\n    } //when opening a new tab (ctrl + t), `control` won't be pressed when coming back.\n\n\n    function blurHandler() {\n      setState({\n        isWindowFocused: false\n      });\n      g_controlPressed = false;\n    }\n    /**\n    * Makes sure the tab key will only focus elements within the current section/slide\n    * preventing this way from breaking the page.\n    * Based on \"Modals and keyboard traps\"\n    * from https://developers.google.com/web/fundamentals/accessibility/focus/using-tabindex\n    */\n\n\n    function onTab(e) {\n      var isShiftPressed = e.shiftKey;\n      var activeElement = doc.activeElement;\n      var focusableElements = getFocusables(getSlideOrSection(getState().activeSection.item));\n\n      function preventAndFocusFirst(e) {\n        preventDefault(e);\n        return focusableElements[0] ? focusableElements[0].focus() : null;\n      } // deactivating tab while scrolling #4550\n\n\n      if (!state.canScroll) {\n        preventDefault(e);\n        return;\n      } //outside any section or slide? Let's not hijack the tab!\n\n\n      if (isFocusOutside(e)) {\n        return;\n      } //is there an element with focus?\n\n\n      if (activeElement) {\n        if (closest(activeElement, SECTION_ACTIVE_SEL + ',' + SECTION_ACTIVE_SEL + ' ' + SLIDE_ACTIVE_SEL) == null) {\n          activeElement = preventAndFocusFirst(e);\n        }\n      } //no element if focused? Let's focus the first one of the section/slide\n      else {\n        preventAndFocusFirst(e);\n      } //when reached the first or last focusable element of the section/slide\n      //we prevent the tab action to keep it in the last focusable element\n\n\n      var isFirstFocusableInSection = activeElement == focusableElements[0];\n      var isLastFocusableInSection = activeElement == focusableElements[focusableElements.length - 1];\n      var isNextItem = !isShiftPressed && isLastFocusableInSection;\n      var isPrevItem = isShiftPressed && isFirstFocusableInSection;\n\n      if (isPrevItem || isNextItem) {\n        preventDefault(e);\n        var focusInfo = getPanelWithFocusable(isPrevItem);\n        var destinationPanel = focusInfo ? focusInfo.panel : null;\n\n        if (destinationPanel) {\n          var destinationSection = destinationPanel.isSection ? destinationPanel : destinationPanel.parent;\n          EventEmitter.emit(events.onScrollPageAndSlide, {\n            sectionAnchor: destinationSection.index() + 1,\n            slideAnchor: destinationPanel.isSection ? 0 : destinationPanel.index()\n          });\n          g_elToFocus = focusInfo.itemToFocus;\n          preventDefault(e);\n        }\n      }\n    }\n\n    function onAfterSlideLoads(v) {\n      focusItem();\n    }\n\n    function afterSectionLoads(v) {\n      if (!closest(g_elToFocus, SLIDE_SEL) || closest(g_elToFocus, SLIDE_ACTIVE_SEL)) {\n        focusItem();\n      }\n    }\n\n    function focusItem() {\n      if (g_elToFocus) {\n        g_elToFocus.focus();\n        g_elToFocus = null;\n      }\n    }\n    /**\n     * Get's the panel containing the element to focus.\n     *\n     */\n\n\n    function getPanelWithFocusable(isPrevItem) {\n      var action = isPrevItem ? 'prevPanel' : 'nextPanel';\n      var focusableElements = [];\n      var panelWithFocusables;\n      var currentPanel = getSlideOrSectionPanel(getActivePanel()[action]());\n\n      do {\n        focusableElements = getFocusables(currentPanel.item);\n\n        if (focusableElements.length) {\n          panelWithFocusables = {\n            panel: currentPanel,\n            itemToFocus: focusableElements[isPrevItem ? focusableElements.length - 1 : 0]\n          };\n        }\n\n        currentPanel = getSlideOrSectionPanel(currentPanel[action]());\n      } while (currentPanel && focusableElements.length === 0);\n\n      return panelWithFocusables;\n    }\n    /**\n    * Gets all the focusable elements inside the passed element.\n    */\n\n\n    function getFocusables(el) {\n      return [].slice.call($(focusableElementsString, el)).filter(function (item) {\n        return getAttr(item, 'tabindex') !== '-1' && //are also not hidden elements (or with hidden parents)\n        item.offsetParent !== null;\n      });\n    }\n    /**\n    * Determines whether the focus is outside fullpage.js sections/slides or not.\n    */\n\n\n    function isFocusOutside(e) {\n      var allFocusables = getFocusables(doc);\n      var currentFocusIndex = allFocusables.indexOf(doc.activeElement);\n      var focusDestinationIndex = e.shiftKey ? currentFocusIndex - 1 : currentFocusIndex + 1;\n      var focusDestination = allFocusables[focusDestinationIndex];\n      var destinationItemSlide = closest(focusDestination, SLIDE_SEL);\n      var destinationItemSection = closest(focusDestination, SECTION_SEL);\n      return !destinationItemSlide && !destinationItemSection;\n    }\n\n    function shouldCancelKeyboardNavigation(e) {\n      // https://keycode.info/for/34\n      // 40 = arrow down\n      // 38 = arrow up\n      // 32 = spacebar\n      // 33  = PageUp\n      // 34 = PageDown\n      var keyControls = [40, 38, 32, 33, 34];\n      return keyControls.indexOf(e.keyCode) > -1 && !state.isBeyondFullpage;\n    } //preventing the scroll with arrow keys & spacebar & Page Up & Down keys\n\n\n    function cancelDirectionKeyEvents(e) {\n      if (shouldCancelKeyboardNavigation(e) && !closest(e.target, OVERFLOW_SEL)) {\n        e.preventDefault();\n      }\n    }\n\n    function getControlPressed() {\n      return g_controlPressed;\n    }\n\n    var prevTime = new Date().getTime();\n    var scrollings = [];\n    FP.setMouseWheelScrolling = setMouseWheelScrolling;\n    /**\n    * Adds or remove the possibility of scrolling through sections by using the mouse wheel or the trackpad.\n    */\n\n    function setMouseWheelScrolling(value) {\n      if (value) {\n        addMouseWheelHandler();\n        addMiddleWheelHandler();\n      } else {\n        removeMouseWheelHandler();\n        removeMiddleWheelHandler();\n      }\n    }\n    /**\n    * Adds the auto scrolling action for the mouse wheel and trackpad.\n    * After this function is called, the mousewheel and trackpad movements will scroll through sections\n    * https://developer.mozilla.org/en-US/docs/Web/Events/wheel\n    */\n\n\n    function addMouseWheelHandler() {\n      var prefix = '';\n\n      var _addEventListener;\n\n      if (win.addEventListener) {\n        _addEventListener = \"addEventListener\";\n      } else {\n        _addEventListener = \"attachEvent\";\n        prefix = 'on';\n      } // detect available wheel event\n\n\n      var support = 'onwheel' in doc.createElement('div') ? 'wheel' : // Modern browsers support \"wheel\"\n      // @ts-ignore\n      doc.onmousewheel !== undefined ? 'mousewheel' : // Webkit and IE support at least \"mousewheel\"\n      'DOMMouseScroll'; // let's assume that remaining browsers are older Firefox\n\n      var passiveEvent = getPassiveOptionsIfPossible();\n\n      if (support == 'DOMMouseScroll') {\n        doc[_addEventListener](prefix + 'MozMousePixelScroll', MouseWheelHandler, passiveEvent);\n      } //handle MozMousePixelScroll in older Firefox\n      else {\n        doc[_addEventListener](prefix + support, MouseWheelHandler, passiveEvent);\n      }\n    }\n    /**\n    * Binding the mousemove when the mouse's middle button is pressed\n    */\n\n\n    function addMiddleWheelHandler() {\n      getContainer().addEventListener('mousedown', mouseDownHandler);\n      getContainer().addEventListener('mouseup', mouseUpHandler);\n    }\n    /**\n    * Removes the auto scrolling action fired by the mouse wheel and trackpad.\n    * After this function is called, the mousewheel and trackpad movements won't scroll through sections.\n    */\n\n\n    function removeMouseWheelHandler() {\n      if (doc.addEventListener) {\n        docRemoveEvent('mousewheel', MouseWheelHandler, false); //IE9, Chrome, Safari, Oper\n\n        docRemoveEvent('wheel', MouseWheelHandler, false); //Firefox\n\n        docRemoveEvent('MozMousePixelScroll', MouseWheelHandler, false); //old Firefox\n      } else {\n        // @ts-ignore\n        doc.detachEvent('onmousewheel', MouseWheelHandler); //IE 6/7/8\n      }\n    }\n    /**\n    * Unbinding the mousemove when the mouse's middle button is released\n    */\n\n\n    function removeMiddleWheelHandler() {\n      getContainer().removeEventListener('mousedown', mouseDownHandler);\n      getContainer().removeEventListener('mouseup', mouseUpHandler);\n    }\n    /**\n     * Detecting mousewheel scrolling\n     *\n     * http://blogs.sitepointstatic.com/examples/tech/mouse-wheel/index.html\n     * http://www.sitepoint.com/html5-javascript-mouse-wheel/\n     */\n\n\n    function MouseWheelHandler(e) {\n      var curTime = new Date().getTime();\n      var isNormalScroll = hasClass($(COMPLETELY_SEL)[0], NORMAL_SCROLL);\n      var isScrollAllowedBeyondFullPage = beyondFullPageHandler(getContainer(), e);\n\n      if (!state.isUsingWheel) {\n        setState({\n          isGrabbing: false,\n          isUsingWheel: true,\n          touchDirection: 'none'\n        });\n      } //is scroll allowed?\n\n\n      if (!getIsScrollAllowed().m.down && !getIsScrollAllowed().m.up) {\n        return false;\n      }\n\n      if (isScrollAllowedBeyondFullPage) {\n        return true;\n      } else if (isScrollAllowedBeyondFullPage === false) {\n        preventDefault(e);\n        return false;\n      } //autoscrolling and not zooming?\n\n\n      if (getOptions().autoScrolling && !getControlPressed() && !isNormalScroll) {\n        // cross-browser wheel delta\n        e = e || win.event;\n        var value = e.wheelDelta || -e.deltaY || -e.detail;\n        var delta = Math.max(-1, Math.min(1, value));\n        var horizontalDetection = typeof e.wheelDeltaX !== 'undefined' || typeof e.deltaX !== 'undefined';\n        var isScrollingVertically = Math.abs(e.wheelDeltaX) < Math.abs(e.wheelDelta) || Math.abs(e.deltaX) < Math.abs(e.deltaY) || !horizontalDetection;\n        var direction = delta < 0 ? 'down' : delta > 0 ? 'up' : 'none'; //Limiting the array to 150 (lets not waste memory!)\n\n        if (scrollings.length > 149) {\n          scrollings.shift();\n        } //keeping record of the previous scrollings\n\n\n        scrollings.push(Math.abs(value)); //preventing to scroll the site on mouse wheel when scrollbar is present\n\n        if (getOptions().scrollBar || !getOptions().scrollOverflow) {\n          preventDefault(e);\n        } //time difference between the last scroll and the current one\n\n\n        var timeDiff = curTime - prevTime;\n        prevTime = curTime; //haven't they scrolled in a while?\n        //(enough to be consider a different scrolling action to scroll another section)\n\n        if (timeDiff > 200) {\n          //emptying the array, we dont care about old scrollings for our averages\n          scrollings = [];\n        }\n\n        setState({\n          wheelDirection: direction\n        });\n\n        if (state.canScroll) {\n          var averageEnd = getAverage(scrollings, 10);\n          var averageMiddle = getAverage(scrollings, 70);\n          var isAccelerating = averageEnd >= averageMiddle; //to avoid double swipes...\n\n          if (isAccelerating && isScrollingVertically) {\n            setState({\n              scrollTrigger: 'wheel'\n            }); //scrolling down?\n\n            if (delta < 0) {\n              scrolling('down');\n            } //scrolling up?\n            else {\n              scrolling('up');\n            }\n          }\n        }\n\n        return false;\n      }\n\n      if (getOptions().fitToSection) {\n        //stopping the auto scroll to adjust to a section\n        setState({\n          activeAnimation: false\n        });\n      }\n    } //binding the mousemove when the mouse's middle button is released\n\n\n    function mouseDownHandler(e) {\n      //middle button\n      if (e.which == 2) {\n        setOldPageY(e.pageY);\n        getContainer().addEventListener('mousemove', mouseMoveHandler);\n      }\n    } //unbinding the mousemove when the mouse's middle button is released\n\n\n    function mouseUpHandler(e) {\n      //middle button\n      if (e.which == 2) {\n        getContainer().removeEventListener('mousemove', mouseMoveHandler);\n      }\n    }\n    /**\n    * Adds or remove the mouse wheel hijacking\n    */\n\n\n    function setMouseHijack(value) {\n      if (value) {\n        setMouseWheelScrolling(true);\n        addTouchHandler();\n      } else {\n        setMouseWheelScrolling(false);\n        removeTouchHandler();\n      }\n    }\n\n    var g_canFireMouseEnterNormalScroll = true;\n    EventEmitter.on(events.bindEvents, bindEvents$7);\n\n    function bindEvents$7() {\n      /**\n      * Applying normalScroll elements.\n      * Ignoring the scrolls over the specified selectors.\n      */\n      if (getOptions().normalScrollElements) {\n        ['mouseenter', 'touchstart'].forEach(function (eventName) {\n          forMouseLeaveOrTouch(eventName, false);\n        });\n        ['mouseleave', 'touchend'].forEach(function (eventName) {\n          forMouseLeaveOrTouch(eventName, true);\n        });\n      }\n\n      EventEmitter.on(events.onDestroy, onDestroy$4);\n    }\n\n    function onDestroy$4() {\n      ['mouseenter', 'touchstart', 'mouseleave', 'touchend'].forEach(function (eventName) {\n        docRemoveEvent(eventName, onMouseEnterOrLeave, true); //true is required!\n      });\n    }\n\n    function forMouseLeaveOrTouch(eventName, allowScrolling) {\n      //a way to pass arguments to the onMouseEnterOrLeave function\n      document['fp_' + eventName] = allowScrolling;\n      docAddEvent(eventName, onMouseEnterOrLeave, true); //capturing phase\n    }\n\n    function onMouseEnterOrLeave(e) {\n      var type = e.type;\n      var isInsideOneNormalScroll = false; //onMouseLeave will use the destination target, not the one we are moving away from\n\n      var target = type === 'mouseleave' ? e.toElement || e.relatedTarget : e.target; //coming from closing a normalScrollElements modal or moving outside viewport?\n\n      if (target == document || !target) {\n        setMouseHijack(true);\n        return;\n      }\n\n      if (type === 'touchend') {\n        g_canFireMouseEnterNormalScroll = false;\n        setTimeout(function () {\n          g_canFireMouseEnterNormalScroll = true;\n        }, 800);\n      } //preventing mouseenter event to do anything when coming from a touchEnd event\n      //fixing issue #3576\n\n\n      if (type === 'mouseenter' && !g_canFireMouseEnterNormalScroll) {\n        return;\n      }\n\n      var normalSelectors = getOptions().normalScrollElements.split(',');\n      normalSelectors.forEach(function (normalSelector) {\n        if (!isInsideOneNormalScroll) {\n          var isNormalScrollTarget = matches(target, normalSelector); //leaving a child inside the normalScoll element is not leaving the normalScroll #3661\n\n          var isNormalScrollChildFocused = closest(target, normalSelector);\n\n          if (isNormalScrollTarget || isNormalScrollChildFocused) {\n            if (!FP.shared.isNormalScrollElement) {\n              setMouseHijack(false);\n            }\n\n            FP.shared.isNormalScrollElement = true;\n            isInsideOneNormalScroll = true;\n          }\n        }\n      }); //not inside a single normal scroll element anymore?\n\n      if (!isInsideOneNormalScroll && FP.shared.isNormalScrollElement) {\n        setMouseHijack(true);\n        FP.shared.isNormalScrollElement = false;\n      }\n    }\n\n    FP.silentMoveTo = silentMoveTo;\n    /**\n    * Moves the page to the given section and slide with no animation.\n    * Anchors or index positions can be used as params.\n    */\n\n    function silentMoveTo(sectionAnchor, slideAnchor) {\n      setScrollingSpeed(0, 'internal');\n      moveTo$1(sectionAnchor, slideAnchor);\n      setScrollingSpeed(getOriginals().scrollingSpeed, 'internal');\n    }\n\n    var previousHeight = getWindowHeight();\n    var windowsWidth = getWindowWidth();\n    var g_resizeId;\n    var g_isConsecutiveResize = false;\n    var g_resizeMobileHandlerId;\n    FP.reBuild = reBuild;\n    EventEmitter.on(events.bindEvents, bindEvents$6);\n\n    function bindEvents$6() {\n      // Setting VH correctly in mobile devices\n      resizeHandler(); //when resizing the site, we adjust the heights of the sections, slimScroll...\n\n      windowAddEvent('resize', resizeHandler);\n      EventEmitter.on(events.onDestroy, onDestroy$3);\n    }\n\n    function onDestroy$3() {\n      clearTimeout(g_resizeId);\n      clearTimeout(g_resizeMobileHandlerId);\n      windowRemoveEvent('resize', resizeHandler);\n    }\n    /*\n    * Resize event handler.\n    */\n\n\n    function resizeHandler() {\n      if (!g_isConsecutiveResize) {\n        if (getOptions().autoScrolling && !getOptions().scrollBar || !getOptions().fitToSection) {\n          setSectionsHeight(getWindowHeight());\n        }\n      } // we won't trigger fit to section on page load\n      // otherwise it will scroll to the worng section if using anchors #4613\n\n\n      if (state.isFullpageInitDone) {\n        fitToActiveSection();\n      }\n\n      g_isConsecutiveResize = true; //in order to call the functions only when the resize is finished\n      //http://stackoverflow.com/questions/4298612/jquery-how-to-call-resize-event-only-once-its-finished-resizing    \n\n      clearTimeout(g_resizeId);\n      g_resizeId = setTimeout(function () {\n        //issue #3336 \n        //(some apps or browsers, like Chrome/Firefox for Mobile take time to report the real height)\n        //so we check it 3 times with intervals in that case\n        // for(var i = 0; i< 4; i++){\n        resizeActions();\n        g_isConsecutiveResize = false; // }\n      }, 400);\n    }\n\n    function fitToActiveSection() {\n      if (isTouchDevice) {\n        // Issue #4393 and previously in v3, #3336\n        // (some apps or browsers, like Chrome/Firefox will delay a bit to scroll \n        // to the focused input\n        for (var i = 0; i < 4; i++) {\n          g_resizeMobileHandlerId = setTimeout(function () {\n            window.requestAnimationFrame(function () {\n              // on Android devices the browser scrolls to the focused element\n              // messing up the whole page structure. So we need to update the\n              // translate3d value when the keyboard shows/hides\n              if (getOptions().autoScrolling && !getOptions().scrollBar) {\n                setState({\n                  isResizing: true\n                });\n                silentMoveTo(state.activeSection.index() + 1);\n                setState({\n                  isResizing: false\n                });\n              }\n            });\n          }, 200 * i);\n        }\n      }\n    }\n    /**\n     * Checks if VH units need to be set based on scrolling configuration\n     */\n\n\n    function shouldSetVhUnits() {\n      return !state.isBeyondFullpage && !getOptions().autoScrolling;\n    }\n    /**\n    * When resizing the site, we adjust the heights of the sections, slimScroll...\n    */\n\n\n    function resizeActions() {\n      setState({\n        isResizing: true\n      });\n\n      if (!isTouchDevice || getOptions().adjustOnNavChange) {\n        setSectionsHeight('');\n\n        if (shouldSetVhUnits()) {\n          setVhUnits();\n        }\n      }\n\n      EventEmitter.emit(events.contentChanged);\n      updateState(); //checking if it needs to get responsive\n\n      responsive(); // rebuild immediately on touch devices\n\n      if (isTouchDevice) {\n        var activeElement = doc.activeElement; //if the keyboard is NOT visible\n\n        if (!matches(activeElement, 'textarea') && !matches(activeElement, 'input') && !matches(activeElement, 'select')) {\n          var currentHeight = getWindowHeight(); //making sure the change in the viewport size is enough to force a rebuild. (20 % of the window to avoid problems when hidding scroll bars)\n\n          if (Math.abs(currentHeight - previousHeight) > 20 * Math.max(previousHeight, currentHeight) / 100) {\n            reBuild(true);\n            previousHeight = currentHeight;\n          }\n        }\n      } else {\n        adjustToNewViewport();\n      }\n\n      setState({\n        isResizing: false\n      });\n    }\n    /**\n     * When resizing is finished, we adjust the slides sizes and positions\n     */\n\n\n    function reBuild(resizing) {\n      if (hasClass(getContainer(), DESTROYED)) {\n        return;\n      } //nothing to do if the plugin was destroyed\n      //updating global vars\n\n\n      setState({\n        isResizing: true,\n        windowsHeight: getWindowHeight(),\n        windowsWidth: getWindowWidth()\n      });\n      var sections = getState().sections;\n\n      for (var i = 0; i < sections.length; ++i) {\n        var section = sections[i];\n        var slidesWrap = $(SLIDES_WRAPPER_SEL, section.item)[0];\n        var slides = section.slides; //adjusting the position fo the FULL WIDTH slides...\n\n        if (slides.length > 1) {\n          landscapeScroll(slidesWrap, section.activeSlide.item);\n        }\n      }\n\n      if (getOptions().scrollOverflow) {\n        scrollOverflowHandler.makeScrollable();\n      }\n\n      var sectionIndex = getState().activeSection.index();\n\n      if (!state.isBeyondFullpage) {\n        //isn't it the first section?\n        if (sectionIndex) {\n          //adjusting the position for the current section\n          silentMoveTo(sectionIndex + 1);\n        }\n      }\n\n      setState({\n        isResizing: false\n      });\n\n      if (isFunction(getOptions().afterResize) && resizing) {\n        getOptions().afterResize.call(getContainer(), win.innerWidth, win.innerHeight);\n      }\n\n      if (isFunction(getOptions().afterReBuild) && !resizing) {\n        getOptions().afterReBuild.call(getContainer());\n      }\n\n      trigger(getContainer(), 'afterRebuild');\n    }\n    /**\n    * Adjusts a section to the viewport if it has changed.\n    */\n\n\n    function adjustToNewViewport() {\n      var newWindowHeight = getWindowHeight();\n      var newWindowWidth = getWindowWidth();\n\n      if (state.windowsHeight !== newWindowHeight || windowsWidth !== newWindowWidth) {\n        setState({\n          windowsHeight: newWindowHeight\n        });\n        windowsWidth = newWindowWidth;\n        reBuild(true);\n      }\n    }\n\n    function setSectionsHeight(value) {\n      var propertyValue = value === '' ? '' : value + 'px';\n      getState().sections.forEach(function (section) {\n        css(section.item, {\n          'height': propertyValue\n        });\n      });\n    }\n    /**\n     * Defining the value in px of a VH unit. (Used for autoScrolling: false)\n     * To fix the height issue on mobile devices when using VH units.\n     * https://css-tricks.com/the-trick-to-viewport-units-on-mobile/\n     */\n\n\n    function setVhUnits() {\n      // First we get the viewport height and we multiple it by 1% to get a value for a vh unit\n      var vh = win.innerHeight * 0.01; // Then we set the value in the --vh custom property to the root of the document\n\n      doc.documentElement.style.setProperty('--vh', \"\".concat(vh, \"px\"));\n    }\n\n    function getAnchorsURL() {\n      var section;\n      var slide;\n      var hash = win.location.hash;\n\n      if (hash.length) {\n        //getting the anchor link in the URL and deleting the `#`\n        var anchorsParts = hash.replace('#', '').split('/'); //using / for visual reasons and not as a section/slide separator #2803\n\n        var isFunkyAnchor = hash.indexOf('#/') > -1;\n        section = isFunkyAnchor ? '/' + anchorsParts[1] : decodeURIComponent(anchorsParts[0]);\n        var slideAnchor = isFunkyAnchor ? anchorsParts[2] : anchorsParts[1];\n\n        if (slideAnchor && slideAnchor.length) {\n          slide = decodeURIComponent(slideAnchor);\n        }\n      }\n\n      return {\n        section: section,\n        slide: slide\n      };\n    }\n\n    FP.setLockAnchors = setLockAnchors;\n    EventEmitter.on(events.bindEvents, bindEvents$5);\n\n    function bindEvents$5() {\n      //detecting any change on the URL to scroll to the given anchor link\n      //(a way to detect back history button as we play with the hashes on the URL)\n      windowAddEvent('hashchange', hashChangeHandler);\n      EventEmitter.on(events.onDestroy, onDestroy$2);\n    }\n\n    function onDestroy$2() {\n      windowRemoveEvent('hashchange', hashChangeHandler);\n    }\n    /**\n    * Sets lockAnchors\n    */\n\n\n    function setLockAnchors(value) {\n      getOptions().lockAnchors = value;\n    }\n    /**\n    * Detecting any change on the URL to scroll to the given anchor link\n    * (a way to detect back history button as we play with the hashes on the URL)\n    */\n\n\n    function hashChangeHandler() {\n      if (!state.isScrolling && !getOptions().lockAnchors) {\n        var anchors = getAnchorsURL();\n        var sectionAnchor = anchors.section;\n        var slideAnchor = anchors.slide; //when moving to a slide in the first section for the first time (first time to add an anchor to the URL)\n\n        var isFirstSlideMove = typeof state.lastScrolledDestiny === 'undefined';\n        var isFirstScrollMove = typeof state.lastScrolledDestiny === 'undefined' && typeof slideAnchor === 'undefined' && !state.slideMoving;\n\n        if (sectionAnchor && sectionAnchor.length) {\n          /*in order to call scrollpage() only once for each destination at a time\n          It is called twice for each scroll otherwise, as in case of using anchorlinks `hashChange`\n          event is fired on every scroll too.*/\n          if (sectionAnchor && sectionAnchor !== state.lastScrolledDestiny && !isFirstSlideMove || isFirstScrollMove || !state.slideMoving && state.lastScrolledSlide != slideAnchor) {\n            EventEmitter.emit(events.onScrollPageAndSlide, {\n              sectionAnchor: sectionAnchor,\n              slideAnchor: slideAnchor\n            });\n          }\n        }\n      }\n    }\n\n    EventEmitter.on(events.bindEvents, bindEvents$4);\n\n    function bindEvents$4() {\n      docAddEvent('wheel', wheelDataHandler.registerEvent, getPassiveOptionsIfPossible());\n      EventEmitter.on(events.scrollBeyondFullpage, scrollBeyondFullPage);\n      EventEmitter.on(events.onKeyDown, onKeyDown);\n    }\n\n    EventEmitter.on(events.bindEvents, bindEvents$3);\n\n    function bindEvents$3() {\n      EventEmitter.on(events.onClickOrTouch, onClickOrTouch$1);\n    }\n\n    function onClickOrTouch$1(params) {\n      var target = params.target;\n\n      if (closest(target, getOptions().menu + ' [data-menuanchor]')) {\n        menuItemsHandler.call(target, params.e);\n      }\n    } //Menu item handler when not using anchors or using lockAnchors:true\n\n\n    function menuItemsHandler(e) {\n      setState({\n        scrollTrigger: 'menu'\n      });\n\n      if ($(getOptions().menu)[0] && (getOptions().lockAnchors || !getOptions().anchors.length)) {\n        preventDefault(e);\n        var menuAnchorEl = closest(this, '[data-menuanchor]');\n        /*jshint validthis:true */\n\n        EventEmitter.emit(events.onMenuClick, {\n          anchor: getAttr(menuAnchorEl, 'data-menuanchor')\n        });\n      }\n    }\n\n    EventEmitter.on(events.bindEvents, bindEvents$2);\n\n    function bindEvents$2() {\n      EventEmitter.on(events.onClickOrTouch, onClickOrTouch);\n    }\n\n    function onClickOrTouch(params) {\n      var target = params.target;\n\n      if (target && closest(target, SECTION_NAV_SEL + ' a')) {\n        sectionBulletHandler.call(target, params.e);\n      } else if (matches(target, SECTION_NAV_TOOLTIP_SEL)) {\n        tooltipTextHandler.call(target);\n      } else if (matches(target, SLIDES_NAV_LINK_SEL) || closest(target, SLIDES_NAV_LINK_SEL) != null) {\n        slideBulletHandler.call(target, params.e);\n      }\n    }\n\n    var lastScroll = 0;\n    var g_scrollId;\n    var g_scrollId2;\n    EventEmitter.on(events.onDestroy, onDestroy$1); //when scrolling...\n\n    function scrollHandler(e) {\n      var currentSection;\n      var currentSectionElem;\n\n      if (state.isResizing || !getState().activeSection) {\n        return;\n      }\n\n      getLast(getState().sections);\n\n      if (getState().isBeyondFullpage || getState().isAboutToScrollToFullPage) {\n        return;\n      }\n\n      if (!getOptions().autoScrolling || getOptions().scrollBar) {\n        var currentScroll = getScrollTop();\n        var scrollDirection = getScrollDirection(currentScroll);\n        var visibleSectionIndex = 0;\n        var screen_mid = currentScroll + getWindowHeight() / 2.0;\n        var isAtBottom = $body.scrollHeight - getWindowHeight() === currentScroll;\n        var sections = getState().sections;\n        setState({\n          scrollY: currentScroll\n        }); //when using `auto-height` for a small last section it won't be centered in the viewport\n\n        if (isAtBottom) {\n          visibleSectionIndex = sections.length - 1;\n        } //is at top? when using `auto-height` for a small first section it won't be centered in the viewport\n        else if (!currentScroll) {\n          visibleSectionIndex = 0;\n        } //taking the section which is showing more content in the viewport\n        else {\n          for (var i = 0; i < sections.length; ++i) {\n            var section = sections[i].item; // Pick the the last section which passes the middle line of the screen.\n\n            if (section.offsetTop <= screen_mid) {\n              visibleSectionIndex = i;\n            }\n          }\n        }\n\n        if (isCompletelyInViewPort(scrollDirection)) {\n          if (!hasClass(getState().activeSection.item, COMPLETELY)) {\n            addClass(getState().activeSection.item, COMPLETELY);\n            removeClass(siblings(getState().activeSection.item), COMPLETELY);\n          }\n        } //geting the last one, the current one on the screen\n\n\n        currentSection = sections[visibleSectionIndex];\n        currentSectionElem = currentSection.item; //setting the visible section as active when manually scrolling\n        //executing only once the first time we reach the section\n\n        if (!currentSection.isActive) {\n          setState({\n            isScrolling: true\n          });\n          var leavingSection = getState().activeSection.item;\n          var leavingSectionIndex = getState().activeSection.index() + 1;\n          var yMovement = getYmovement(getState().activeSection, currentSectionElem);\n          var anchorLink = currentSection.anchor;\n          var sectionIndex = currentSection.index() + 1;\n          var activeSlide = currentSection.activeSlide;\n          var slideIndex;\n          var slideAnchorLink;\n          var callbacksParams = {\n            activeSection: leavingSection,\n            sectionIndex: sectionIndex - 1,\n            anchorLink: anchorLink,\n            element: currentSectionElem,\n            leavingSection: leavingSectionIndex,\n            direction: yMovement,\n            items: {\n              origin: getState().activeSection,\n              destination: currentSection\n            }\n          };\n\n          if (activeSlide) {\n            slideAnchorLink = activeSlide.anchor;\n            slideIndex = activeSlide.index();\n          }\n\n          if (state.canScroll) {\n            addClass(currentSectionElem, ACTIVE);\n            removeClass(siblings(currentSectionElem), ACTIVE);\n\n            if (isFunction(getOptions().beforeLeave)) {\n              fireCallbackOncePerScroll('beforeLeave', callbacksParams);\n            }\n\n            if (isFunction(getOptions().onLeave)) {\n              fireCallback('onLeave', callbacksParams);\n            }\n\n            if (isFunction(getOptions().afterLoad)) {\n              fireCallback('afterLoad', callbacksParams);\n            }\n\n            stopMedia(leavingSection);\n            lazyLoadPanels(currentSection);\n            playMedia(currentSectionElem);\n            activateMenuAndNav(anchorLink, sectionIndex - 1);\n\n            if (getOptions().anchors.length) {\n              //needed to enter in hashChange event when using the menu with anchor links\n              setState({\n                lastScrolledDestiny: anchorLink\n              });\n            }\n\n            updateState();\n            setPageStatus(slideIndex, slideAnchorLink, anchorLink);\n          } //small timeout in order to avoid entering in hashChange event when scrolling is not finished yet\n\n\n          clearTimeout(g_scrollId);\n          g_scrollId = setTimeout(function () {\n            setState({\n              isScrolling: false\n            });\n          }, 100);\n        }\n\n        if (getOptions().fitToSection && state.canScroll) {\n          clearTimeout(g_scrollId2);\n          g_scrollId2 = setTimeout(function () {\n            var fixedSections = state.sections.filter(function (section) {\n              var sectionValues = section.item.getBoundingClientRect();\n              return Math.round(sectionValues.bottom) === Math.round(getWindowHeight()) || Math.round(sectionValues.top) === 0;\n            }); // No section is fitting the viewport? Let's fix that!\n\n            if (!fixedSections.length) {\n              if (isTouchDevice && isFormElementFocused()) {\n                // Exit early to avoid fixing the section while interacting with form elements\n                return;\n              } else {\n                fitToSection();\n              }\n            }\n          }, getOptions().fitToSectionDelay);\n        }\n      }\n    }\n\n    function isFormElementFocused() {\n      var focusedElement = document.activeElement;\n      if (!focusedElement) return false; // Include only elements that trigger the keyboard on mobile\n\n      return focusedElement.matches('input, textarea');\n    }\n\n    function onDestroy$1() {\n      clearTimeout(g_scrollId);\n      clearTimeout(g_scrollId2);\n    }\n    /**\n    * Gets the directon of the the scrolling fired by the scroll event.\n    */\n\n\n    function getScrollDirection(currentScroll) {\n      var direction = currentScroll > lastScroll ? 'down' : 'up';\n      lastScroll = currentScroll; //needed for auto-height sections to determine if we want to scroll to the top or bottom of the destination\n\n      setState({\n        previousDestTop: currentScroll\n      });\n      return direction;\n    }\n    /**\n    * Determines whether the active section has seen in its whole or not.\n    */\n\n\n    function isCompletelyInViewPort(movement) {\n      var top = getState().activeSection.item.offsetTop;\n      var bottom = top + getWindowHeight();\n\n      if (movement == 'up') {\n        return bottom >= getScrollTop() + getWindowHeight();\n      }\n\n      return top <= getScrollTop();\n    }\n\n    EventEmitter.on(events.bindEvents, bindEvents$1);\n    EventEmitter.on(events.onDestroy, onDestroy);\n\n    function onDestroy() {\n      windowRemoveEvent('scroll', scrollHandler);\n    }\n\n    function bindEvents$1() {\n      windowAddEvent('scroll', scrollHandler);\n      doc.body.addEventListener('scroll', scrollHandler);\n      EventEmitter.on(events.onScrollPageAndSlide, function (params) {\n        scrollPageAndSlide(params.sectionAnchor, params.slideAnchor);\n      });\n      EventEmitter.on(events.onMenuClick, function (params) {\n        moveTo$1(params.anchor, undefined);\n      });\n      EventEmitter.on(events.onScrollOverflowScrolled, function (params) {\n        var scrollSection = params.direction === 'down' ? moveSectionDown : moveSectionUp;\n        scrollSection();\n      });\n      EventEmitter.on(events.scrollPage, function (params) {\n        scrollPage(params.destination);\n      });\n    }\n\n    FP.getActiveSlide = getActiveSlide;\n\n    FP.getScrollX = function () {\n      return state.scrollX;\n    };\n\n    EventEmitter.on(events.bindEvents, bindEvents);\n\n    function bindEvents() {\n      EventEmitter.on(events.onDestroy, onDestroy$6);\n      EventEmitter.on(events.landscapeScroll, function (params) {\n        landscapeScroll(params.slides, params.destination);\n      });\n      EventEmitter.on(events.moveSlideRight, function (params) {\n        moveSlideRight(params.section);\n      });\n      EventEmitter.on(events.moveSlideLeft, function (params) {\n        moveSlideLeft(params.section);\n      });\n      EventEmitter.on(events.afterSectionLoads, updateScrollX);\n    }\n\n    function updateScrollX(params) {\n      var activeSlide = params.items.destination.activeSlide;\n      var scrollX = activeSlide ? Math.round(activeSlide.offsetLeft) : 0;\n      setState({\n        scrollX: scrollX\n      });\n    }\n    /**\n    * Gets the active slide.\n    */\n\n\n    function getActiveSlide() {\n      return nullOrSlide(getState().activeSection.activeSlide);\n    }\n\n    EventEmitter.on(events.bindEvents, init$1);\n\n    function init$1() {\n      var position = getOptions().credits.position || 'right';\n      var positionStyle = ['left', 'right'].indexOf(position) > -1 ? \"\".concat(position, \": 0;\") : '';\n      var waterMark = \"\\n        <div class=\\\"\".concat(WATERMARK, \"\\\" style=\\\"\").concat(positionStyle, \"\\\">\\n            <a href=\\\"https://alvarotrigo.com/fullPage/\\\" \\n                rel=\\\"nofollow noopener\\\" \\n                target=\\\"_blank\\\" \\n                style=\\\"text-decoration:none; color: #000;\\\">\\n                    \").concat(getOptions().credits.label || 'Made with fullPage.js', \"\\n            </a>\\n        </div>\\n    \");\n      var lastSection = getLast(state.sections);\n      var shouldUseWaterMark = !state.isValid || getOptions().credits.enabled;\n\n      if (lastSection && lastSection.item && shouldUseWaterMark) {\n        lastSection.item.insertAdjacentHTML('beforeend', waterMark);\n      }\n    }\n\n    !function () {\n      EventEmitter.on(events.onInitialise, function () {\n        var n, a, l;\n        setState({\n          isValid: (getOptions().licenseKey, n = getOptions().licenseKey, a = function (n) {\n            var e = parseInt(\"\\x35\\x31\\x34\").toString(16);\n            if (!n || n.length < 29 || 4 === n.split(t[0]).length) return null;\n            var r = [\"\\x45\\x61\\x63\\x68\", \"\\x66\\x6f\\x72\"][i()]().join(\"\"),\n                a = n[[\"\\x73\\x70\\x6c\\x69\\x74\"]](\"-\"),\n                l = [];\n            a[r](function (t, n) {\n              if (n < 4) {\n                var r = function (t) {\n                  var n = t[t.length - 1],\n                      e = [\"\\x4e\\x61\\x4e\", \"\\x69\\x73\"][i()]().join(\"\");\n                  return window[e](n) ? o(n) : function (t) {\n                    return t - ACTIVE.length;\n                  }(n);\n                }(t);\n\n                l.push(r);\n                var s = o(t[r]);\n\n                if (1 === n) {\n                  var a = [\"\\x70\\x61\", \"\\x64\\x53\", \"\\x74\", \"\\x61\\x72\\x74\"].join(\"\");\n                  s = s.toString()[a](2, \"0\");\n                }\n\n                e += s, 0 !== n && 1 !== n || (e += \"-\");\n              }\n            });\n            var f = 0,\n                m = \"\";\n            return n.split(\"-\").forEach(function (t, n) {\n              if (n < 4) {\n                var _i = 0;\n\n                for (var e = 0; e < 4; e++) {\n                  e !== l[n] && (_i += Math.abs(o(t[e])), isNaN(t[e]) || f++);\n                }\n\n                var r = s(_i);\n                m += r;\n              }\n            }), m += s(f), {\n              v: new Date(e + \"T00:00\"),\n              o: e.split(\"-\")[2] === 8 * (ACTIVE.length - 2) + \"\",\n              l: m\n            };\n          }(n), l = function (t) {\n            var n = r[i()]().join(\"\");\n            return t && 0 === n.indexOf(t) && t.length === n.length;\n          }(n) || function (t) {\n            return new RegExp(\"^(?=.*?[A-Y])(?=.*?[a-y])(?=.*?[0-8])(?=.*?[#?!@$%^&*-]).{8,}$\").test(t);\n          }(n), (a || l) && (a && e <= a.v && a.l === n.split(t[0])[4] || l || a.o) || !1)\n        });\n      });\n      var t = [\"-\"];\n      var n = \"\\x32\\x30\\x32\\x35\\x2d\\x35\\x2d\\x32\\x36\".split(\"-\"),\n          e = new Date(n[0], n[1], n[2]),\n          r = [\"se\", \"licen\", \"-\", \"v3\", \"l\", \"gp\"];\n\n      function i() {\n        return [[\"\\x72\\x65\", \"\\x76\\x65\\x72\\x73\\x65\"].join(\"\")][\"\".length];\n      }\n\n      function o(t) {\n        return t ? isNaN(t) ? t.charCodeAt(0) - 72 : t : \"\";\n      }\n\n      function s(t) {\n        var n = 72 + t;\n        return n > 90 && n < 97 && (n += 15), String.fromCharCode(n).toUpperCase();\n      }\n    }();\n\n    EventEmitter.on(events.onPerformMovement, onSlideOrScroll);\n    EventEmitter.on(events.afterSectionLoads, afterPanelLoad);\n    EventEmitter.on(events.onSlideLeave, onSlideOrScroll);\n    EventEmitter.on(events.afterSlideLoads, afterPanelLoad);\n\n    function onSlideOrScroll(params) {\n      var skipValue = getOptions().skipIntermediateItems;\n      var scrollType = params.items.origin.isSection ? 'sections' : 'slides';\n      var areConsecutivePanels = Math.abs(params.items.origin.index() - params.items.destination.index()) > 1;\n      var doesApply = (skipValue === true || skipValue === scrollType) && areConsecutivePanels;\n\n      if (doesApply) {\n        setScrollingSpeed(0, 'internal');\n      }\n    }\n\n    function afterPanelLoad(params) {\n      if (getOptions().skipIntermediateItems) {\n        setVariableState('scrollingSpeed', getOriginals().scrollingSpeed, 'internal');\n      }\n    }\n\n    //@ts-check\n    EventEmitter.on(events.beforeInit, beforeInit);\n    FP.setKeyboardScrolling = setKeyboardScrolling;\n\n    function beforeInit() {\n      setKeyboardScrolling(true);\n    }\n    /**\n    * Adds or remove the possibility of scrolling through sections by using the keyboard arrow keys\n    */\n\n\n    function setKeyboardScrolling(value, directions) {\n      if (typeof directions !== 'undefined') {\n        directions = directions.replace(/ /g, '').split(',');\n        directions.forEach(function (direction) {\n          setIsScrollAllowed(value, direction, 'k');\n        });\n      } else {\n        setIsScrollAllowed(value, 'all', 'k');\n        getOptions().keyboardScrolling = value;\n      }\n    }\n\n    /**\n    * Sets the data-anchor attributes to the menu elements and activates the current one.\n    */\n\n    function styleMenu(section) {\n      var index = section.index();\n\n      if (typeof getOptions().anchors[index] !== 'undefined') {\n        //activating the menu / nav element on load\n        if (section.isActive) {\n          activateMenuAndNav(getOptions().anchors[index], index);\n        }\n      } //moving the menu outside the main container if it is inside (avoid problems with fixed positions when using CSS3 tranforms)\n\n\n      if (getOptions().menu && getOptions().css3 && closest($(getOptions().menu)[0], WRAPPER_SEL) != null) {\n        $(getOptions().menu).forEach(function (menu) {\n          $body.appendChild(menu);\n        });\n      }\n    }\n\n    /**\n    * Works over the DOM structure to set it up for the current fullpage getOptions().\n    */\n\n    function prepareDom() {\n      css(getParentsUntil(getContainer(), 'body'), {\n        'height': '100%',\n        'position': 'relative'\n      }); //adding a class to recognize the container internally in the code\n\n      addClass(getContainer(), WRAPPER);\n      addClass($html, ENABLED); //due to https://github.com/alvarotrigo/fullPage.js/issues/1502\n\n      setState({\n        windowsHeight: getWindowHeight()\n      });\n      removeClass(getContainer(), DESTROYED); //in case it was destroyed before initializing it again\n\n      addInternalSelectors();\n      var sections = getState().sectionsIncludingHidden; //styling the sections / slides / menu\n\n      for (var i = 0; i < sections.length; i++) {\n        var section = sections[i];\n        var slides = section.allSlidesItems; //caching the original styles to add them back on destroy('all')\n\n        var originalStyles = getAttr(section.item, 'style');\n\n        if (originalStyles) {\n          section.item.setAttribute('data-fp-styles', originalStyles);\n        }\n\n        styleSection(section);\n        styleMenu(section); // if there's any slide\n\n        if (slides.length > 0) {\n          styleSlides(section);\n        }\n      } //fixed elements need to be moved out of the plugin container due to problems with CSS3.\n\n\n      if (getOptions().fixedElements && getOptions().css3) {\n        $(getOptions().fixedElements).forEach(function (item) {\n          $body.appendChild(item);\n        });\n      } //vertical centered of the navigation + active bullet\n\n\n      if (getOptions().navigation) {\n        addVerticalNavigation();\n      }\n\n      enableYoutubeAPI();\n\n      if (getOptions().scrollOverflow) {\n        scrollOverflowHandler.makeScrollable();\n      }\n    }\n\n    FP.shared.afterRenderActions = afterRenderActions;\n    /**\n    * Actions and callbacks to fire afterRender\n    */\n\n    function afterRenderActions() {\n      var section = getState().activeSection;\n      var sectionElem = getState().activeSection.item;\n      addClass(sectionElem, COMPLETELY);\n      lazyLoadPanels(getState().activeSection);\n      lazyLoadOthers();\n      playMedia(sectionElem);\n\n      if (isDestinyTheStartingSection() && isFunction(getOptions().afterLoad)) {\n        fireCallback('afterLoad', {\n          activeSection: sectionElem,\n          element: sectionElem,\n          direction: null,\n          //for backwards compatibility callback (to be removed in a future!)\n          anchorLink: section.anchor,\n          sectionIndex: section.index(),\n          items: {\n            origin: getState().activeSection,\n            destination: getState().activeSection\n          }\n        });\n      }\n\n      if (isFunction(getOptions().afterRender)) {\n        fireCallback('afterRender');\n      }\n    }\n    /**\n    * Determines if the URL anchor destiny is the starting section (the one using 'active' class before initialization)\n    */\n\n    function isDestinyTheStartingSection() {\n      var anchor = getAnchorsURL();\n      var destinationSection = getSectionByAnchor(anchor.section);\n      return !anchor.section || !destinationSection || typeof destinationSection !== 'undefined' && destinationSection.index() === index(getStartingSection());\n    }\n\n    FP.setAllowScrolling = setAllowScrolling;\n    /**\n    * Adds or remove the possibility of scrolling through sections by using the mouse wheel/trackpad or touch gestures.\n    * Optionally a second parameter can be used to specify the direction for which the action will be applied.\n    *\n    * @param directions string containing the direction or directions separated by comma.\n    */\n\n    function setAllowScrolling(value, directions) {\n      if (typeof directions !== 'undefined') {\n        directions = directions.replace(/ /g, '').split(',');\n        directions.forEach(function (direction) {\n          setIsScrollAllowed(value, direction, 'm');\n        });\n      } else {\n        setIsScrollAllowed(value, 'all', 'm');\n      }\n    }\n\n    /**\n    * Scrolls to the anchor in the URL when loading the site\n    */\n\n    function scrollToAnchor() {\n      var anchors = getAnchorsURL();\n      var sectionAnchor = anchors.section;\n      var slideAnchor = anchors.slide;\n\n      if (sectionAnchor) {\n        //if theres any #\n        if (getOptions().animateAnchor) {\n          scrollPageAndSlide(sectionAnchor, slideAnchor);\n        } else {\n          silentMoveTo(sectionAnchor, slideAnchor);\n        }\n      } else {\n        EventEmitter.emit(events.onAfterRenderNoAnchor, null);\n      }\n    }\n\n    /*\n    * Removes inline styles added by fullpage.js\n    */\n\n    function destroyStructure() {\n      //reseting the `top` or `translate` properties to 0\n      silentScroll(0); //loading all the lazy load content\n\n      $('img[data-src], source[data-src], audio[data-src], iframe[data-src]', getContainer()).forEach(function (item) {\n        setSrc(item, 'src');\n      });\n      $('img[data-srcset]').forEach(function (item) {\n        setSrc(item, 'srcset');\n      });\n      remove($(SECTION_NAV_SEL + ', ' + SLIDES_NAV_SEL + ', ' + SLIDES_ARROW_SEL + ', ' + WATERMARK_SEL)); //removing inline styles\n\n      css(getNodes(getState().sections), {\n        'height': '',\n        'background-color': '',\n        'padding': ''\n      });\n      css(getNodes(getState().slides), {\n        'width': ''\n      });\n      css(getContainer(), {\n        'height': '',\n        'position': '',\n        '-ms-touch-action': '',\n        'touch-action': ''\n      });\n      css($htmlBody, {\n        'overflow': '',\n        'height': ''\n      }); // remove .fp-enabled class\n\n      removeClass($html, ENABLED); // remove .fp-responsive class & .fp-scrollable\n\n      removeClass($body, RESPONSIVE + ' ' + SCROLLABLE); // remove all of the .fp-viewing- classes\n\n      $body.className.split(/\\s+/).forEach(function (className) {\n        if (className.indexOf(VIEWING_PREFIX) === 0) {\n          removeClass($body, className);\n        }\n      }); //removing added classes\n\n      getNodes(getState().panels).forEach(function (item) {\n        if (getOptions().scrollOverflow) {\n          scrollOverflowHandler.destroyWrapper(item);\n        }\n\n        removeClass(item, TABLE + ' ' + ACTIVE + ' ' + COMPLETELY + ' ' + IS_OVERFLOW + ' ' + LOADED);\n        var previousStyles = getAttr(item, 'data-fp-styles');\n\n        if (previousStyles) {\n          item.setAttribute('style', previousStyles);\n        } //removing anchors if they were not set using the HTML markup\n\n\n        if (hasClass(item, SECTION) && !getInitialAnchorsInDom()) {\n          item.removeAttribute('data-anchor');\n        }\n      }); //removing the applied transition from the fullpage wrapper\n\n      removeAnimation(getContainer()); //Unwrapping content\n\n      [TABLE_CELL_SEL, SLIDES_CONTAINER_SEL, SLIDES_WRAPPER_SEL].forEach(function (selector) {\n        $(selector, getContainer()).forEach(function (item) {\n          //unwrap not being use in case there's no child element inside and its just text\n          unwrap(item);\n        });\n      }); //removing the applied transition from the fullpage wrapper\n\n      css(getContainer(), {\n        '-webkit-transition': 'none',\n        'transition': 'none'\n      });\n      removeClass(getContainer(), WRAPPER); //scrolling the page to the top with no animation\n\n      win.scrollTo(0, 0); //removing selectors\n\n      var usedSelectors = [SECTION, SLIDE, SLIDES_CONTAINER];\n      usedSelectors.forEach(function (item) {\n        removeClass($('.' + item), item);\n      });\n      resetState();\n      EventEmitter.emit(events.onDestroyAll);\n    }\n\n    FP.destroy = destroy;\n    function init() {\n      updateStructuralState();\n      updateState();\n      getOptions().scrollBar = getOptions().scrollBar || getOptions().hybrid;\n      setOptionsFromDOM();\n      prepareDom();\n      setAllowScrolling(true);\n      setMouseHijack(true);\n      setAutoScrolling(getOptions().autoScrolling, 'internal');\n      responsive(); //setting the class for the body element\n\n      setBodyClass();\n\n      if (doc.readyState === 'complete') {\n        scrollToAnchor();\n      }\n\n      windowAddEvent('load', scrollToAnchor);\n      afterRenderActions(); // Updating the state again with the new DOM\n\n      updateStructuralState();\n      updateState();\n    }\n    /*\n    * Destroys fullpage.js plugin events and optinally its html markup and styles\n    */\n\n    function destroy(all) {\n      setAutoScrolling(false, 'internal');\n      setAllowScrolling(true);\n      setMouseHijack(false);\n      setKeyboardScrolling(false);\n      addClass(getContainer(), DESTROYED);\n      EventEmitter.emit(events.onDestroy); //lets make a mess!\n\n      if (all) {\n        destroyStructure();\n      }\n    }\n\n    var isOK = function isOK() {\n      return getOptions() && state.isValid || doc.domain.indexOf('al' + 'varotri' + 'go' + '.' + 'com') > -1;\n    };\n    /**\n    * Displays warnings\n    */\n\n\n    function displayWarnings() {\n      var l = getOptions()['li' + 'c' + 'enseK' + 'e' + 'y'];\n      var msgStyle = 'font-size: 15px;background:yellow;';\n\n      if (getOptions().licenseKey.trim() === '') {\n        showError('error', 'Fullpage.js requires a `licenseKey` option. Read about it on the following website:');\n        showError('error', 'https://alvarotrigo.com/fullPage/docs/#licensekey');\n      } else if (!isOK()) {\n        showError('error', 'Incorrect `licenseKey`. Get one for fullPage.js version 4 here:');\n        showError('error', 'https://alvarotrigo.com/fullPage/pricing');\n      } else if (l && l.length < 20) {\n        console.warn('%c This website was made using fullPage.js slider. Learn more on the following website:', msgStyle);\n        console.warn('%c https://alvarotrigo.com/fullPage/', msgStyle);\n      }\n\n      if (hasClass($html, ENABLED)) {\n        showError('error', 'Fullpage.js can only be initialized once and you are doing it multiple times!');\n        return;\n      } // Disable mutually exclusive settings\n\n\n      if (getOptions().continuousVertical && (getOptions().loopTop || getOptions().loopBottom)) {\n        getOptions().continuousVertical = false;\n        showError('warn', 'Option `loopTop/loopBottom` is mutually exclusive with `continuousVertical`; `continuousVertical` disabled');\n      }\n\n      if (getOptions().scrollOverflow && (getOptions().scrollBar || !getOptions().autoScrolling)) {\n        showError('warn', 'Options scrollBar:true and autoScrolling:false are mutually exclusive with scrollOverflow:true. Sections with scrollOverflow might not work well in Firefox');\n      }\n\n      if (getOptions().continuousVertical && (getOptions().scrollBar || !getOptions().autoScrolling)) {\n        getOptions().continuousVertical = false;\n        showError('warn', 'Scroll bars (`scrollBar:true` or `autoScrolling:false`) are mutually exclusive with `continuousVertical`; `continuousVertical` disabled');\n      } //using extensions? Wrong file!\n\n\n      extensions.forEach(function (extension) {\n        //is the option set to true?\n        if (getOptions()[extension]) {\n          showError('warn', 'fullpage.js extensions require fullpage.extensions.min.js file instead of the usual fullpage.js. Requested: ' + extension);\n        }\n      }); //anchors can not have the same value as any element ID or NAME\n\n      getOptions().anchors.forEach(function (name) {\n        //case insensitive selectors (http://stackoverflow.com/a/19465187/1081396)\n        var nameAttr = [].slice.call($('[name]')).filter(function (item) {\n          return getAttr(item, 'name') && getAttr(item, 'name').toLowerCase() == name.toLowerCase();\n        });\n        var idAttr = [].slice.call($('[id]')).filter(function (item) {\n          return getAttr(item, 'id') && getAttr(item, 'id').toLowerCase() == name.toLowerCase();\n        });\n\n        if (idAttr.length || nameAttr.length) {\n          showError('error', 'data-anchor tags can not have the same value as any `id` element on the site (or `name` element for IE).');\n          var propertyName = idAttr.length ? 'id' : 'name';\n\n          if (idAttr.length || nameAttr.length) {\n            showError('error', '\"' + name + '\" is is being used by another element `' + propertyName + '` property');\n          }\n        }\n      });\n    }\n\n    function fullpage(containerSelector, options) {\n      setCache(); //only once my friend!\n\n      if (hasClass($html, ENABLED)) {\n        displayWarnings();\n        return;\n      }\n\n      setOption('touchWrapper', typeof containerSelector === 'string' ? $(containerSelector)[0] : containerSelector); // Creating some defaults, extending them with any options that were provided\n\n      setOptions(options);\n      setContainer(typeof containerSelector === 'string' ? $(containerSelector)[0] : containerSelector);\n      EventEmitter.emit(events.onInitialise);\n      displayWarnings();\n      setAPI();\n\n      if (getContainer()) {\n        EventEmitter.emit(events.beforeInit);\n        init();\n        EventEmitter.emit(events.bindEvents);\n      }\n\n      setState({\n        isFullpageInitDone: true\n      }); // @ts-ignore\n\n      return win.fullpage_api;\n    }\n\n    function setAPI() {\n      FP.getFullpageData = function () {\n        return {\n          options: getOptions()\n        };\n      }; //public functions\n\n\n      FP.version = '4.0.37';\n      FP.test = Object.assign(FP.test, {\n        top: '0px',\n        translate3d: 'translate3d(0px, 0px, 0px)',\n        translate3dH: function () {\n          var a = [];\n\n          for (var i = 0; i < $(getOptions().sectionSelector, getContainer()).length; i++) {\n            a.push('translate3d(0px, 0px, 0px)');\n          }\n\n          return a;\n        }(),\n        left: function () {\n          var a = [];\n\n          for (var i = 0; i < $(getOptions().sectionSelector, getContainer()).length; i++) {\n            a.push(0);\n          }\n\n          return a;\n        }(),\n        options: getOptions(),\n        setAutoScrolling: null\n      }); //functions we want to share across files but which are not\n      //mean to be used on their own by developers\n\n      FP.shared = Object.assign(FP.shared, {\n        afterRenderActions: null,\n        isNormalScrollElement: false\n      }); // @ts-ignore\n\n      win.fullpage_api = FP;\n    }\n\n    // @ts-ignore\n\n    win.fp_easings = deepExtend(win.fp_easings, {\n      easeInOutCubic: function easeInOutCubic(t, b, c, d) {\n        if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;\n        return c / 2 * ((t -= 2) * t * t + 2) + b;\n      }\n    });\n\n    /**\n     * jQuery adapter for fullPage.js 3.0.0\n     */\n    // @ts-ignore\n\n    if (win.jQuery) {\n      (function ($, fullpage) {\n\n        if (!$ || !fullpage) {\n          showError('error', 'jQuery is required to use the jQuery fullpage adapter!');\n          return;\n        }\n\n        $.fn.fullpage = function (options) {\n          options = $.extend({}, options, {\n            '$': $\n          });\n          new fullpage(this[0], options); // Creating the $.fn.fullpage object\n\n          Object.keys(FP).forEach(function (key) {\n            getOptions().$.fn.fullpage[key] = FP[key];\n          });\n        }; // @ts-ignore\n\n      })(win.jQuery, fullpage);\n    }\n\n    return fullpage;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mdWxscGFnZS5qcy9kaXN0L2Z1bGxwYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQ3VHO0FBQzNHLENBQUMsdUJBQXVCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEMsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsWUFBWSxpREFBaUQ7OztBQUc3RCxzQ0FBc0M7O0FBRXRDLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjOzs7QUFHZDtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4Qix5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFvRDs7O0FBR2xFO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQSx1RUFBdUU7O0FBRXZFLHFCQUFxQjs7QUFFckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxZQUFZOzs7QUFHWiwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHFPQUFxTzs7QUFF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QUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5COztBQUVBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLCtGQUErRixhQUFhO0FBQzVHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRkFBaUYsZUFBZTtBQUNoRztBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRkFBZ0Y7O0FBRWhGLHVEQUF1RDs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxR0FBcUc7QUFDckc7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU8sT0FBTzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGOztBQUV0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0EsWUFBWTs7O0FBR1osNkNBQTZDOzs7QUFHN0M7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtB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QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEUsMkRBQTJEOztBQUUzRCx5RUFBeUU7QUFDekUsUUFBUTtBQUNSO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBLFVBQVU7OztBQUdWLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHOztBQUVoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0Msc0ZBQXNGOztBQUV0RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7O0FBRXRFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBLHVDQUF1QztBQUN2QyxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQixvQkFBb0I7O0FBRXBCO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7O0FBRVo7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQyw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRzs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGLHVTQUF1UyxZQUFZO0FBQ25UO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gseUZBQXlGLEdBQUc7QUFDNUYsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOENBQThDOztBQUU5QztBQUNBLHlEQUF5RDs7QUFFekQsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBLDZDQUE2Qzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCwyR0FBMkc7O0FBRTNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVYsbUNBQW1DOztBQUVuQyx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVix1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU8sR0FBRzs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNENBQTRDOztBQUU1QywwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxSUFBcUk7QUFDckksUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNIQUFzSDs7QUFFdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiw0REFBNEQ7QUFDdEY7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLDBCQUEwQiw0REFBNEQ7QUFDdEY7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLFdBQVc7QUFDWCwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVzs7QUFFWCxPQUFPO0FBQ1A7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pblxcRGVza3RvcFxcQXJ0IHdlYnNpdGVcXG5vZGVfbW9kdWxlc1xcZnVsbHBhZ2UuanNcXGRpc3RcXGZ1bGxwYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuKiBmdWxsUGFnZSA0LjAuMzdcbiogaHR0cHM6Ly9naXRodWIuY29tL2FsdmFyb3RyaWdvL2Z1bGxQYWdlLmpzXG4qXG4qIEBsaWNlbnNlIEdQTHYzIGZvciBvcGVuIHNvdXJjZSB1c2Ugb25seVxuKiBvciBGdWxscGFnZSBDb21tZXJjaWFsIExpY2Vuc2UgZm9yIGNvbW1lcmNpYWwgdXNlXG4qIGh0dHA6Ly9hbHZhcm90cmlnby5jb20vZnVsbFBhZ2UvcHJpY2luZy9cbipcbiogQ29weXJpZ2h0IChDKSAyMDE4IGh0dHA6Ly9hbHZhcm90cmlnby5jb20vZnVsbFBhZ2UgLSBBIHByb2plY3QgYnkgQWx2YXJvIFRyaWdvXG4qL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5mdWxscGFnZSA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICAgIGlmICghQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdmaW5kJywge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocHJlZGljYXRlKSB7XG4gICAgICAgICAgLy8gMS4gTGV0IE8gYmUgPyBUb09iamVjdCh0aGlzIHZhbHVlKS5cbiAgICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG8gPSBPYmplY3QodGhpcyk7IC8vIDIuIExldCBsZW4gYmUgPyBUb0xlbmd0aCg/IEdldChPLCBcImxlbmd0aFwiKSkuXG5cbiAgICAgICAgICB2YXIgbGVuID0gby5sZW5ndGggPj4+IDA7IC8vIDMuIElmIElzQ2FsbGFibGUocHJlZGljYXRlKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICB9IC8vIDQuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cblxuXG4gICAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07IC8vIDUuIExldCBrIGJlIDAuXG5cbiAgICAgICAgICB2YXIgayA9IDA7IC8vIDYuIFJlcGVhdCwgd2hpbGUgayA8IGxlblxuXG4gICAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIC8vIGEuIExldCBQayBiZSAhIFRvU3RyaW5nKGspLlxuICAgICAgICAgICAgLy8gYi4gTGV0IGtWYWx1ZSBiZSA/IEdldChPLCBQaykuXG4gICAgICAgICAgICAvLyBjLiBMZXQgdGVzdFJlc3VsdCBiZSBUb0Jvb2xlYW4oPyBDYWxsKHByZWRpY2F0ZSwgVCwgwqsga1ZhbHVlLCBrLCBPIMK7KSkuXG4gICAgICAgICAgICAvLyBkLiBJZiB0ZXN0UmVzdWx0IGlzIHRydWUsIHJldHVybiBrVmFsdWUuXG4gICAgICAgICAgICB2YXIga1ZhbHVlID0gb1trXTtcblxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIGtWYWx1ZSwgaywgbykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGtWYWx1ZTtcbiAgICAgICAgICAgIH0gLy8gZS4gSW5jcmVhc2UgayBieSAxLlxuXG5cbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgICB9IC8vIDcuIFJldHVybiB1bmRlZmluZWQuXG5cblxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFByb2R1Y3Rpb24gc3RlcHMgb2YgRUNNQS0yNjIsIEVkaXRpb24gNiwgMjIuMS4yLjFcbiAgICBpZiAoIUFycmF5LmZyb20pIHtcbiAgICAgIEFycmF5LmZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAgICAgdmFyIGlzQ2FsbGFibGUgPSBmdW5jdGlvbiBpc0NhbGxhYmxlKGZuKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKGZuKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9JbnRlZ2VyID0gZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG51bWJlciA9IE51bWJlcih2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG51bWJlciA9PT0gMCB8fCAhaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKG51bWJlciA+IDAgPyAxIDogLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhudW1iZXIpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4gICAgICAgIHZhciB0b0xlbmd0aCA9IGZ1bmN0aW9uIHRvTGVuZ3RoKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGxlbiA9IHRvSW50ZWdlcih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGxlbiwgMCksIG1heFNhZmVJbnRlZ2VyKTtcbiAgICAgICAgfTsgLy8gVGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiB0aGUgZnJvbSBtZXRob2QgaXMgMS5cblxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZVxuICAgICAgICAvKiwgbWFwRm4sIHRoaXNBcmcgKi9cbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gMS4gTGV0IEMgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgdmFyIEMgPSB0aGlzOyAvLyAyLiBMZXQgaXRlbXMgYmUgVG9PYmplY3QoYXJyYXlMaWtlKS5cblxuICAgICAgICAgIHZhciBpdGVtcyA9IE9iamVjdChhcnJheUxpa2UpOyAvLyAzLiBSZXR1cm5JZkFicnVwdChpdGVtcykuXG5cbiAgICAgICAgICBpZiAoYXJyYXlMaWtlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LmZyb20gcmVxdWlyZXMgYW4gYXJyYXktbGlrZSBvYmplY3QgLSBub3QgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICB9IC8vIDQuIElmIG1hcGZuIGlzIHVuZGVmaW5lZCwgdGhlbiBsZXQgbWFwcGluZyBiZSBmYWxzZS5cblxuXG4gICAgICAgICAgdmFyIG1hcEZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB2b2lkIHVuZGVmaW5lZDtcbiAgICAgICAgICB2YXIgVDtcblxuICAgICAgICAgIGlmICh0eXBlb2YgbWFwRm4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyA1LiBlbHNlXG4gICAgICAgICAgICAvLyA1LiBhIElmIElzQ2FsbGFibGUobWFwZm4pIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgICBpZiAoIWlzQ2FsbGFibGUobWFwRm4pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FycmF5LmZyb206IHdoZW4gcHJvdmlkZWQsIHRoZSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9IC8vIDUuIGIuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cblxuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgVCA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIDEwLiBMZXQgbGVuVmFsdWUgYmUgR2V0KGl0ZW1zLCBcImxlbmd0aFwiKS5cbiAgICAgICAgICAvLyAxMS4gTGV0IGxlbiBiZSBUb0xlbmd0aChsZW5WYWx1ZSkuXG5cblxuICAgICAgICAgIHZhciBsZW4gPSB0b0xlbmd0aChpdGVtcy5sZW5ndGgpOyAvLyAxMy4gSWYgSXNDb25zdHJ1Y3RvcihDKSBpcyB0cnVlLCB0aGVuXG4gICAgICAgICAgLy8gMTMuIGEuIExldCBBIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAvLyBvZiBDIHdpdGggYW4gYXJndW1lbnQgbGlzdCBjb250YWluaW5nIHRoZSBzaW5nbGUgaXRlbSBsZW4uXG4gICAgICAgICAgLy8gMTQuIGEuIEVsc2UsIExldCBBIGJlIEFycmF5Q3JlYXRlKGxlbikuXG5cbiAgICAgICAgICB2YXIgQSA9IGlzQ2FsbGFibGUoQykgPyBPYmplY3QobmV3IEMobGVuKSkgOiBuZXcgQXJyYXkobGVuKTsgLy8gMTYuIExldCBrIGJlIDAuXG5cbiAgICAgICAgICB2YXIgayA9IDA7IC8vIDE3LiBSZXBlYXQsIHdoaWxlIGsgPCBsZW7igKYgKGFsc28gc3RlcHMgYSAtIGgpXG5cbiAgICAgICAgICB2YXIga1ZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIGtWYWx1ZSA9IGl0ZW1zW2tdO1xuXG4gICAgICAgICAgICBpZiAobWFwRm4pIHtcbiAgICAgICAgICAgICAgQVtrXSA9IHR5cGVvZiBUID09PSAndW5kZWZpbmVkJyA/IG1hcEZuKGtWYWx1ZSwgaykgOiBtYXBGbi5jYWxsKFQsIGtWYWx1ZSwgayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBBW2tdID0ga1ZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrICs9IDE7XG4gICAgICAgICAgfSAvLyAxOC4gTGV0IHB1dFN0YXR1cyBiZSBQdXQoQSwgXCJsZW5ndGhcIiwgbGVuLCB0cnVlKS5cblxuXG4gICAgICAgICAgQS5sZW5ndGggPSBsZW47IC8vIDIwLiBSZXR1cm4gQS5cblxuICAgICAgICAgIHJldHVybiBBO1xuICAgICAgICB9O1xuICAgICAgfSgpO1xuICAgIH1cblxuICAgIHZhciB3aW4gPSB3aW5kb3c7XG4gICAgdmFyIGRvYyA9IGRvY3VtZW50O1xuICAgIHZhciBpc1RvdWNoRGV2aWNlID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKGlQaG9uZXxpUG9kfGlQYWR8QW5kcm9pZHxwbGF5Ym9va3xzaWxrfEJsYWNrQmVycnl8QkIxMHxXaW5kb3dzIFBob25lfFRpemVufEJhZGF8d2ViT1N8SUVNb2JpbGV8T3BlcmEgTWluaSkvKSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTWFjXCIpICYmIFwib250b3VjaGVuZFwiIGluIGRvY3VtZW50OyAvLyBpUGFkIG9uIGlPUyAxMyBkZXRlY3Rpb25cblxuICAgIHZhciBpc01hY0RldmljZSA9IC8oTWFjfGlQaG9uZXxpUG9kfGlQYWQpL2kudGVzdCh3aW4ubmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIEB0cy1pZ25vcmVcblxuICAgIHZhciBpc1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luIHx8IG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM7XG4gICAgdmFyIGlzSUUxMSA9ICEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlOyAvLyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS91ZGFjaXR5L3VkODkxL2Jsb2IvZ2gtcGFnZXMvbGVzc29uMi1mb2N1cy8wNy1tb2RhbHMtYW5kLWtleWJvYXJkLXRyYXBzL3NvbHV0aW9uL21vZGFsLmpzXG5cbiAgICB2YXIgZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcgPSAnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgW3RhYmluZGV4PVwiMFwiXSwgc3VtbWFyeTpub3QoW2Rpc2FibGVkXSksIFtjb250ZW50ZWRpdGFibGVdJzsgLy8gY2FjaGUgY29tbW9uIGVsZW1lbnRzXG5cbiAgICB2YXIgRlAgPSB7XG4gICAgICB0ZXN0OiB7fSxcbiAgICAgIHNoYXJlZDoge31cbiAgICB9O1xuICAgIHZhciBleHRlbnNpb25zID0gWydwYXJhbGxheCcsICdzY3JvbGxPdmVyZmxvd1Jlc2V0JywgJ2RyYWdBbmRNb3ZlJywgJ29mZnNldFNlY3Rpb25zJywgJ2ZhZGluZ0VmZmVjdCcsICdyZXNwb25zaXZlU2xpZGVzJywgJ2NvbnRpbnVvdXNIb3Jpem9udGFsJywgJ2ludGVybG9ja2VkU2xpZGVzJywgJ3Njcm9sbEhvcml6b250YWxseScsICdyZXNldFNsaWRlcnMnLCAnY2FyZHMnLCAnZHJvcEVmZmVjdCcsICd3YXRlckVmZmVjdCddO1xuICAgIHZhciBpc0luc2lkZUlmcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbklmcmFtZSA9IHdpbmRvdy5zZWxmICE9PSB3aW5kb3cudG9wO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluSWZyYW1lO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAqIGZvckVhY2ggcG9seWZpbGwgZm9yIElFXG4gICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZUxpc3QvZm9yRWFjaCNCcm93c2VyX0NvbXBhdGliaWxpdHlcbiAgICAqL1xuXG4gICAgaWYgKHdpbi5Ob2RlTGlzdCAmJiAhTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICAgIE5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXNBcmcgPSB0aGlzQXJnIHx8IHdpbmRvdztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXNbaV0sIGksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBNdXN0IGJlIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgdmFyQXJncykge1xuXG4gICAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgYnVncyB3aGVuIGhhc093blByb3BlcnR5IGlzIHNoYWRvd2VkXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0U291cmNlLCBuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTE3MTk1NTMvcGFkc3RhcnQtbm90LXdvcmtpbmctaW4taWUxMVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZWhuYW1tb2RpL3BvbHlmaWxsL2Jsb2IvbWFzdGVyL3N0cmluZy5wb2x5ZmlsbC5qc1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9wYWRTdGFydFxuICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydCkge1xuICAgICAgU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydCA9IGZ1bmN0aW9uIHBhZFN0YXJ0KHRhcmdldExlbmd0aCwgcGFkU3RyaW5nKSB7XG4gICAgICAgIHRhcmdldExlbmd0aCA9IHRhcmdldExlbmd0aCA+PiAwOyAvL3RydW5jYXRlIGlmIG51bWJlciBvciBjb252ZXJ0IG5vbi1udW1iZXIgdG8gMDtcblxuICAgICAgICBwYWRTdHJpbmcgPSBTdHJpbmcodHlwZW9mIHBhZFN0cmluZyAhPT0gJ3VuZGVmaW5lZCcgPyBwYWRTdHJpbmcgOiAnICcpO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IHRhcmdldExlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TGVuZ3RoIC0gdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0TGVuZ3RoID4gcGFkU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFkU3RyaW5nICs9IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KHRhcmdldExlbmd0aCkpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYWRTdHJpbmc7XG4gICAgICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwYWRTdHJpbmcuc2xpY2UoMCwgdGFyZ2V0TGVuZ3RoKSArIFN0cmluZyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvL3V0aWxzXG4gICAgLyoqXG4gICAgKiBTaG93cyBhIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNob3dFcnJvcih0eXBlLCB0ZXh0KSB7XG4gICAgICB3aW4uY29uc29sZSAmJiB3aW4uY29uc29sZVt0eXBlXSAmJiB3aW4uY29uc29sZVt0eXBlXSgnZnVsbFBhZ2U6ICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWaXNpYmxlKGVsKSB7XG4gICAgICB2YXIgc3R5bGUgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICByZXR1cm4gc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWaXNpYmxlKGVsZW1lbnRzKSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBpc1Zpc2libGUoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBFcXVpdmFsZW50IG9mIGpRdWVyeSBmdW5jdGlvbiAkKCkuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uICQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGNvbnRleHQgOiBkb2N1bWVudDtcbiAgICAgIHJldHVybiBjb250ZXh0ID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICogRXh0ZW5kcyBhIGdpdmVuIE9iamVjdCBwcm9wZXJ0aWVzIGFuZCBpdHMgY2hpbGRzLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBkZWVwRXh0ZW5kKG91dCkge1xuICAgICAgb3V0ID0gb3V0IHx8IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IGtleSA9PSAnX19wcm90b19fJyB8fCBrZXkgPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBiYXNlZCBvbiBodHRwczovL2phdmFzY3JpcHR3ZWJsb2cud29yZHByZXNzLmNvbS8yMDExLzA4LzA4L2ZpeGluZy10aGUtamF2YXNjcmlwdC10eXBlb2Ytb3BlcmF0b3IvXG5cblxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqW2tleV0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgb3V0W2tleV0gPSBkZWVwRXh0ZW5kKG91dFtrZXldLCBvYmpba2V5XSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQ2hlY2tzIGlmIHRoZSBwYXNzZWQgZWxlbWVudCBjb250YWlucyB0aGUgcGFzc2VkIGNsYXNzLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBHZXRzIHRoZSB3aW5kb3cgaGVpZ2h0LiBDcm9zc2Jyb3dzZXIuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldFdpbmRvd0hlaWdodCgpIHtcbiAgICAgIHJldHVybiAnaW5uZXJIZWlnaHQnIGluIHdpbiA/IHdpbi5pbm5lckhlaWdodCA6IGRvYy5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIHdpbmRvdyB3aWR0aC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93V2lkdGgoKSB7XG4gICAgICByZXR1cm4gd2luLmlubmVyV2lkdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICogU2V0J3MgdGhlIENTUyBwcm9wZXJ0aWVzIGZvciB0aGUgcGFzc2VkIGl0ZW0vcy5cbiAgICAqIEBwYXJhbSB7Tm9kZUxpc3R8SFRNTEVsZW1lbnR8T2JqZWN0fSBpdGVtc1xuICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIGNzcyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGNzcyhpdGVtcywgcHJvcHMpIHtcbiAgICAgIGl0ZW1zID0gZ2V0TGlzdChpdGVtcyk7XG4gICAgICB2YXIga2V5O1xuXG4gICAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgaXRlbS5zdHlsZVtrZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIHByZXZpb3VzIGVsZW1lbnQgdG8gdGhlIHBhc3NlZCBlbGVtZW50LlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBwcmV2KGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICogR2V0cyB0aGUgbmV4dCBlbGVtZW50IHRvIHRoZSBwYXNzZWQgZWxlbWVudC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gbmV4dChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IGZyb20gdGhlIHBhc3NlZCBsaXN0IG9mIGVsZW1lbnRzLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBsYXN0KGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtW2l0ZW0ubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgICogR2V0cyBpbmRleCBmcm9tIHRoZSBwYXNzZWQgZWxlbWVudC5cbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBpcyBvcHRpb25hbC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gaW5kZXgoaXRlbSwgc2VsZWN0b3IpIHtcbiAgICAgIGl0ZW0gPSBpc0FycmF5T3JMaXN0KGl0ZW0pID8gaXRlbVswXSA6IGl0ZW07XG4gICAgICB2YXIgY2hpbGRyZW4gPSBzZWxlY3RvciAhPSBudWxsID8gJChzZWxlY3RvciwgaXRlbS5wYXJlbnROb2RlKSA6IGl0ZW0ucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuICAgICAgdmFyIG51bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldID09IGl0ZW0pIHJldHVybiBudW07XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS5ub2RlVHlwZSA9PSAxKSBudW0rKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgYW4gaXRlcmFibGUgZWxlbWVudCBmb3IgdGhlIHBhc3NlZCBlbGVtZW50L3NcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0TGlzdChpdGVtKSB7XG4gICAgICByZXR1cm4gIWlzQXJyYXlPckxpc3QoaXRlbSkgPyBbaXRlbV0gOiBpdGVtO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFkZHMgdGhlIGRpc3BsYXk9bm9uZSBwcm9wZXJ0eSBmb3IgdGhlIHBhc3NlZCBlbGVtZW50L3NcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gaGlkZShlbCkge1xuICAgICAgZWwgPSBnZXRMaXN0KGVsKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbFtpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICogQWRkcyB0aGUgZGlzcGxheT1ibG9jayBwcm9wZXJ0eSBmb3IgdGhlIHBhc3NlZCBlbGVtZW50L3NcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2hvdyhlbCkge1xuICAgICAgZWwgPSBnZXRMaXN0KGVsKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbFtpXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAqIENoZWNrcyBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgYW4gaXRlcmFibGUgZWxlbWVudCBvciBub3RcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gaXNBcnJheU9yTGlzdChlbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlbCkgPT09ICdbb2JqZWN0IEFycmF5XScgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsKSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBZGRzIHRoZSBwYXNzZWQgY2xhc3MgdG8gdGhlIHBhc3NlZCBlbGVtZW50L3NcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgZWwgPSBnZXRMaXN0KGVsKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IGVsW2ldO1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJlbW92ZXMgdGhlIHBhc3NlZCBjbGFzcyB0byB0aGUgcGFzc2VkIGVsZW1lbnQvc1xuICAgICogQHBhcmFtIHtTdHJpbmd9IGBjbGFzc05hbWVgIGNhbiBiZSBtdWx0aXBsZSBjbGFzc25hbWVzIHNlcGFyYXRlZCBieSB3aGl0ZXNwYWNlXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgIGVsID0gZ2V0TGlzdChlbCk7XG4gICAgICB2YXIgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXG4gICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1thXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBlbFtpXTtcbiAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gZWxlbWVudCBvdCB0aGUgZ2l2ZW4gcGFyZW50LlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBhcHBlbmRUbyhlbCwgcGFyZW50KSB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2FnZTpcblxuICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcHBlci5jbGFzc05hbWUgPSAnZnAtc2xpZGVzJztcbiAgICB3cmFwKCQoJy5zbGlkZScpLCB3cmFwcGVyKTtcblxuICAgIGh0dHBzOi8vanNmaWRkbGUubmV0L3F3emM3b3kzLzE1LyAodmFuaWxsYSlcbiAgICBodHRwczovL2pzZmlkZGxlLm5ldC9veWE2bmRrYS8xLyAoanF1ZXJ5IGVxdWl2YWxlbnQpXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHdyYXAodG9XcmFwLCB3cmFwcGVyLCBpc1dyYXBBbGwpIHtcbiAgICAgIHZhciBuZXdQYXJlbnQ7XG4gICAgICB3cmFwcGVyID0gd3JhcHBlciB8fCBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9XcmFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gdG9XcmFwW2ldO1xuXG4gICAgICAgIGlmIChpc1dyYXBBbGwgJiYgIWkgfHwgIWlzV3JhcEFsbCkge1xuICAgICAgICAgIG5ld1BhcmVudCA9IHdyYXBwZXIuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgIGl0ZW0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3UGFyZW50LCBpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld1BhcmVudC5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvV3JhcDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNhZ2U6XG4gICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB3cmFwcGVyLmNsYXNzTmFtZSA9ICdmcC1zbGlkZXMnO1xuICAgIHdyYXAoJCgnLnNsaWRlJyksIHdyYXBwZXIpO1xuXG4gICAgaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvcXd6YzdveTMvMjcvICh2YW5pbGxhKVxuICAgIGh0dHBzOi8vanNmaWRkbGUubmV0L295YTZuZGthLzQvIChqcXVlcnkgZXF1aXZhbGVudClcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gd3JhcEFsbCh0b1dyYXAsIHdyYXBwZXIpIHtcbiAgICAgIHdyYXAodG9XcmFwLCB3cmFwcGVyLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBVc2FnZTpcbiAgICAqIHdyYXBJbm5lcihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGVwZScpLCAnPGRpdiBjbGFzcz1cInRlc3RcIj5hZmRhczwvZGl2PicpO1xuICAgICogd3JhcElubmVyKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwZXBlJyksIGVsZW1lbnQpO1xuICAgICpcbiAgICAqIGh0dHBzOi8vanNmaWRkbGUubmV0L3pleHh6MHR3LzYvXG4gICAgKlxuICAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxODE3NTkwLzEwODEzOTZcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gd3JhcElubmVyKHBhcmVudCwgd3JhcHBlcikge1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuXG4gICAgICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQgIT09IHdyYXBwZXIpIHtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogVXNhZ2U6XG4gICAgKiB1bndyYXAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3BlcGUnKSk7XG4gICAgKiB1bndyYXAoZWxlbWVudCk7XG4gICAgKlxuICAgICogaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvc3pqdDBoeHEvMS9cbiAgICAqXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHVud3JhcCh3cmFwcGVyKSB7XG4gICAgICB2YXIgd3JhcHBlckNvbnRlbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgIHdyYXBwZXJDb250ZW50LmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlckNvbnRlbnQsIHdyYXBwZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjIxMDA4NTMvZG9tLXB1cmUtamF2YXNjcmlwdC1zb2x1dGlvbi10by1qcXVlcnktY2xvc2VzdC1pbXBsZW1lbnRhdGlvblxuICAgICogUmV0dXJucyB0aGUgZWxlbWVudCBvciBgZmFsc2VgIGlmIHRoZXJlJ3Mgbm9uZVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBjbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xuICAgICAgaWYgKGVsICYmIGVsLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIGlmIChtYXRjaGVzKGVsLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvc2VzdChlbC5wYXJlbnROb2RlLCBzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFBsYWNlcyBvbmUgZWxlbWVudCAocmVsKSBhZnRlciBhbm90aGVyIG9uZSBvciBncm91cCBvZiB0aGVtIChyZWZlcmVuY2UpLlxuICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fE5vZGVMaXN0fFN0cmluZ3xBcnJheX0gZWxcbiAgICAqIGh0dHBzOi8vanNmaWRkbGUubmV0LzlzOTdoaHp2LzEvXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGFmdGVyKHJlZmVyZW5jZSwgZWwpIHtcbiAgICAgIGluc2VydEJlZm9yZShyZWZlcmVuY2UsIHJlZmVyZW5jZS5uZXh0U2libGluZywgZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFBsYWNlcyBvbmUgZWxlbWVudCAocmVsKSBiZWZvcmUgYW5vdGhlciBvbmUgb3IgZ3JvdXAgb2YgdGhlbSAocmVmZXJlbmNlKS5cbiAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxOb2RlTGlzdHxTdHJpbmd8QXJyYXl9IGVsXG4gICAgKiBodHRwczovL2pzZmlkZGxlLm5ldC85czk3aGh6di8xL1xuICAgICovXG5cbiAgICBmdW5jdGlvbiBiZWZvcmUocmVmZXJlbmNlLCBlbCkge1xuICAgICAgaW5zZXJ0QmVmb3JlKHJlZmVyZW5jZSwgcmVmZXJlbmNlLCBlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQmFzZWQgaW4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5MzE2MDI0LzEwODEzOTZcbiAgICAqIGFuZCBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDc5MzYzMC8xMDgxMzk2XG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGluc2VydEJlZm9yZShyZWZlcmVuY2UsIGJlZm9yZUVsZW1lbnQsIGVsKSB7XG4gICAgICBpZiAoIWlzQXJyYXlPckxpc3QoZWwpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBlbCA9IGNyZWF0ZUVsZW1lbnRGcm9tSFRNTChlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbCA9IFtlbF07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVmZXJlbmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsW2ldLCBiZWZvcmVFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9IC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNDY0ODc2L2phdmFzY3JpcHQtZ2V0LXdpbmRvdy14LXktcG9zaXRpb24tZm9yLXNjcm9sbFxuXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKCkge1xuICAgICAgdmFyIGRvY0VsZW1lbnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgcmV0dXJuICh3aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbWVudC5zY3JvbGxUb3ApIC0gKGRvY0VsZW1lbnQuY2xpZW50VG9wIHx8IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBwYXNzZWQgZWxlbWVudFxuICAgICovXG5cbiAgICBmdW5jdGlvbiBzaWJsaW5ncyhlbCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChlbC5wYXJlbnROb2RlLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkICE9PSBlbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QXR0cihlbCwgYXR0cikge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG9jQWRkRXZlbnQoZXZlbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG9wdGlvbnMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3aW5kb3dBZGRFdmVudChldmVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogb3B0aW9ucyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvY1JlbW92ZUV2ZW50KGV2ZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCBvcHRpb25zID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBvcHRpb25zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2luZG93UmVtb3ZlRXZlbnQoZXZlbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGFzc2VkIGl0ZW0gaXMgb2YgZnVuY3Rpb24gdHlwZS5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUcmlnZ2VyIGN1c3RvbSBldmVudHNcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gdHJpZ2dlcihlbCwgZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICB2YXIgZXZlbnQ7XG4gICAgICBkYXRhID0gdHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8ge30gOiBkYXRhOyAvLyBOYXRpdmVcblxuICAgICAgaWYgKHR5cGVvZiB3aW4uQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHtcbiAgICAgICAgICBkZXRhaWw6IGRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudCA9IGRvYy5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFBvbHlmaWxsIG9mIC5tYXRjaGVzKClcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiAoZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3IgfHwgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbC5vTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGVsLCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgcGFzc2VkIGVsZW1lbnQgZWwuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZShlbCwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbFtpXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgICB9XG4gICAgICB9IC8vd2UgZG9uJ3QgdXNlIGl0IGluIG90aGVyIHdheSwgc28gbm8gZWxzZSA6KVxuXG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgSFRNTEVsZW1lbnQgZnJvbSB0aGUgcGFzc2VkIEhUTUwgc3RyaW5nLlxuICAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ5NDM0OC8xMDgxMzk2XG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRGcm9tSFRNTChodG1sU3RyaW5nKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LmlubmVySFRNTCA9IGh0bWxTdHJpbmcudHJpbSgpOyAvLyBDaGFuZ2UgdGhpcyB0byBkaXYuY2hpbGROb2RlcyB0byBzdXBwb3J0IG11bHRpcGxlIHRvcC1sZXZlbCBub2Rlc1xuXG4gICAgICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmVtb3ZlcyB0aGUgcGFzc2VkIGl0ZW0vcyBmcm9tIHRoZSBET00uXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHJlbW92ZShpdGVtcykge1xuICAgICAgaXRlbXMgPSBnZXRMaXN0KGl0ZW1zKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIGl0ZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy9odHRwczovL2pzZmlkZGxlLm5ldC93MXJrdGVjei9cblxuICAgIGZ1bmN0aW9uIHVudGlsQWxsKGl0ZW0sIHNlbGVjdG9yLCBmbikge1xuICAgICAgdmFyIHNpYmxpbmcgPSBpdGVtW2ZuXTtcbiAgICAgIHZhciBzaWJsaW5ncyA9IFtdO1xuXG4gICAgICB3aGlsZSAoc2libGluZykge1xuICAgICAgICBpZiAobWF0Y2hlcyhzaWJsaW5nLCBzZWxlY3RvcikgfHwgc2VsZWN0b3IgPT0gbnVsbCkge1xuICAgICAgICAgIHNpYmxpbmdzLnB1c2goc2libGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzaWJsaW5nID0gc2libGluZ1tmbl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBHZXRzIGFsbCBuZXh0IGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBwYXNzZWQgc2VsZWN0b3IuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIG5leHRBbGwoaXRlbSwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB1bnRpbEFsbChpdGVtLCBzZWxlY3RvciwgJ25leHRFbGVtZW50U2libGluZycpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgYWxsIHByZXZpb3VzIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBwYXNzZWQgc2VsZWN0b3IuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHByZXZBbGwoaXRlbSwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB1bnRpbEFsbChpdGVtLCBzZWxlY3RvciwgJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgdG8gYW4gYXJyYXkuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkob2JqZWN0RGF0YSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdERhdGEpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBvYmplY3REYXRhW2tleV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TGFzdChpdGVtcykge1xuICAgICAgcmV0dXJuIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIGF2ZXJhZ2Ugb2YgdGhlIGxhc3QgYG51bWJlcmAgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5LlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBnZXRBdmVyYWdlKGVsZW1lbnRzLCBudW1iZXIpIHtcbiAgICAgIHZhciBzdW0gPSAwOyAvL3Rha2luZyBgbnVtYmVyYCBlbGVtZW50cyBmcm9tIHRoZSBlbmQgdG8gbWFrZSB0aGUgYXZlcmFnZSwgaWYgdGhlcmUgYXJlIG5vdCBlbm91Z2h0LCAxXG5cbiAgICAgIHZhciBsYXN0RWxlbWVudHMgPSBlbGVtZW50cy5zbGljZShNYXRoLm1heChlbGVtZW50cy5sZW5ndGggLSBudW1iZXIsIDEpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtID0gc3VtICsgbGFzdEVsZW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHN1bSAvIG51bWJlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICogU2V0cyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBhdHRyaWJ1dGUgZnJvbSB0aGUgYGRhdGEtYCBhdHRyaWJ1dGUgd2l0aCB0aGUgc2FtZSBzdWZmaXhcbiAgICAqIGllOiBkYXRhLXNyY3NldCA9PT4gc3Jjc2V0ICB8ICBkYXRhLXNyYyA9PT4gc3JjXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNldFNyYyhlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgZ2V0QXR0cihlbGVtZW50LCAnZGF0YS0nICsgYXR0cmlidXRlKSk7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS0nICsgYXR0cmlidXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UGFyZW50c1VudGlsKGl0ZW0sIHRvcFBhcmVudFNlbGVjdG9yKSB7XG4gICAgICB2YXIgcGFyZW50cyA9IFtpdGVtXTtcblxuICAgICAgZG8ge1xuICAgICAgICBpdGVtID0gaXRlbS5wYXJlbnROb2RlO1xuICAgICAgICBwYXJlbnRzLnB1c2goaXRlbSk7XG4gICAgICB9IHdoaWxlICghbWF0Y2hlcyhpdGVtLCB0b3BQYXJlbnRTZWxlY3RvcikpO1xuXG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNJbnNpZGVJbnB1dCgpIHtcbiAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICByZXR1cm4gbWF0Y2hlcyhhY3RpdmVFbGVtZW50LCAndGV4dGFyZWEnKSB8fCBtYXRjaGVzKGFjdGl2ZUVsZW1lbnQsICdpbnB1dCcpIHx8IG1hdGNoZXMoYWN0aXZlRWxlbWVudCwgJ3NlbGVjdCcpIHx8IGdldEF0dHIoYWN0aXZlRWxlbWVudCwgJ2NvbnRlbnRFZGl0YWJsZScpID09IFwidHJ1ZVwiIHx8IGdldEF0dHIoYWN0aXZlRWxlbWVudCwgJ2NvbnRlbnRFZGl0YWJsZScpID09ICcnO1xuICAgIH0gLy91dGlscyBhcmUgcHVibGljLCBzbyB3ZSBjYW4gdXNlIGl0IHdoZXJldmVyIHdlIHdhbnRcbiAgICAvLyBAdHMtaWdub3JlXG5cbiAgICB3aW5kb3dbXCJmcF91dGlsc1wiXSA9IHtcbiAgICAgIFwiJFwiOiAkLFxuICAgICAgXCJkZWVwRXh0ZW5kXCI6IGRlZXBFeHRlbmQsXG4gICAgICBcImhhc0NsYXNzXCI6IGhhc0NsYXNzLFxuICAgICAgXCJnZXRXaW5kb3dIZWlnaHRcIjogZ2V0V2luZG93SGVpZ2h0LFxuICAgICAgXCJjc3NcIjogY3NzLFxuICAgICAgXCJwcmV2XCI6IHByZXYsXG4gICAgICBcIm5leHRcIjogbmV4dCxcbiAgICAgIFwibGFzdFwiOiBsYXN0LFxuICAgICAgXCJpbmRleFwiOiBpbmRleCxcbiAgICAgIFwiZ2V0TGlzdFwiOiBnZXRMaXN0LFxuICAgICAgXCJoaWRlXCI6IGhpZGUsXG4gICAgICBcInNob3dcIjogc2hvdyxcbiAgICAgIFwiaXNBcnJheU9yTGlzdFwiOiBpc0FycmF5T3JMaXN0LFxuICAgICAgXCJhZGRDbGFzc1wiOiBhZGRDbGFzcyxcbiAgICAgIFwicmVtb3ZlQ2xhc3NcIjogcmVtb3ZlQ2xhc3MsXG4gICAgICBcImFwcGVuZFRvXCI6IGFwcGVuZFRvLFxuICAgICAgXCJ3cmFwXCI6IHdyYXAsXG4gICAgICBcIndyYXBBbGxcIjogd3JhcEFsbCxcbiAgICAgIFwidW53cmFwXCI6IHVud3JhcCxcbiAgICAgIFwiY2xvc2VzdFwiOiBjbG9zZXN0LFxuICAgICAgXCJhZnRlclwiOiBhZnRlcixcbiAgICAgIFwiYmVmb3JlXCI6IGJlZm9yZSxcbiAgICAgIFwiaW5zZXJ0QmVmb3JlXCI6IGluc2VydEJlZm9yZSxcbiAgICAgIFwiZ2V0U2Nyb2xsVG9wXCI6IGdldFNjcm9sbFRvcCxcbiAgICAgIFwic2libGluZ3NcIjogc2libGluZ3MsXG4gICAgICBcInByZXZlbnREZWZhdWx0XCI6IHByZXZlbnREZWZhdWx0LFxuICAgICAgXCJpc0Z1bmN0aW9uXCI6IGlzRnVuY3Rpb24sXG4gICAgICBcInRyaWdnZXJcIjogdHJpZ2dlcixcbiAgICAgIFwibWF0Y2hlc1wiOiBtYXRjaGVzLFxuICAgICAgXCJ0b2dnbGVcIjogdG9nZ2xlLFxuICAgICAgXCJjcmVhdGVFbGVtZW50RnJvbUhUTUxcIjogY3JlYXRlRWxlbWVudEZyb21IVE1MLFxuICAgICAgXCJyZW1vdmVcIjogcmVtb3ZlLFxuICAgICAgLy8gXCJmaWx0ZXJcIjogZmlsdGVyLFxuICAgICAgXCJ1bnRpbEFsbFwiOiB1bnRpbEFsbCxcbiAgICAgIFwibmV4dEFsbFwiOiBuZXh0QWxsLFxuICAgICAgXCJwcmV2QWxsXCI6IHByZXZBbGwsXG4gICAgICBcInNob3dFcnJvclwiOiBzaG93RXJyb3JcbiAgICB9O1xuXG4gICAgdmFyIHV0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIHNob3dFcnJvcjogc2hvd0Vycm9yLFxuICAgICAgICBpc1Zpc2libGU6IGlzVmlzaWJsZSxcbiAgICAgICAgZ2V0VmlzaWJsZTogZ2V0VmlzaWJsZSxcbiAgICAgICAgJDogJCxcbiAgICAgICAgZGVlcEV4dGVuZDogZGVlcEV4dGVuZCxcbiAgICAgICAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxuICAgICAgICBnZXRXaW5kb3dIZWlnaHQ6IGdldFdpbmRvd0hlaWdodCxcbiAgICAgICAgZ2V0V2luZG93V2lkdGg6IGdldFdpbmRvd1dpZHRoLFxuICAgICAgICBjc3M6IGNzcyxcbiAgICAgICAgcHJldjogcHJldixcbiAgICAgICAgbmV4dDogbmV4dCxcbiAgICAgICAgbGFzdDogbGFzdCxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBnZXRMaXN0OiBnZXRMaXN0LFxuICAgICAgICBoaWRlOiBoaWRlLFxuICAgICAgICBzaG93OiBzaG93LFxuICAgICAgICBpc0FycmF5T3JMaXN0OiBpc0FycmF5T3JMaXN0LFxuICAgICAgICBhZGRDbGFzczogYWRkQ2xhc3MsXG4gICAgICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICAgICAgYXBwZW5kVG86IGFwcGVuZFRvLFxuICAgICAgICB3cmFwOiB3cmFwLFxuICAgICAgICB3cmFwQWxsOiB3cmFwQWxsLFxuICAgICAgICB3cmFwSW5uZXI6IHdyYXBJbm5lcixcbiAgICAgICAgdW53cmFwOiB1bndyYXAsXG4gICAgICAgIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gICAgICAgIGFmdGVyOiBhZnRlcixcbiAgICAgICAgYmVmb3JlOiBiZWZvcmUsXG4gICAgICAgIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICAgICAgICBnZXRTY3JvbGxUb3A6IGdldFNjcm9sbFRvcCxcbiAgICAgICAgc2libGluZ3M6IHNpYmxpbmdzLFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogcHJldmVudERlZmF1bHQsXG4gICAgICAgIGdldEF0dHI6IGdldEF0dHIsXG4gICAgICAgIGRvY0FkZEV2ZW50OiBkb2NBZGRFdmVudCxcbiAgICAgICAgd2luZG93QWRkRXZlbnQ6IHdpbmRvd0FkZEV2ZW50LFxuICAgICAgICBkb2NSZW1vdmVFdmVudDogZG9jUmVtb3ZlRXZlbnQsXG4gICAgICAgIHdpbmRvd1JlbW92ZUV2ZW50OiB3aW5kb3dSZW1vdmVFdmVudCxcbiAgICAgICAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICAgICAgdHJpZ2dlcjogdHJpZ2dlcixcbiAgICAgICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICAgICAgdG9nZ2xlOiB0b2dnbGUsXG4gICAgICAgIGNyZWF0ZUVsZW1lbnRGcm9tSFRNTDogY3JlYXRlRWxlbWVudEZyb21IVE1MLFxuICAgICAgICByZW1vdmU6IHJlbW92ZSxcbiAgICAgICAgdW50aWxBbGw6IHVudGlsQWxsLFxuICAgICAgICBuZXh0QWxsOiBuZXh0QWxsLFxuICAgICAgICBwcmV2QWxsOiBwcmV2QWxsLFxuICAgICAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgICAgICBnZXRMYXN0OiBnZXRMYXN0LFxuICAgICAgICBnZXRBdmVyYWdlOiBnZXRBdmVyYWdlLFxuICAgICAgICBzZXRTcmM6IHNldFNyYyxcbiAgICAgICAgZ2V0UGFyZW50c1VudGlsOiBnZXRQYXJlbnRzVW50aWwsXG4gICAgICAgIGlzSW5zaWRlSW5wdXQ6IGlzSW5zaWRlSW5wdXRcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgICB9XG5cbiAgICB2YXIgRXZlbnRFbWl0dGVyID0ge1xuICAgICAgZXZlbnRzOiB7fSxcbiAgICAgIG9uOiBmdW5jdGlvbiBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAoX3R5cGVvZih0aGlzLmV2ZW50c1tldmVudF0pICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudHNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKF90eXBlb2YodGhpcy5ldmVudHNbZXZlbnRdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5ldmVudHNbZXZlbnRdLmluZGV4T2YobGlzdGVuZXIpO1xuXG4gICAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3R5cGVvZih0aGlzLmV2ZW50c1tldmVudF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KF90aGlzMiwgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICB2YXIgcmVtb3ZlID0gdGhpcy5vbihldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlbW92ZSgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXIuYXBwbHkoX3RoaXMzLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0U3RhdGUgPSB7XG4gICAgICBudW1TZWN0aW9uczogMCxcbiAgICAgIG51bVNsaWRlczogMCxcbiAgICAgIHNsaWRlczogW10sXG4gICAgICBzZWN0aW9uczogW10sXG4gICAgICBhY3RpdmVTZWN0aW9uOiBudWxsLFxuICAgICAgc2Nyb2xsVHJpZ2dlcjogbnVsbCxcbiAgICAgIGlzQmV5b25kRnVsbHBhZ2U6IGZhbHNlLFxuICAgICAgYWJvdXRUb1Njcm9sbFRvRnVsbFBhZ2U6IGZhbHNlLFxuICAgICAgc2xpZGVNb3Zpbmc6IGZhbHNlLFxuICAgICAgaXNSZXNpemluZzogZmFsc2UsXG4gICAgICBpc1Njcm9sbGluZzogZmFsc2UsXG4gICAgICBsYXN0U2Nyb2xsZWREZXN0aW55OiB1bmRlZmluZWQsXG4gICAgICBsYXN0U2Nyb2xsZWRTbGlkZTogdW5kZWZpbmVkLFxuICAgICAgYWN0aXZlQW5pbWF0aW9uOiBmYWxzZSxcbiAgICAgIGNhblNjcm9sbDogdHJ1ZSxcbiAgICAgIHRvdWNoRGlyZWN0aW9uOiAnbm9uZScsXG4gICAgICB3aGVlbERpcmVjdGlvbjogJ25vbmUnLFxuICAgICAgaXNHcmFiYmluZzogZmFsc2UsXG4gICAgICBpc1VzaW5nV2hlZWw6IGZhbHNlLFxuICAgICAgaXNXaW5kb3dGb2N1c2VkOiB0cnVlLFxuICAgICAgcHJldmlvdXNEZXN0VG9wOiAwLFxuICAgICAgd2luZG93c0hlaWdodDogZ2V0V2luZG93SGVpZ2h0KCksXG4gICAgICBpc0RvaW5nQ29udGlub3VzVmVydGljYWw6IGZhbHNlLFxuICAgICAgdGltZW91dHM6IHt9LFxuICAgICAgc2Nyb2xsWTogMCxcbiAgICAgIHNjcm9sbFg6IDAsXG4gICAgICBpc0Z1bGxwYWdlSW5pdERvbmU6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3RhdGUpOyAvLyBAdHMtaWdub3JlXG5cbiAgICB3aW4uc3RhdGUgPSBzdGF0ZTtcbiAgICBmdW5jdGlvbiBzZXRTdGF0ZShwcm9wcykge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QWN0aXZlUGFuZWwoKSB7XG4gICAgICByZXR1cm4gc3RhdGUuYWN0aXZlU2VjdGlvbiAmJiBzdGF0ZS5hY3RpdmVTZWN0aW9uLmFjdGl2ZVNsaWRlID8gc3RhdGUuYWN0aXZlU2VjdGlvbi5hY3RpdmVTbGlkZSA6IHN0YXRlLmFjdGl2ZVNlY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0U3RhdGUoKSB7XG4gICAgICBzZXRTdGF0ZShkZWZhdWx0U3RhdGUpO1xuICAgIH1cblxuICAgIHZhciBldmVudHMgPSB7XG4gICAgICBvbkFmdGVyUmVuZGVyTm9BbmNob3I6ICdvbkFmdGVyUmVuZGVyTm9BbmNob3InLFxuICAgICAgb25DbGlja09yVG91Y2g6ICdvbkNsaWNrT3JUb3VjaCcsXG4gICAgICBtb3ZlU2xpZGVMZWZ0OiAnbW92ZVNsaWRlTGVmdCcsXG4gICAgICBtb3ZlU2xpZGVSaWdodDogJ21vdmVTbGlkZVJpZ2h0JyxcbiAgICAgIG9uSW5pdGlhbGlzZTogJ29uSW5pdGlhbGlzZScsXG4gICAgICBiZWZvcmVJbml0OiAnYmVmb3JlSW5pdCcsXG4gICAgICBiaW5kRXZlbnRzOiAnYmluZEV2ZW50cycsXG4gICAgICBvbkRlc3Ryb3k6ICdvbkRlc3Ryb3knLFxuICAgICAgb25EZXN0cm95QWxsOiAnb25EZXN0cm95QWxsJyxcbiAgICAgIGNvbnRlbnRDaGFuZ2VkOiAnY29udGVudENoYW5nZWQnLFxuICAgICAgb25TY3JvbGxPdmVyZmxvd1Njcm9sbGVkOiAnb25TY3JvbGxPdmVyZmxvd1Njcm9sbGVkJyxcbiAgICAgIG9uU2Nyb2xsUGFnZUFuZFNsaWRlOiAnb25TY3JvbGxQYWdlQW5kU2xpZGUnLFxuICAgICAgb25LZXlEb3duOiAnb25LZXlEb3duJyxcbiAgICAgIG9uTWVudUNsaWNrOiAnb25NZW51Q2xpY2snLFxuICAgICAgc2Nyb2xsUGFnZTogJ3Njcm9sbFBhZ2UnLFxuICAgICAgbGFuZHNjYXBlU2Nyb2xsOiAnbGFuZHNjYXBlU2Nyb2xsJyxcbiAgICAgIHNjcm9sbEJleW9uZEZ1bGxwYWdlOiAnc2Nyb2xsQmV5b25kRnVsbHBhZ2UnLFxuICAgICAgb25QZXJmb3JtTW92ZW1lbnQ6ICdvblBlcmZvcm1Nb3ZlbWVudCcsXG4gICAgICBvblNsaWRlTGVhdmU6ICdvblNsaWRlTGVhdmUnLFxuICAgICAgb25MZWF2ZTogJ29uTGVhdmUnLFxuICAgICAgYWZ0ZXJTZWN0aW9uTG9hZHM6ICdhZnRlclNlY3Rpb25Mb2FkcycsXG4gICAgICBhZnRlclNsaWRlTG9hZHM6ICdhZnRlclNsaWRlTG9hZHMnXG4gICAgfTtcblxuICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYmluZEV2ZW50cywgYmluZEV2ZW50cyRjKTtcblxuICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMkYygpIHtcbiAgICAgIC8vU2Nyb2xscyB0byB0aGUgc2VjdGlvbiB3aGVuIGNsaWNraW5nIHRoZSBuYXZpZ2F0aW9uIGJ1bGxldFxuICAgICAgLy9zaW11bGF0aW5nIHRoZSBqUXVlcnkgLm9uKCdjbGljaycpIGV2ZW50IHVzaW5nIGRlbGVnYXRpb25cbiAgICAgIFsnY2xpY2snLCAndG91Y2hzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICBkb2NBZGRFdmVudChldmVudE5hbWUsIGRlbGVnYXRlZEV2ZW50cyk7XG4gICAgICB9KTtcbiAgICAgIHdpbmRvd0FkZEV2ZW50KCdmb2N1cycsIGZvY3VzSGFuZGxlcik7XG4gICAgICBpbnRlcm5hbEV2ZW50cygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludGVybmFsRXZlbnRzKCkge1xuICAgICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5vbkRlc3Ryb3ksIG9uRGVzdHJveSQ5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxlZ2F0ZWRFdmVudHMoZSkge1xuICAgICAgRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRzLm9uQ2xpY2tPclRvdWNoLCB7XG4gICAgICAgIGU6IGUsXG4gICAgICAgIHRhcmdldDogZS50YXJnZXRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRGVzdHJveSQ5KCkge1xuICAgICAgWydjbGljaycsICd0b3VjaHN0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIGRvY1JlbW92ZUV2ZW50KGV2ZW50TmFtZSwgZGVsZWdhdGVkRXZlbnRzKTtcbiAgICAgIH0pO1xuICAgIH0gLy8gY2hhbmdpbmcgaXNXaW5kb3dGb2N1c2VkIHRvIHRydWUgb24gZm9jdXMgZXZlbnRcblxuXG4gICAgZnVuY3Rpb24gZm9jdXNIYW5kbGVyKCkge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpc1dpbmRvd0ZvY3VzZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGtlZXBpbmcgY2VudHJhbCBzZXQgb2YgY2xhc3NuYW1lcyBhbmQgc2VsZWN0b3JzXG4gICAgdmFyIFdSQVBQRVIgPSAnZnVsbHBhZ2Utd3JhcHBlcic7XG4gICAgdmFyIFdSQVBQRVJfU0VMID0gJy4nICsgV1JBUFBFUjsgLy8gc2xpbXNjcm9sbFxuXG4gICAgdmFyIFNDUk9MTEFCTEUgPSAnZnAtc2Nyb2xsYWJsZSc7XG5cbiAgICB2YXIgUkVTUE9OU0lWRSA9ICdmcC1yZXNwb25zaXZlJztcbiAgICB2YXIgTk9fVFJBTlNJVElPTiA9ICdmcC1ub3RyYW5zaXRpb24nO1xuICAgIHZhciBERVNUUk9ZRUQgPSAnZnAtZGVzdHJveWVkJztcbiAgICB2YXIgRU5BQkxFRCA9ICdmcC1lbmFibGVkJztcbiAgICB2YXIgVklFV0lOR19QUkVGSVggPSAnZnAtdmlld2luZyc7XG4gICAgdmFyIEFDVElWRSA9ICdhY3RpdmUnO1xuICAgIHZhciBBQ1RJVkVfU0VMID0gJy4nICsgQUNUSVZFO1xuICAgIHZhciBDT01QTEVURUxZID0gJ2ZwLWNvbXBsZXRlbHknO1xuICAgIHZhciBDT01QTEVURUxZX1NFTCA9ICcuJyArIENPTVBMRVRFTFk7XG4gICAgdmFyIExPQURFRCA9ICdmcC1sb2FkZWQnO1xuXG4gICAgdmFyIFNFQ1RJT05fREVGQVVMVF9TRUwgPSAnLnNlY3Rpb24nO1xuICAgIHZhciBTRUNUSU9OID0gJ2ZwLXNlY3Rpb24nO1xuICAgIHZhciBTRUNUSU9OX1NFTCA9ICcuJyArIFNFQ1RJT047XG4gICAgdmFyIFNFQ1RJT05fQUNUSVZFX1NFTCA9IFNFQ1RJT05fU0VMICsgQUNUSVZFX1NFTDtcbiAgICB2YXIgVEFCTEVfQ0VMTCA9ICdmcC10YWJsZUNlbGwnO1xuICAgIHZhciBUQUJMRV9DRUxMX1NFTCA9ICcuJyArIFRBQkxFX0NFTEw7XG4gICAgdmFyIEFVVE9fSEVJR0hUID0gJ2ZwLWF1dG8taGVpZ2h0JztcbiAgICB2YXIgQVVUT19IRUlHSFRfU0VMID0gJy4nICsgQVVUT19IRUlHSFQ7XG4gICAgdmFyIEFVVE9fSEVJR0hUX1JFU1BPTlNJVkUgPSAnZnAtYXV0by1oZWlnaHQtcmVzcG9uc2l2ZSc7XG4gICAgdmFyIEFVVE9fSEVJR0hUX1JFU1BPTlNJVkVfU0VMID0gJy4nICsgQVVUT19IRUlHSFRfUkVTUE9OU0lWRTtcbiAgICB2YXIgTk9STUFMX1NDUk9MTCA9ICdmcC1ub3JtYWwtc2Nyb2xsJztcblxuICAgIHZhciBTRUNUSU9OX05BViA9ICdmcC1uYXYnO1xuICAgIHZhciBTRUNUSU9OX05BVl9TRUwgPSAnIycgKyBTRUNUSU9OX05BVjtcbiAgICB2YXIgU0VDVElPTl9OQVZfVE9PTFRJUCA9ICdmcC10b29sdGlwJztcbiAgICB2YXIgU0VDVElPTl9OQVZfVE9PTFRJUF9TRUwgPSAnLicgKyBTRUNUSU9OX05BVl9UT09MVElQO1xuICAgIHZhciBTSE9XX0FDVElWRV9UT09MVElQID0gJ2ZwLXNob3ctYWN0aXZlJzsgLy8gc2xpZGVcblxuICAgIHZhciBTTElERV9ERUZBVUxUX1NFTCA9ICcuc2xpZGUnO1xuICAgIHZhciBTTElERSA9ICdmcC1zbGlkZSc7XG4gICAgdmFyIFNMSURFX1NFTCA9ICcuJyArIFNMSURFO1xuICAgIHZhciBTTElERV9BQ1RJVkVfU0VMID0gU0xJREVfU0VMICsgQUNUSVZFX1NFTDtcbiAgICB2YXIgU0xJREVTX1dSQVBQRVIgPSAnZnAtc2xpZGVzJztcbiAgICB2YXIgU0xJREVTX1dSQVBQRVJfU0VMID0gJy4nICsgU0xJREVTX1dSQVBQRVI7XG4gICAgdmFyIFNMSURFU19DT05UQUlORVIgPSAnZnAtc2xpZGVzQ29udGFpbmVyJztcbiAgICB2YXIgU0xJREVTX0NPTlRBSU5FUl9TRUwgPSAnLicgKyBTTElERVNfQ09OVEFJTkVSO1xuICAgIHZhciBUQUJMRSA9ICdmcC10YWJsZSc7XG4gICAgdmFyIE9WRVJGTE9XID0gJ2ZwLW92ZXJmbG93JztcbiAgICB2YXIgT1ZFUkZMT1dfU0VMID0gJy4nICsgT1ZFUkZMT1c7XG4gICAgdmFyIElTX09WRVJGTE9XID0gJ2ZwLWlzLW92ZXJmbG93JzsgLy8gc2xpZGUgbmF2XG5cbiAgICB2YXIgU0xJREVTX05BViA9ICdmcC1zbGlkZXNOYXYnO1xuICAgIHZhciBTTElERVNfTkFWX1NFTCA9ICcuJyArIFNMSURFU19OQVY7XG4gICAgdmFyIFNMSURFU19OQVZfTElOS19TRUwgPSBTTElERVNfTkFWX1NFTCArICcgYSc7XG4gICAgdmFyIFNMSURFU19TVFlMRURfQVJST1cgPSAnZnAtYXJyb3cnO1xuICAgIHZhciBTTElERVNfQVJST1cgPSAnZnAtY29udHJvbEFycm93JztcbiAgICB2YXIgU0xJREVTX0FSUk9XX1NFTCA9ICcuJyArIFNMSURFU19BUlJPVztcbiAgICB2YXIgU0xJREVTX1BSRVYgPSAnZnAtcHJldic7XG4gICAgdmFyIFNMSURFU19QUkVWX1NFTCA9ICcuJyArIFNMSURFU19QUkVWO1xuICAgIHZhciBTTElERVNfQVJST1dfUFJFVl9TRUwgPSBTTElERVNfQVJST1dfU0VMICsgU0xJREVTX1BSRVZfU0VMO1xuICAgIHZhciBTTElERVNfTkVYVCA9ICdmcC1uZXh0JztcbiAgICB2YXIgU0xJREVTX05FWFRfU0VMID0gJy4nICsgU0xJREVTX05FWFQ7XG4gICAgdmFyIFNMSURFU19BUlJPV19ORVhUX1NFTCA9IFNMSURFU19BUlJPV19TRUwgKyBTTElERVNfTkVYVF9TRUw7IC8vIFdhdGVybWFya1xuXG4gICAgdmFyIFdBVEVSTUFSSyA9ICdmcC13YXRlcm1hcmsnO1xuICAgIHZhciBXQVRFUk1BUktfU0VMID0gJy4nICsgV0FURVJNQVJLO1xuXG4gICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgLy9uYXZpZ2F0aW9uXG4gICAgICBtZW51OiBmYWxzZSxcbiAgICAgIGFuY2hvcnM6IFtdLFxuICAgICAgbG9ja0FuY2hvcnM6IGZhbHNlLFxuICAgICAgbmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICBuYXZpZ2F0aW9uUG9zaXRpb246ICdyaWdodCcsXG4gICAgICBuYXZpZ2F0aW9uVG9vbHRpcHM6IFtdLFxuICAgICAgc2hvd0FjdGl2ZVRvb2x0aXA6IGZhbHNlLFxuICAgICAgc2xpZGVzTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICBzbGlkZXNOYXZQb3NpdGlvbjogJ2JvdHRvbScsXG4gICAgICBzY3JvbGxCYXI6IGZhbHNlLFxuICAgICAgaHlicmlkOiBmYWxzZSxcbiAgICAgIGxpY2Vuc2VLZXk6ICcnLFxuICAgICAgY3JlZGl0czoge1xuICAgICAgICBcImVuYWJsZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJsYWJlbFwiOiAnTWFkZSB3aXRoIGZ1bGxQYWdlLmpzJyxcbiAgICAgICAgXCJwb3NpdGlvblwiOiAncmlnaHQnXG4gICAgICB9LFxuICAgICAgLy9zY3JvbGxpbmdcbiAgICAgIGNzczM6IHRydWUsXG4gICAgICBzY3JvbGxpbmdTcGVlZDogNzAwLFxuICAgICAgYXV0b1Njcm9sbGluZzogdHJ1ZSxcbiAgICAgIGZpdFRvU2VjdGlvbjogdHJ1ZSxcbiAgICAgIGZpdFRvU2VjdGlvbkRlbGF5OiA2MDAsXG4gICAgICBlYXNpbmc6ICdlYXNlSW5PdXRDdWJpYycsXG4gICAgICBlYXNpbmdjc3MzOiAnZWFzZScsXG4gICAgICBsb29wQm90dG9tOiBmYWxzZSxcbiAgICAgIGxvb3BUb3A6IGZhbHNlLFxuICAgICAgbG9vcEhvcml6b250YWw6IHRydWUsXG4gICAgICBjb250aW51b3VzVmVydGljYWw6IGZhbHNlLFxuICAgICAgY29udGludW91c0hvcml6b250YWw6IGZhbHNlLFxuICAgICAgc2Nyb2xsSG9yaXpvbnRhbGx5OiBmYWxzZSxcbiAgICAgIGludGVybG9ja2VkU2xpZGVzOiBmYWxzZSxcbiAgICAgIGRyYWdBbmRNb3ZlOiBmYWxzZSxcbiAgICAgIG9mZnNldFNlY3Rpb25zOiBmYWxzZSxcbiAgICAgIHJlc2V0U2xpZGVyczogZmFsc2UsXG4gICAgICBmYWRpbmdFZmZlY3Q6IGZhbHNlLFxuICAgICAgbm9ybWFsU2Nyb2xsRWxlbWVudHM6IG51bGwsXG4gICAgICBzY3JvbGxPdmVyZmxvdzogdHJ1ZSxcbiAgICAgIHNjcm9sbE92ZXJmbG93UmVzZXQ6IGZhbHNlLFxuICAgICAgc2tpcEludGVybWVkaWF0ZUl0ZW1zOiBmYWxzZSxcbiAgICAgIHRvdWNoU2Vuc2l0aXZpdHk6IDUsXG4gICAgICB0b3VjaFdyYXBwZXI6IG51bGwsXG4gICAgICBiaWdTZWN0aW9uc0Rlc3RpbmF0aW9uOiBudWxsLFxuICAgICAgYWRqdXN0T25OYXZDaGFuZ2U6IHRydWUsXG4gICAgICAvL0FjY2Vzc2liaWxpdHlcbiAgICAgIGtleWJvYXJkU2Nyb2xsaW5nOiB0cnVlLFxuICAgICAgYW5pbWF0ZUFuY2hvcjogdHJ1ZSxcbiAgICAgIHJlY29yZEhpc3Rvcnk6IHRydWUsXG4gICAgICBhbGxvd0NvcnJlY3REaXJlY3Rpb246IGZhbHNlLFxuICAgICAgLy9kZXNpZ25cbiAgICAgIHNjcm9sbE92ZXJmbG93TWFjU3R5bGU6IHRydWUsXG4gICAgICBjb250cm9sQXJyb3dzOiB0cnVlLFxuICAgICAgY29udHJvbEFycm93c0hUTUw6IFsnPGRpdiBjbGFzcz1cIicgKyBTTElERVNfU1RZTEVEX0FSUk9XICsgJ1wiPjwvZGl2PicsICc8ZGl2IGNsYXNzPVwiJyArIFNMSURFU19TVFlMRURfQVJST1cgKyAnXCI+PC9kaXY+J10sXG4gICAgICBjb250cm9sQXJyb3dDb2xvcjogJyNmZmYnLFxuICAgICAgdmVydGljYWxDZW50ZXJlZDogdHJ1ZSxcbiAgICAgIHNlY3Rpb25zQ29sb3I6IFtdLFxuICAgICAgcGFkZGluZ1RvcDogMCxcbiAgICAgIHBhZGRpbmdCb3R0b206IDAsXG4gICAgICBmaXhlZEVsZW1lbnRzOiBudWxsLFxuICAgICAgcmVzcG9uc2l2ZTogMCxcbiAgICAgIC8vYmFja3dhcmRzIGNvbXBhYml0aWxpdHkgd2l0aCByZXNwb25zaXZlV2lkZHRoXG4gICAgICByZXNwb25zaXZlV2lkdGg6IDAsXG4gICAgICByZXNwb25zaXZlSGVpZ2h0OiAwLFxuICAgICAgcmVzcG9uc2l2ZVNsaWRlczogZmFsc2UsXG4gICAgICBwYXJhbGxheDogZmFsc2UsXG4gICAgICBwYXJhbGxheE9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogJ3JldmVhbCcsXG4gICAgICAgIHBlcmNlbnRhZ2U6IDYyLFxuICAgICAgICBwcm9wZXJ0eTogJ3RyYW5zbGF0ZSdcbiAgICAgIH0sXG4gICAgICBjYXJkczogZmFsc2UsXG4gICAgICBjYXJkc09wdGlvbnM6IHtcbiAgICAgICAgcGVyc3BlY3RpdmU6IDEwMCxcbiAgICAgICAgZmFkZUNvbnRlbnQ6IHRydWUsXG4gICAgICAgIGZhZGVCYWNrZ3JvdW5kOiB0cnVlXG4gICAgICB9LFxuICAgICAgLy9DdXN0b20gc2VsZWN0b3JzXG4gICAgICBzZWN0aW9uU2VsZWN0b3I6IFNFQ1RJT05fREVGQVVMVF9TRUwsXG4gICAgICBzbGlkZVNlbGVjdG9yOiBTTElERV9ERUZBVUxUX1NFTCxcbiAgICAgIC8vZXZlbnRzXG4gICAgICBhZnRlckxvYWQ6IG51bGwsXG4gICAgICBiZWZvcmVMZWF2ZTogbnVsbCxcbiAgICAgIG9uTGVhdmU6IG51bGwsXG4gICAgICBhZnRlclJlbmRlcjogbnVsbCxcbiAgICAgIGFmdGVyUmVzaXplOiBudWxsLFxuICAgICAgYWZ0ZXJSZUJ1aWxkOiBudWxsLFxuICAgICAgYWZ0ZXJTbGlkZUxvYWQ6IG51bGwsXG4gICAgICBvblNsaWRlTGVhdmU6IG51bGwsXG4gICAgICBhZnRlclJlc3BvbnNpdmU6IG51bGwsXG4gICAgICBvblNjcm9sbE92ZXJmbG93OiBudWxsLFxuICAgICAgbGF6eUxvYWRpbmc6IHRydWUsXG4gICAgICBsYXp5TG9hZFRocmVzaG9sZDogMCxcbiAgICAgIG9ic2VydmVyOiB0cnVlLFxuICAgICAgc2Nyb2xsQmV5b25kRnVsbHBhZ2U6IHRydWVcbiAgICB9O1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IG51bGw7XG4gICAgdmFyIGdfaW5pdGlhbEFuY2hvcnNJbkRvbSA9IGZhbHNlO1xuICAgIHZhciBvcmlnaW5hbHMgPSBkZWVwRXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucyk7IC8vZGVlcCBjb3B5XG5cbiAgICB2YXIgZ19vcHRpb25zID0gbnVsbDtcbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsQW5jaG9yc0luRG9tKCkge1xuICAgICAgcmV0dXJuIGdfaW5pdGlhbEFuY2hvcnNJbkRvbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0Q29udGFpbmVyKHZhbHVlKSB7XG4gICAgICBjb250YWluZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29udGFpbmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIGdfb3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBnX29wdGlvbnMgPSBkZWVwRXh0ZW5kKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICBvcmlnaW5hbHMgPSBPYmplY3QuYXNzaWduKHt9LCBnX29wdGlvbnMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPcmlnaW5hbHMoKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRPcHRpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIGRlZmF1bHRPcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIC8qXG4gICAgKiBTZXRzIHRoZSBzdGF0ZSBmb3IgYSB2YXJpYWJsZSB3aXRoIG11bHRpcGxlIHN0YXRlcyAob3JpZ2luYWwsIGFuZCB0ZW1wb3JhbClcbiAgICAqIFNvbWUgdmFyaWFibGVzIHN1Y2ggYXMgYGF1dG9TY3JvbGxpbmdgIG9yIGByZWNvcmRIaXN0b3J5YCBtaWdodCBjaGFuZ2UgYXV0b21hdGljYWxseSBpdHMgc3RhdGUgd2hlbiB1c2luZyBgcmVzcG9uc2l2ZWAgb3IgYGF1dG9TY3JvbGxpbmc6ZmFsc2VgLlxuICAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgYm90aCBzdGF0ZXMsIHRoZSBvcmlnaW5hbCBhbmQgdGhlIHRlbXBvcmFsIG9uZS5cbiAgICAqIElmIHR5cGUgaXMgbm90ICdpbnRlcm5hbCcsIHRoZW4gd2UgYXNzdW1lIHRoZSB1c2VyIGlzIGdsb2JhbGx5IGNoYW5naW5nIHRoZSB2YXJpYWJsZS5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2V0VmFyaWFibGVTdGF0ZSh2YXJpYWJsZSwgdmFsdWUsIHR5cGUpIHtcbiAgICAgIGdfb3B0aW9uc1t2YXJpYWJsZV0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHR5cGUgIT09ICdpbnRlcm5hbCcpIHtcbiAgICAgICAgb3JpZ2luYWxzW3ZhcmlhYmxlXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIFNldHRpbmcgb3B0aW9ucyBmcm9tIERPTSBlbGVtZW50cyBpZiB0aGV5IGFyZSBub3QgcHJvdmlkZWQuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNldE9wdGlvbnNGcm9tRE9NKCkge1xuICAgICAgLy9ubyBhbmNob3JzIG9wdGlvbj8gQ2hlY2tpbmcgZm9yIHRoZW0gaW4gdGhlIERPTSBhdHRyaWJ1dGVzXG4gICAgICBpZiAoIWdldE9wdGlvbnMoKS5hbmNob3JzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYW5jaG9yc0F0dHJpYnV0ZSA9ICdbZGF0YS1hbmNob3JdJztcbiAgICAgICAgdmFyIGFuY2hvcnMgPSAkKGdldE9wdGlvbnMoKS5zZWN0aW9uU2VsZWN0b3Iuc3BsaXQoJywnKS5qb2luKGFuY2hvcnNBdHRyaWJ1dGUgKyAnLCcpICsgYW5jaG9yc0F0dHJpYnV0ZSwgY29udGFpbmVyKTtcblxuICAgICAgICBpZiAoYW5jaG9ycy5sZW5ndGggJiYgYW5jaG9ycy5sZW5ndGggPT09ICQoZ2V0T3B0aW9ucygpLnNlY3Rpb25TZWxlY3RvciwgY29udGFpbmVyKS5sZW5ndGgpIHtcbiAgICAgICAgICBnX2luaXRpYWxBbmNob3JzSW5Eb20gPSB0cnVlO1xuICAgICAgICAgIGFuY2hvcnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgZ2V0T3B0aW9ucygpLmFuY2hvcnMucHVzaChnZXRBdHRyKGl0ZW0sICdkYXRhLWFuY2hvcicpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vbm8gdG9vbHRpcHMgb3B0aW9uPyBDaGVja2luZyBmb3IgdGhlbSBpbiB0aGUgRE9NIGF0dHJpYnV0ZXNcblxuXG4gICAgICBpZiAoIWdldE9wdGlvbnMoKS5uYXZpZ2F0aW9uVG9vbHRpcHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0b29sdGlwc0F0dHJpYnV0ZSA9ICdbZGF0YS10b29sdGlwXSc7XG4gICAgICAgIHZhciB0b29sdGlwcyA9ICQoZ2V0T3B0aW9ucygpLnNlY3Rpb25TZWxlY3Rvci5zcGxpdCgnLCcpLmpvaW4odG9vbHRpcHNBdHRyaWJ1dGUgKyAnLCcpICsgdG9vbHRpcHNBdHRyaWJ1dGUsIGNvbnRhaW5lcik7XG5cbiAgICAgICAgaWYgKHRvb2x0aXBzLmxlbmd0aCkge1xuICAgICAgICAgIHRvb2x0aXBzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGdldE9wdGlvbnMoKS5uYXZpZ2F0aW9uVG9vbHRpcHMucHVzaChnZXRBdHRyKGl0ZW0sICdkYXRhLXRvb2x0aXAnKS50b1N0cmluZygpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwbGFpbkl0ZW0gPSBmdW5jdGlvbiBwbGFpbkl0ZW0ocGFuZWwpIHtcbiAgICAgIHRoaXMuYW5jaG9yID0gcGFuZWwuYW5jaG9yO1xuICAgICAgdGhpcy5pdGVtID0gcGFuZWwuaXRlbTtcbiAgICAgIHRoaXMuaW5kZXggPSBwYW5lbC5pbmRleCgpO1xuICAgICAgdGhpcy5pc0xhc3QgPSB0aGlzLmluZGV4ID09PSBwYW5lbC5pdGVtLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChwYW5lbC5zZWxlY3RvcikubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXMuaXNGaXJzdCA9ICF0aGlzLmluZGV4O1xuICAgICAgdGhpcy5pc0FjdGl2ZSA9IHBhbmVsLmlzQWN0aXZlO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBJdGVtLiBTbGlkZSBvciBTZWN0aW9uIG9iamVjdHMgc2hhcmUgdGhlIHNhbWUgcHJvcGVydGllcy5cbiAgICAqL1xuXG4gICAgdmFyIEl0ZW0gPSBmdW5jdGlvbiBJdGVtKGVsLCBzZWxlY3Rvcikge1xuICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLnBhcmVudCB8fCBudWxsO1xuICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgdGhpcy5hbmNob3IgPSBnZXRBdHRyKGVsLCAnZGF0YS1hbmNob3InKSB8fCBnZXRPcHRpb25zKCkuYW5jaG9yc1tpbmRleChlbCwgZ2V0T3B0aW9ucygpLnNlY3Rpb25TZWxlY3RvcildO1xuICAgICAgdGhpcy5pdGVtID0gZWw7XG4gICAgICB0aGlzLmlzVmlzaWJsZSA9IGlzVmlzaWJsZShlbCk7XG4gICAgICB0aGlzLmlzQWN0aXZlID0gaGFzQ2xhc3MoZWwsIEFDVElWRSk7XG4gICAgICB0aGlzLmhhc1Njcm9sbCA9IGhhc0NsYXNzKGVsLCBPVkVSRkxPVykgfHwgJChPVkVSRkxPV19TRUwsIGVsKVswXSAhPSBudWxsO1xuICAgICAgdGhpcy5pc1NlY3Rpb24gPSBzZWxlY3RvciA9PT0gZ2V0T3B0aW9ucygpLnNlY3Rpb25TZWxlY3RvcjtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY2xvc2VzdChlbCwgU0xJREVTX0NPTlRBSU5FUl9TRUwpIHx8IGNsb3Nlc3QoZWwsIFdSQVBQRVJfU0VMKTtcblxuICAgICAgdGhpcy5pbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3MoKS5pbmRleE9mKHRoaXMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgSXRlbS5wcm90b3R5cGUuc2libGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5pc1NlY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnNlY3Rpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5zZWN0aW9uc0luY2x1ZGluZ0hpZGRlbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5zbGlkZXMgOiAwO1xuICAgIH07XG5cbiAgICBJdGVtLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNpYmxpbmdzID0gdGhpcy5zaWJsaW5ncygpO1xuICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMuaXNTZWN0aW9uID8gc2libGluZ3MuaW5kZXhPZih0aGlzKSA6IHRoaXMucGFyZW50LnNsaWRlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgdmFyIHByZXZJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG5cbiAgICAgIGlmIChwcmV2SW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gc2libGluZ3NbcHJldkluZGV4XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIEl0ZW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2libGluZ3MgPSB0aGlzLnNpYmxpbmdzKCk7XG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5pc1NlY3Rpb24gPyBzaWJsaW5ncy5pbmRleE9mKHRoaXMpIDogdGhpcy5wYXJlbnQuc2xpZGVzLmluZGV4T2YodGhpcyk7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcblxuICAgICAgaWYgKG5leHRJbmRleCA8IHNpYmxpbmdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc2libGluZ3NbbmV4dEluZGV4XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIEl0ZW0ucHJvdG90eXBlW1wicHJldlBhbmVsXCJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldigpIHx8ICh0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnByZXYoKSA6IG51bGwpO1xuICAgIH07XG5cbiAgICBJdGVtLnByb3RvdHlwZVtcIm5leHRQYW5lbFwiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHQoKSB8fCAodGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5uZXh0KCkgOiBudWxsKTtcbiAgICB9O1xuXG4gICAgSXRlbS5wcm90b3R5cGUuZ2V0U2libGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5pc1NlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLnNlY3Rpb25zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGUucGFuZWxzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXROb2RlcyhwYW5lbHMpIHtcbiAgICAgIHJldHVybiBwYW5lbHMubWFwKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICByZXR1cm4gcGFuZWwuaXRlbTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQYW5lbEJ5RWxlbWVudChwYW5lbHMsIGVsKSB7XG4gICAgICByZXR1cm4gcGFuZWxzLmZpbmQoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHJldHVybiBwYW5lbC5pdGVtID09PSBlbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uIFNlY3Rpb24oZWwpIHtcbiAgICAgIHBsYWluSXRlbS5jYWxsKHRoaXMsIGVsKTtcbiAgICB9O1xuICAgIHZhciBTbGlkZSA9IGZ1bmN0aW9uIFNsaWRlKGVsKSB7XG4gICAgICBwbGFpbkl0ZW0uY2FsbCh0aGlzLCBlbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICogR2V0cyB0aGUgYWN0aXZlIHNsaWRlIChvciBzZWN0aW9uKSBmb3IgdGhlIGdpdmVuIHNlY3Rpb25cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0U2xpZGVPclNlY3Rpb24oZGVzdGlueSkge1xuICAgICAgdmFyIHNsaWRlID0gJChTTElERV9BQ1RJVkVfU0VMLCBkZXN0aW55KTtcblxuICAgICAgaWYgKHNsaWRlLmxlbmd0aCkge1xuICAgICAgICBkZXN0aW55ID0gc2xpZGVbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXN0aW55O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTbGlkZU9yU2VjdGlvblBhbmVsKHBhbmVsKSB7XG4gICAgICBpZiAoIXBhbmVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFuZWwuYWN0aXZlU2xpZGUgPyBwYW5lbC5hY3RpdmVTbGlkZSA6IHBhbmVsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Z1bGxQYWdlQWJvdmUoKSB7XG4gICAgICByZXR1cm4gZ2V0Q29udGFpbmVyKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tID49IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogR2V0cyB0aGUgc2Nyb2xsaW5nIHNldHRpbmdzIGRlcGVuZGluZyBvbiB0aGUgcGx1Z2luIGF1dG9TY3JvbGxpbmcgb3B0aW9uXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldFNjcm9sbFNldHRpbmdzKHRvcCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG4gICAgICB2YXIgcG9zaXRpb247XG4gICAgICB2YXIgZWxlbWVudDsgLy90b3AgcHJvcGVydHkgYW5pbWF0aW9uXG5cbiAgICAgIGlmIChvcHRpb25zLmF1dG9TY3JvbGxpbmcgJiYgIW9wdGlvbnMuc2Nyb2xsQmFyKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLXRvcDtcbiAgICAgICAgZWxlbWVudCA9ICQoV1JBUFBFUl9TRUwpWzBdO1xuICAgICAgfSAvL3dpbmRvdyByZWFsIHNjcm9sbGluZ1xuICAgICAgZWxzZSB7XG4gICAgICAgIHBvc2l0aW9uID0gdG9wO1xuICAgICAgICBlbGVtZW50ID0gd2luZG93O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25zOiBwb3NpdGlvbixcbiAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTY3JvbGxzIHRoZSBwYWdlIC8gc2xpZGVyIHRoZSBnaXZlbiBudW1iZXIgb2YgcGl4ZWxzLlxuICAgICogSXQgd2lsbCBkbyBpdCBvbmUgb3IgYW5vdGhlciB3YXkgZGVwZW5kaW9uZyBvbiB0aGUgbGlicmFyeSdzIGNvbmZpZy5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2V0U2Nyb2xsaW5nKGVsZW1lbnQsIHZhbCkge1xuICAgICAgaWYgKCFnZXRPcHRpb25zKCkuYXV0b1Njcm9sbGluZyB8fCBnZXRPcHRpb25zKCkuc2Nyb2xsQmFyIHx8IGVsZW1lbnQuc2VsZiAhPSB3aW5kb3cgJiYgaGFzQ2xhc3MoZWxlbWVudCwgU0xJREVTX1dSQVBQRVIpKSB7XG4gICAgICAgIC8vc2Nyb2xsaW5nIGhvcml6b250YWxseSB0aHJvdWdoIHRoZSBzbGlkZXM/XG4gICAgICAgIGlmIChlbGVtZW50LnNlbGYgIT0gd2luZG93ICYmIGhhc0NsYXNzKGVsZW1lbnQsIFNMSURFU19XUkFQUEVSKSkge1xuICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHZhbDtcbiAgICAgICAgfSAvL3ZlcnRpY2FsIHNjcm9sbFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LnNjcm9sbFRvKDAsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gdmFsICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBBZGRzIHRyYW5zaXRpb24gYW5pbWF0aW9ucyBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gYWRkQW5pbWF0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJ3RyYW5zZm9ybSAnICsgZ2V0T3B0aW9ucygpLnNjcm9sbGluZ1NwZWVkICsgJ21zICcgKyBnZXRPcHRpb25zKCkuZWFzaW5nY3NzMztcbiAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIE5PX1RSQU5TSVRJT04pO1xuICAgICAgcmV0dXJuIGNzcyhlbGVtZW50LCB7XG4gICAgICAgICctd2Via2l0LXRyYW5zaXRpb24nOiB0cmFuc2l0aW9uLFxuICAgICAgICAndHJhbnNpdGlvbic6IHRyYW5zaXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJldHVucyBgdXBgIG9yIGBkb3duYCBkZXBlbmRpbmcgb24gdGhlIHNjcm9sbGluZyBtb3ZlbWVudCB0byByZWFjaCBpdHMgZGVzdGluYXRpb25cbiAgICAqIGZyb20gdGhlIGN1cnJlbnQgc2VjdGlvbi5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0WW1vdmVtZW50KGFjdGl2ZVNlY3Rpb24sIGRlc3RpbnkpIHtcbiAgICAgIHZhciBmcm9tSW5kZXggPSBhY3RpdmVTZWN0aW9uLmluZGV4KCk7XG4gICAgICB2YXIgdG9JbmRleCA9IGluZGV4KGRlc3RpbnksIFNFQ1RJT05fU0VMKTtcblxuICAgICAgaWYgKGZyb21JbmRleCA9PSB0b0luZGV4KSB7XG4gICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmcm9tSW5kZXggPiB0b0luZGV4KSB7XG4gICAgICAgIHJldHVybiAndXAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ2Rvd24nO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJlbW92ZSB0cmFuc2l0aW9uIGFuaW1hdGlvbnMgZm9yIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuaW1hdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gYWRkQ2xhc3MoZWxlbWVudCwgTk9fVFJBTlNJVElPTik7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgY3Jvc3MtYnJvd3NlciB0cmFuc2Zvcm0gc3RyaW5nLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1zKHRyYW5zbGF0ZTNkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnLXdlYmtpdC10cmFuc2Zvcm0nOiB0cmFuc2xhdGUzZCxcbiAgICAgICAgJy1tb3otdHJhbnNmb3JtJzogdHJhbnNsYXRlM2QsXG4gICAgICAgICctbXMtdHJhbnNmb3JtJzogdHJhbnNsYXRlM2QsXG4gICAgICAgICd0cmFuc2Zvcm0nOiB0cmFuc2xhdGUzZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc2lsZW50U2Nyb2xsSWQ7XG4gICAgLyoqXG4gICAgKiBBZGRzIGEgY3NzMyB0cmFuc2Zvcm0gcHJvcGVydHkgdG8gdGhlIGNvbnRhaW5lciBjbGFzcyB3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uIGRlcGVuZGluZyBvbiB0aGUgYW5pbWF0ZWQgcGFyYW0uXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUNvbnRhaW5lcih0cmFuc2xhdGUzZCwgYW5pbWF0ZWQpIHtcbiAgICAgIGlmIChhbmltYXRlZCkge1xuICAgICAgICBhZGRBbmltYXRpb24oZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQW5pbWF0aW9uKGdldENvbnRhaW5lcigpKTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KHNpbGVudFNjcm9sbElkKTtcbiAgICAgIGNzcyhnZXRDb250YWluZXIoKSwgZ2V0VHJhbnNmb3Jtcyh0cmFuc2xhdGUzZCkpO1xuICAgICAgRlAudGVzdC50cmFuc2xhdGUzZCA9IHRyYW5zbGF0ZTNkOyAvL3N5bmNyb25vdXNseSByZW1vdmluZyB0aGUgY2xhc3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgYmVlbiBhcHBsaWVkLlxuXG4gICAgICBzaWxlbnRTY3JvbGxJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVDbGFzcyhnZXRDb250YWluZXIoKSwgTk9fVFJBTlNJVElPTik7XG4gICAgICB9LCAxMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBTY3JvbGxzIHNpbGVudGx5ICh3aXRoIG5vIGFuaW1hdGlvbikgdGhlIHBhZ2UgdG8gdGhlIGdpdmVuIFkgcG9zaXRpb24uXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNpbGVudFNjcm9sbCh0b3ApIHtcbiAgICAgIC8vIFRoZSBmaXJzdCBzZWN0aW9uIGNhbiBoYXZlIGEgbmVnYXRpdmUgdmFsdWUgaW4gaU9TIDEwLiBOb3QgcXVpdGUgc3VyZSB3aHk6IC0wLjAxNDI4MjIyNjU2MjVcbiAgICAgIC8vIHRoYXQncyB3aHkgd2Ugcm91bmQgaXQgdG8gMC5cbiAgICAgIHZhciByb3VuZGVkVG9wID0gTWF0aC5yb3VuZCh0b3ApO1xuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLmNzczMgJiYgZ2V0T3B0aW9ucygpLmF1dG9TY3JvbGxpbmcgJiYgIWdldE9wdGlvbnMoKS5zY3JvbGxCYXIpIHtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZTNkID0gJ3RyYW5zbGF0ZTNkKDBweCwgLScgKyByb3VuZGVkVG9wICsgJ3B4LCAwcHgpJztcbiAgICAgICAgdHJhbnNmb3JtQ29udGFpbmVyKHRyYW5zbGF0ZTNkLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKGdldE9wdGlvbnMoKS5hdXRvU2Nyb2xsaW5nICYmICFnZXRPcHRpb25zKCkuc2Nyb2xsQmFyKSB7XG4gICAgICAgIGNzcyhnZXRDb250YWluZXIoKSwge1xuICAgICAgICAgICd0b3AnOiAtcm91bmRlZFRvcCArICdweCdcbiAgICAgICAgfSk7XG4gICAgICAgIEZQLnRlc3QudG9wID0gLXJvdW5kZWRUb3AgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNjcm9sbFNldHRpbmdzID0gZ2V0U2Nyb2xsU2V0dGluZ3Mocm91bmRlZFRvcCk7XG4gICAgICAgIHNldFNjcm9sbGluZyhzY3JvbGxTZXR0aW5ncy5lbGVtZW50LCBzY3JvbGxTZXR0aW5ncy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBGUC5zZXRTY3JvbGxpbmdTcGVlZCA9IHNldFNjcm9sbGluZ1NwZWVkO1xuICAgIC8qKlxuICAgICogRGVmaW5lcyB0aGUgc2Nyb2xsaW5nIHNwZWVkXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNldFNjcm9sbGluZ1NwZWVkKHZhbHVlLCB0eXBlKSB7XG4gICAgICBzZXRWYXJpYWJsZVN0YXRlKCdzY3JvbGxpbmdTcGVlZCcsIHZhbHVlLCB0eXBlKTtcbiAgICB9XG5cbiAgICB2YXIgJGJvZHkgPSBudWxsO1xuICAgIHZhciAkaHRtbCA9IG51bGw7XG4gICAgdmFyICRodG1sQm9keSA9IG51bGw7IC8vIGNhY2hpbmcgY29tbW9uIGVsZW1lbnRzXG5cbiAgICBmdW5jdGlvbiBzZXRDYWNoZSgpIHtcbiAgICAgICRib2R5ID0gJCgnYm9keScpWzBdO1xuICAgICAgJGh0bWwgPSAkKCdodG1sJylbMF07XG4gICAgICAkaHRtbEJvZHkgPSAkKCdodG1sLCBib2R5Jyk7XG4gICAgfVxuXG4gICAgLy9AdHMtY2hlY2tcblxuICAgIHZhciBfZ19hbmltYXRlU2Nyb2xsO1xuICAgIC8qKlxuICAgICogU2ltdWxhdGVzIHRoZSBhbmltYXRlZCBzY3JvbGxUb3Agb2YgalF1ZXJ5LiBVc2VkIHdoZW4gY3NzMzpmYWxzZSBvciBzY3JvbGxCYXI6dHJ1ZSBvciBhdXRvU2Nyb2xsaW5nOmZhbHNlXG4gICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjEzNjc4OS8xMDgxMzk2XG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsVG8oZWxlbWVudCwgdG8sIGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHN0YXJ0ID0gZ2V0U2Nyb2xsZWRQb3NpdGlvbihlbGVtZW50KTtcbiAgICAgIHZhciBjaGFuZ2UgPSB0byAtIHN0YXJ0O1xuICAgICAgdmFyIGlzQ2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgIHZhciB3YXNBbmltYXRpb25BY3RpdmUgPSBzdGF0ZS5hY3RpdmVBbmltYXRpb247XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGl2ZUFuaW1hdGlvbjogdHJ1ZVxuICAgICAgfSk7IC8vIENhbmNlbGxpbmcgYW55IHBvc3NpYmxlIHByZXZpb3VzIGFuaW1hdGlvbnMgKGlvOiBjbGlja2luZyBvbiBuYXYgZG90cyB2ZXJ5IGZhc3QpXG5cbiAgICAgIGlmIChfZ19hbmltYXRlU2Nyb2xsKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShfZ19hbmltYXRlU2Nyb2xsKTtcbiAgICAgIH1cblxuICAgICAgX2dfYW5pbWF0ZVNjcm9sbCA9IGZ1bmN0aW9uIGdfYW5pbWF0ZVNjcm9sbCh0aW1lc3RhbXApIHtcbiAgICAgICAgaWYgKCFzdGFydFRpbWUpIHtcbiAgICAgICAgICBzdGFydFRpbWUgPSB0aW1lc3RhbXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBNYXRoLmZsb29yKHRpbWVzdGFtcCAtIHN0YXJ0VGltZSk7XG5cbiAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZUFuaW1hdGlvbikge1xuICAgICAgICAgIC8vaW4gb3JkZXIgdG8gc3RvcGUgaXQgZnJvbSBvdGhlciBmdW5jdGlvbiB3aGVuZXZlciB3ZSB3YW50XG4gICAgICAgICAgdmFyIHZhbCA9IHRvO1xuXG4gICAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB2YWwgPSB3aW4uZnBfZWFzaW5nc1tnZXRPcHRpb25zKCkuZWFzaW5nXShjdXJyZW50VGltZSwgc3RhcnQsIGNoYW5nZSwgZHVyYXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50VGltZSA8PSBkdXJhdGlvbikge1xuICAgICAgICAgICAgc2V0U2Nyb2xsaW5nKGVsZW1lbnQsIHZhbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX2dfYW5pbWF0ZVNjcm9sbCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmICFpc0NhbGxiYWNrRmlyZWQpIHtcbiAgICAgICAgICAgIHNldFNjcm9sbGluZyhlbGVtZW50LCB0byk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgICBhY3RpdmVBbmltYXRpb246IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlzQ2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGxiYWNrRmlyZWQgJiYgIXdhc0FuaW1hdGlvbkFjdGl2ZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aXZlQW5pbWF0aW9uOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlzQ2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX2dfYW5pbWF0ZVNjcm9sbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogR2V0dGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgdG8gc2Nyb2xsIHdoZW4gdXNpbmcgalF1ZXJ5IGFuaW1hdGlvbnNcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsZWRQb3NpdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgcG9zaXRpb247IC8vaXMgbm90IHRoZSB3aW5kb3cgZWxlbWVudCBhbmQgaXMgYSBzbGlkZT9cblxuICAgICAgaWYgKGVsZW1lbnQuc2VsZiAhPSB3aW4gJiYgaGFzQ2xhc3MoZWxlbWVudCwgU0xJREVTX1dSQVBQRVIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgfSBlbHNlIGlmICghZ2V0T3B0aW9ucygpLmF1dG9TY3JvbGxpbmcgfHwgZ2V0T3B0aW9ucygpLnNjcm9sbEJhcikge1xuICAgICAgICBwb3NpdGlvbiA9IGdldFNjcm9sbFRvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zaXRpb24gPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgIH0gLy9nZXRzIHRoZSB0b3AgcHJvcGVydHkgb2YgdGhlIHdyYXBwZXJcblxuXG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBNYWtlcyBzdXJlIHRvIG9ubHkgY3JlYXRlIGEgUGFuZWwgb2JqZWN0IGlmIHRoZSBlbGVtZW50IGV4aXN0XG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIG51bGxPclNlY3Rpb24oZWwpIHtcbiAgICAgIGlmIChlbCAmJiAhZWwuaXRlbSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlY3Rpb24obmV3IFNlY3Rpb25QYW5lbChlbCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWwgPyBuZXcgU2VjdGlvbihlbCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG51bGxPclNsaWRlKGVsKSB7XG4gICAgICByZXR1cm4gZWwgPyBuZXcgU2xpZGUoZWwpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIERpc3BhdGNoIGV2ZW50cyAmIGNhbGxiYWNrc1xuICAgICovXG5cbiAgICBmdW5jdGlvbiBmaXJlQ2FsbGJhY2soZXZlbnROYW1lLCB2KSB7XG4gICAgICB2YXIgZXZlbnREYXRhID0gZ2V0RXZlbnREYXRhKGV2ZW50TmFtZSwgdik7XG4gICAgICB0cmlnZ2VyKGdldENvbnRhaW5lcigpLCBldmVudE5hbWUsIGV2ZW50RGF0YSk7XG5cbiAgICAgIGlmIChnZXRPcHRpb25zKClbZXZlbnROYW1lXS5hcHBseShldmVudERhdGFbT2JqZWN0LmtleXMoZXZlbnREYXRhKVswXV0sIHRvQXJyYXkoZXZlbnREYXRhKSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICogR2V0cyB0aGUgZXZlbnQncyBkYXRhIGZvciB0aGUgZ2l2ZW4gZXZlbnQgb24gdGhlIHJpZ2h0IGZvcm1hdC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0RXZlbnREYXRhKGV2ZW50TmFtZSwgdikge1xuICAgICAgLy91c2luZyBmdW5jdGlvbnMgdG8gcnVuIG9ubHkgdGhlIG5lY2Vzc2FyeSBiaXRzIHdpdGhpbiB0aGUgb2JqZWN0XG4gICAgICB2YXIgcGFyYW1zUGVyRXZlbnQgPSB7XG4gICAgICAgIGFmdGVyUmVuZGVyOiBmdW5jdGlvbiBhZnRlclJlbmRlcigpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VjdGlvbjogbnVsbE9yU2VjdGlvbihnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24pLFxuICAgICAgICAgICAgc2xpZGU6IG51bGxPclNsaWRlKGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5hY3RpdmVTbGlkZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvbkxlYXZlOiBmdW5jdGlvbiBvbkxlYXZlKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnaW46IG51bGxPclNlY3Rpb24odi5pdGVtcy5vcmlnaW4pLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IG51bGxPclNlY3Rpb24odi5pdGVtcy5kZXN0aW5hdGlvbiksXG4gICAgICAgICAgICBkaXJlY3Rpb246IHYuZGlyZWN0aW9uLFxuICAgICAgICAgICAgdHJpZ2dlcjogZ2V0U3RhdGUoKS5zY3JvbGxUcmlnZ2VyXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXJMb2FkOiBmdW5jdGlvbiBhZnRlckxvYWQoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtc1BlckV2ZW50Lm9uTGVhdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXJTbGlkZUxvYWQ6IGZ1bmN0aW9uIGFmdGVyU2xpZGVMb2FkKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWN0aW9uOiBudWxsT3JTZWN0aW9uKHYuaXRlbXMuc2VjdGlvbiksXG4gICAgICAgICAgICBvcmlnaW46IG51bGxPclNlY3Rpb24odi5pdGVtcy5vcmlnaW4pLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IG51bGxPclNlY3Rpb24odi5pdGVtcy5kZXN0aW5hdGlvbiksXG4gICAgICAgICAgICBkaXJlY3Rpb246IHYuZGlyZWN0aW9uLFxuICAgICAgICAgICAgdHJpZ2dlcjogZ2V0U3RhdGUoKS5zY3JvbGxUcmlnZ2VyXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TbGlkZUxlYXZlOiBmdW5jdGlvbiBvblNsaWRlTGVhdmUoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtc1BlckV2ZW50LmFmdGVyU2xpZGVMb2FkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZUxlYXZlOiBmdW5jdGlvbiBiZWZvcmVMZWF2ZSgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyYW1zUGVyRXZlbnQub25MZWF2ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBvblNjcm9sbE92ZXJmbG93OiBmdW5jdGlvbiBvblNjcm9sbE92ZXJmbG93KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWN0aW9uOiBudWxsT3JTZWN0aW9uKGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbiksXG4gICAgICAgICAgICBzbGlkZTogbnVsbE9yU2xpZGUoZ2V0U3RhdGUoKS5hY3RpdmVTZWN0aW9uLmFjdGl2ZVNsaWRlKSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB2LnBvc2l0aW9uLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiB2LmRpcmVjdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gcGFyYW1zUGVyRXZlbnRbZXZlbnROYW1lXSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0F1dG9QbGF5KGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmhhc0F0dHJpYnV0ZSgnZGF0YS1hdXRvcGxheScpIHx8IGl0ZW0uaGFzQXR0cmlidXRlKCdhdXRvcGxheScpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFBsYXlzIHZpZGVvIGFuZCBhdWRpbyBlbGVtZW50cy5cbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBwbGF5TWVkaWEoZGVzdGlueSkge1xuICAgICAgdmFyIHBhbmVsID0gZ2V0U2xpZGVPclNlY3Rpb24oZGVzdGlueSk7IC8vcGxheWluZyBIVE1MNSBtZWRpYSBlbGVtZW50c1xuXG4gICAgICAkKCd2aWRlbywgYXVkaW8nLCBwYW5lbCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoaGFzQXV0b1BsYXkoZWxlbWVudCkgJiYgdHlwZW9mIGVsZW1lbnQucGxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGVsZW1lbnQucGxheSgpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy95b3V0dWJlIHZpZGVvc1xuXG4gICAgICAkKCdpZnJhbWVbc3JjKj1cInlvdXR1YmUuY29tL2VtYmVkL1wiXScsIHBhbmVsKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChoYXNBdXRvUGxheShlbGVtZW50KSkge1xuICAgICAgICAgIHBsYXlZb3V0dWJlKGVsZW1lbnQpO1xuICAgICAgICB9IC8vaW4gY2FzZSB0aGUgVVJMIHdhcyBub3QgbG9hZGVkIHlldC4gT24gcGFnZSBsb2FkIHdlIG5lZWQgdGltZSBmb3IgdGhlIG5ldyBVUkwgKHdpdGggdGhlIEFQSSBzdHJpbmcpIHRvIGxvYWQuXG5cblxuICAgICAgICBlbGVtZW50Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaGFzQXV0b1BsYXkoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHBsYXlZb3V0dWJlKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFBsYXlzIGEgeW91dHViZSB2aWRlb1xuICAgICovXG5cbiAgICBmdW5jdGlvbiBwbGF5WW91dHViZShlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoJ3tcImV2ZW50XCI6XCJjb21tYW5kXCIsXCJmdW5jXCI6XCJwbGF5VmlkZW9cIixcImFyZ3NcIjpcIlwifScsICcqJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICogU3RvcHMgdmlkZW8gYW5kIGF1ZGlvIGVsZW1lbnRzLlxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHN0b3BNZWRpYShkZXN0aW55KSB7XG4gICAgICB2YXIgcGFuZWwgPSBnZXRTbGlkZU9yU2VjdGlvbihkZXN0aW55KTsgLy9zdG9wcGluZyBIVE1MNSBtZWRpYSBlbGVtZW50c1xuXG4gICAgICAkKCd2aWRlbywgYXVkaW8nLCBwYW5lbCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLWtlZXBwbGF5aW5nJykgJiYgdHlwZW9mIGVsZW1lbnQucGF1c2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlbGVtZW50LnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvL3lvdXR1YmUgdmlkZW9zXG5cbiAgICAgICQoJ2lmcmFtZVtzcmMqPVwieW91dHViZS5jb20vZW1iZWQvXCJdJywgcGFuZWwpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKC95b3V0dWJlXFwuY29tXFwvZW1iZWRcXC8vLnRlc3QoZ2V0QXR0cihlbGVtZW50LCAnc3JjJykpICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1rZWVwcGxheWluZycpKSB7XG4gICAgICAgICAgZWxlbWVudC5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKCd7XCJldmVudFwiOlwiY29tbWFuZFwiLFwiZnVuY1wiOlwicGF1c2VWaWRlb1wiLFwiYXJnc1wiOlwiXCJ9JywgJyonKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgKiBFbmFibGVzIHRoZSBZb3V0dWJlIHZpZGVvcyBBUEkgc28gd2UgY2FuIGNvbnRyb2wgdGhlaXIgZmxvdyBpZiBuZWNlc3NhcnkuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGVuYWJsZVlvdXR1YmVBUEkoKSB7XG4gICAgICAkKCdpZnJhbWVbc3JjKj1cInlvdXR1YmUuY29tL2VtYmVkL1wiXScsIGdldENvbnRhaW5lcigpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGFkZFVSTFBhcmFtKGl0ZW0sICdlbmFibGVqc2FwaT0xJyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBZGRzIGEgbmV3IHBhcmFtZXRlciBhbmQgaXRzIHZhbHVlIHRvIHRoZSBgc3JjYCBvZiBhIGdpdmVuIGVsZW1lbnRcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gYWRkVVJMUGFyYW0oZWxlbWVudCwgbmV3UGFyYW0pIHtcbiAgICAgIHZhciBvcmlnaW5hbFNyYyA9IGdldEF0dHIoZWxlbWVudCwgJ3NyYycpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsIG9yaWdpbmFsU3JjICsgZ2V0VXJsUGFyYW1TaWduKG9yaWdpbmFsU3JjKSArIG5ld1BhcmFtKTtcbiAgICB9XG4gICAgLypcbiAgICAqIFJldHVybnMgdGhlIHByZWZpeCBzaWduIHRvIHVzZSBmb3IgYSBuZXcgcGFyYW1ldGVyIGluIGFuIGV4aXN0ZW4gVVJMLlxuICAgICpcbiAgICAqIEByZXR1cm4ge1N0cmluZ30gID8gfCAmXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gZ2V0VXJsUGFyYW1TaWduKHVybCkge1xuICAgICAgcmV0dXJuICEvXFw/Ly50ZXN0KHVybCkgPyAnPycgOiAnJic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBMYXp5IGxvYWRzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gZWxlbWVudHMuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGxhenlMb2FkKGRlc3RpbnkpIHtcbiAgICAgIGlmICghZ2V0T3B0aW9ucygpLmxhenlMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhbmVsID0gZ2V0U2xpZGVPclNlY3Rpb24oZGVzdGlueSk7XG4gICAgICAkKCdpbWdbZGF0YS1zcmNdLCBpbWdbZGF0YS1zcmNzZXRdLCBzb3VyY2VbZGF0YS1zcmNdLCBzb3VyY2VbZGF0YS1zcmNzZXRdLCB2aWRlb1tkYXRhLXNyY10sIGF1ZGlvW2RhdGEtc3JjXSwgaWZyYW1lW2RhdGEtc3JjXScsIHBhbmVsKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIFsnc3JjJywgJ3NyY3NldCddLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlID0gZ2V0QXR0cihlbGVtZW50LCAnZGF0YS0nICsgdHlwZSk7XG5cbiAgICAgICAgICBpZiAoYXR0cmlidXRlICE9IG51bGwgJiYgYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBzZXRTcmMoZWxlbWVudCwgdHlwZSk7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGVzKGVsZW1lbnQsICdzb3VyY2UnKSkge1xuICAgICAgICAgIHZhciBlbGVtZW50VG9QbGF5ID0gY2xvc2VzdChlbGVtZW50LCAndmlkZW8sIGF1ZGlvJyk7XG5cbiAgICAgICAgICBpZiAoZWxlbWVudFRvUGxheSkge1xuICAgICAgICAgICAgZWxlbWVudFRvUGxheS5sb2FkKCk7XG5cbiAgICAgICAgICAgIGVsZW1lbnRUb1BsYXkub25sb2FkZWRkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBBZGQgZnAtbG9hZGVkIGNsYXNzIHRvIHRoZSBwYW5lbCBhZnRlciBsYXp5IGxvYWRpbmdcblxuICAgICAgYWRkQ2xhc3MocGFuZWwsIExPQURFRCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhenlMb2FkUGFuZWxzKHBhbmVsKSB7XG4gICAgICB2YXIgbGF6eUxvYWRUaHJlc29sZCA9IGdldE9wdGlvbnMoKS5sYXp5TG9hZFRocmVzaG9sZDtcbiAgICAgIGxhenlMb2FkKHBhbmVsLml0ZW0pO1xuXG4gICAgICBpZiAobGF6eUxvYWRUaHJlc29sZCkge1xuICAgICAgICBsYXp5TG9hZERpcmVjdGlvbihwYW5lbCwgJ3ByZXYnLCBsYXp5TG9hZFRocmVzb2xkKTtcbiAgICAgICAgbGF6eUxvYWREaXJlY3Rpb24ocGFuZWwsICduZXh0JywgbGF6eUxvYWRUaHJlc29sZCk7XG4gICAgICB9XG4gICAgfSAvLyBMYXp5IGxvYWQgXCJjb3VudFwiIG51bWJlciBvZiBwYW5lbHMgaW4gYSBzcGVjaWZpYyBkaXJlY3Rpb25cblxuICAgIGZ1bmN0aW9uIGxhenlMb2FkRGlyZWN0aW9uKHN0YXJ0UGFuZWwsIGRpcmVjdGlvbiwgY291bnQpIHtcbiAgICAgIHZhciBjdXJyZW50UGFuZWwgPSBzdGFydFBhbmVsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICYmIChjdXJyZW50UGFuZWwgPSBjdXJyZW50UGFuZWxbZGlyZWN0aW9uXSgpKTsgaSsrKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGN1cnJlbnRQYW5lbC5pdGVtKTtcbiAgICAgICAgbGF6eUxvYWQoY3VycmVudFBhbmVsLml0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogU2V0cyBhIGNsYXNzIGZvciB0aGUgYm9keSBvZiB0aGUgcGFnZSBkZXBlbmRpbmcgb24gdGhlIGFjdGl2ZSBzZWN0aW9uIC8gc2xpZGVcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2V0Qm9keUNsYXNzKCkge1xuICAgICAgdmFyIHNlY3Rpb24gPSBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uaXRlbTtcbiAgICAgIHZhciBzbGlkZSA9IGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5hY3RpdmVTbGlkZTtcbiAgICAgIHZhciBzZWN0aW9uQW5jaG9yID0gZ2V0QW5jaG9yKHNlY3Rpb24pO1xuICAgICAgdmFyIHRleHQgPSBTdHJpbmcoc2VjdGlvbkFuY2hvcik7XG5cbiAgICAgIGlmIChzbGlkZSkge1xuICAgICAgICB2YXIgc2xpZGVBbmNob3IgPSBnZXRBbmNob3Ioc2xpZGUuaXRlbSk7XG4gICAgICAgIHRleHQgPSB0ZXh0ICsgJy0nICsgc2xpZGVBbmNob3I7XG4gICAgICB9IC8vY2hhbmdpbmcgc2xhc2ggZm9yIGRhc2ggdG8gbWFrZSBpdCBhIHZhbGlkIENTUyBzdHlsZVxuXG5cbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoJy8nLCAnLScpLnJlcGxhY2UoJyMnLCAnJykucmVwbGFjZSgvXFxzL2csICcnKTsgLy9yZW1vdmluZyBwcmV2aW91cyBhbmNob3IgY2xhc3Nlc1xuXG4gICAgICB2YXIgY2xhc3NSZSA9IG5ldyBSZWdFeHAoJ1xcXFxiXFxcXHM/JyArIFZJRVdJTkdfUFJFRklYICsgJy1bXlxcXFxzXStcXFxcYicsIFwiZ1wiKTtcbiAgICAgICRib2R5LmNsYXNzTmFtZSA9ICRib2R5LmNsYXNzTmFtZS5yZXBsYWNlKGNsYXNzUmUsICcnKTsgLy9hZGRpbmcgdGhlIGN1cnJlbnQgYW5jaG9yXG5cbiAgICAgIGFkZENsYXNzKCRib2R5LCBWSUVXSU5HX1BSRUZJWCArICctJyArIHRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIGFuY2hvciBmb3IgdGhlIGdpdmVuIHNsaWRlIC8gc2VjdGlvbi4gSXRzIGluZGV4IHdpbGwgYmUgdXNlZCBpZiB0aGVyZSdzIG5vbmUuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldEFuY2hvcihlbGVtZW50KSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmNob3IgPSBnZXRBdHRyKGVsZW1lbnQsICdkYXRhLWFuY2hvcicpO1xuICAgICAgdmFyIGVsZW1lbnRJbmRleCA9IGluZGV4KGVsZW1lbnQpOyAvL1NsaWRlIHdpdGhvdXQgYW5jaG9yIGxpbms/IFdlIHRha2UgdGhlIGluZGV4IGluc3RlYWQuXG5cbiAgICAgIGlmIChhbmNob3IgPT0gbnVsbCkge1xuICAgICAgICBhbmNob3IgPSBlbGVtZW50SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbmNob3I7XG4gICAgfVxuXG4gICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5vbkRlc3Ryb3lBbGwsIG9uRGVzdHJveUFsbCQxKTtcblxuICAgIGZ1bmN0aW9uIG9uRGVzdHJveUFsbCQxKCkge1xuICAgICAgc2V0VXJsSGFzaCgnJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIHdlYnNpdGUgZGVwZW5kaW5nIG9uIHRoZSBhY3RpdmUgc2VjdGlvbi9zbGlkZS5cbiAgICAqIEl0IGNoYW5nZXMgdGhlIFVSTCBoYXNoIHdoZW4gbmVlZGVkIGFuZCB1cGRhdGVzIHRoZSBib2R5IGNsYXNzLlxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHNldFBhZ2VTdGF0dXMoc2xpZGVJbmRleCwgc2xpZGVBbmNob3IsIGFuY2hvckxpbmspIHtcbiAgICAgIHZhciBzZWN0aW9uSGFzaCA9ICcnO1xuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLmFuY2hvcnMubGVuZ3RoICYmICFnZXRPcHRpb25zKCkubG9ja0FuY2hvcnMpIHtcbiAgICAgICAgLy9pc24ndCBpdCB0aGUgZmlyc3Qgc2xpZGU/XG4gICAgICAgIGlmIChzbGlkZUluZGV4KSB7XG4gICAgICAgICAgaWYgKGFuY2hvckxpbmsgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2VjdGlvbkhhc2ggPSBhbmNob3JMaW5rO1xuICAgICAgICAgIH0gLy9zbGlkZSB3aXRob3V0IGFuY2hvciBsaW5rPyBXZSB0YWtlIHRoZSBpbmRleCBpbnN0ZWFkLlxuXG5cbiAgICAgICAgICBpZiAoc2xpZGVBbmNob3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2xpZGVBbmNob3IgPSBzbGlkZUluZGV4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGxhc3RTY3JvbGxlZFNsaWRlOiBzbGlkZUFuY2hvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFVybEhhc2goc2VjdGlvbkhhc2ggKyAnLycgKyBzbGlkZUFuY2hvcik7IC8vZmlyc3Qgc2xpZGUgd29uJ3QgaGF2ZSBzbGlkZSBhbmNob3IsIGp1c3QgdGhlIHNlY3Rpb24gb25lXG4gICAgICAgIH0gZWxzZSBpZiAoc2xpZGVJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgbGFzdFNjcm9sbGVkU2xpZGU6IHNsaWRlQW5jaG9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VXJsSGFzaChhbmNob3JMaW5rKTtcbiAgICAgICAgfSAvL3NlY3Rpb24gd2l0aG91dCBzbGlkZXNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2V0VXJsSGFzaChhbmNob3JMaW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRCb2R5Q2xhc3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXRzIHRoZSBVUkwgaGFzaC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2V0VXJsSGFzaCh1cmwpIHtcbiAgICAgIGlmIChnZXRPcHRpb25zKCkucmVjb3JkSGlzdG9yeSkge1xuICAgICAgICBsb2NhdGlvbi5oYXNoID0gdXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAnIycgKyB1cmwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogR2V0cyB0aGUgbmFtZSBmb3Igc2NyZWVuIHJlYWRlcnMgZm9yIGEgc2VjdGlvbi9zbGlkZSBuYXZpZ2F0aW9uIGJ1bGxldC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0QnVsbGV0TGlua05hbWUoaSwgZGVmYXVsdE5hbWUsIGl0ZW0pIHtcbiAgICAgIHZhciBhbmNob3IgPSBkZWZhdWx0TmFtZSA9PT0gJ1NlY3Rpb24nID8gZ2V0T3B0aW9ucygpLmFuY2hvcnNbaV0gOiBnZXRBdHRyKGl0ZW0sICdkYXRhLWFuY2hvcicpO1xuICAgICAgcmV0dXJuIGVuY29kZVVSSShnZXRPcHRpb25zKCkubmF2aWdhdGlvblRvb2x0aXBzW2ldIHx8IGFuY2hvciB8fCBkZWZhdWx0TmFtZSArICcgJyArIChpICsgMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNsaWRlQnVsbGV0SGFuZGxlcihlKSB7XG4gICAgICAvLyBub3QgYWxsIGV2ZW50cyBhcmUgY2FuY2VsbGFibGUgXG4gICAgICAvLyBodHRwczovL3d3dy51cmlwb3J0cy5jb20vYmxvZy9lYXN5LWZpeC1mb3ItaW50ZXJ2ZW50aW9uLWlnbm9yZWQtYXR0ZW1wdC10by1jYW5jZWwtYS10b3VjaG1vdmUtZXZlbnQtd2l0aC1jYW5jZWxhYmxlLWZhbHNlL1xuICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBzY3JvbGxUcmlnZ2VyOiAnaG9yaXpvbnRhbE5hdidcbiAgICAgIH0pO1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblxuICAgICAgdmFyIHNlY3Rpb25FbGVtID0gY2xvc2VzdCh0aGlzLCBTRUNUSU9OX1NFTCk7XG4gICAgICB2YXIgc2xpZGVzID0gJChTTElERVNfV1JBUFBFUl9TRUwsIGNsb3Nlc3QodGhpcywgU0VDVElPTl9TRUwpKVswXTtcbiAgICAgIHZhciBzZWN0aW9uID0gZ2V0UGFuZWxCeUVsZW1lbnQoZ2V0U3RhdGUoKS5zZWN0aW9ucywgc2VjdGlvbkVsZW0pO1xuICAgICAgdmFyIGRlc3RpbnkgPSBzZWN0aW9uLnNsaWRlc1tpbmRleChjbG9zZXN0KHRoaXMsICdsaScpKV07XG4gICAgICBFdmVudEVtaXR0ZXIuZW1pdChldmVudHMubGFuZHNjYXBlU2Nyb2xsLCB7XG4gICAgICAgIHNsaWRlczogc2xpZGVzLFxuICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGlueS5pdGVtXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXRzIHRoZSBzdGF0ZSBmb3IgdGhlIGhvcml6b250YWwgYnVsbGV0IG5hdmlnYXRpb25zLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBhY3RpdmVTbGlkZXNOYXZpZ2F0aW9uKHNsaWRlc05hdiwgc2xpZGVJbmRleCkge1xuICAgICAgaWYgKGdldE9wdGlvbnMoKS5zbGlkZXNOYXZpZ2F0aW9uICYmIHNsaWRlc05hdiAhPSBudWxsKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKCQoQUNUSVZFX1NFTCwgc2xpZGVzTmF2KSwgQUNUSVZFKTtcbiAgICAgICAgYWRkQ2xhc3MoJCgnYScsICQoJ2xpJywgc2xpZGVzTmF2KVtzbGlkZUluZGV4XSksIEFDVElWRSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhIGxhbmRzY2FwZSBuYXZpZ2F0aW9uIGJhciB3aXRoIGRvdHMgZm9yIGhvcml6b250YWwgc2xpZGVycy5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gYWRkU2xpZGVzTmF2aWdhdGlvbihzZWN0aW9uKSB7XG4gICAgICB2YXIgc2VjdGlvbkVsZW0gPSBzZWN0aW9uLml0ZW07XG4gICAgICB2YXIgbnVtU2xpZGVzID0gc2VjdGlvbi5zbGlkZXMubGVuZ3RoO1xuICAgICAgYXBwZW5kVG8oY3JlYXRlRWxlbWVudEZyb21IVE1MKCc8ZGl2IGNsYXNzPVwiJyArIFNMSURFU19OQVYgKyAnXCI+PHVsPjwvdWw+PC9kaXY+JyksIHNlY3Rpb25FbGVtKTtcbiAgICAgIHZhciBuYXYgPSAkKFNMSURFU19OQVZfU0VMLCBzZWN0aW9uRWxlbSlbMF07IC8vdG9wIG9yIGJvdHRvbVxuXG4gICAgICBhZGRDbGFzcyhuYXYsICdmcC0nICsgZ2V0T3B0aW9ucygpLnNsaWRlc05hdlBvc2l0aW9uKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TbGlkZXM7IGkrKykge1xuICAgICAgICB2YXIgc2xpZGUgPSAkKFNMSURFX1NFTCwgc2VjdGlvbkVsZW0pW2ldO1xuICAgICAgICBhcHBlbmRUbyhjcmVhdGVFbGVtZW50RnJvbUhUTUwoJzxsaT48YSBocmVmPVwiI1wiPjxzcGFuIGNsYXNzPVwiZnAtc3Itb25seVwiPicgKyBnZXRCdWxsZXRMaW5rTmFtZShpLCAnU2xpZGUnLCBzbGlkZSkgKyAnPC9zcGFuPjxzcGFuPjwvc3Bhbj48L2E+PC9saT4nKSwgJCgndWwnLCBuYXYpWzBdKTtcbiAgICAgIH0gLy9jZW50ZXJpbmcgaXRcblxuXG4gICAgICBjc3MobmF2LCB7XG4gICAgICAgICdtYXJnaW4tbGVmdCc6ICctJyArIG5hdi5pbm5lcldpZHRoIC8gMiArICdweCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGFjdGl2ZVNsaWRlSW5kZXggPSBzZWN0aW9uLmFjdGl2ZVNsaWRlID8gc2VjdGlvbi5hY3RpdmVTbGlkZS5pbmRleCgpIDogMDtcbiAgICAgIGFkZENsYXNzKCQoJ2EnLCAkKCdsaScsIG5hdilbYWN0aXZlU2xpZGVJbmRleF0pLCBBQ1RJVkUpO1xuICAgIH1cblxuICAgIHZhciBpc1Njcm9sbEFsbG93ZWQgPSB7fTtcbiAgICBpc1Njcm9sbEFsbG93ZWQubSA9IHtcbiAgICAgICd1cCc6IHRydWUsXG4gICAgICAnZG93bic6IHRydWUsXG4gICAgICAnbGVmdCc6IHRydWUsXG4gICAgICAncmlnaHQnOiB0cnVlXG4gICAgfTtcbiAgICBpc1Njcm9sbEFsbG93ZWQuayA9IGRlZXBFeHRlbmQoe30sIGlzU2Nyb2xsQWxsb3dlZC5tKTtcbiAgICAvKipcbiAgICAqIEFsbG93aW5nIG9yIGRpc2FsbG93aW5nIHRoZSBtb3VzZS9zd2lwZSBzY3JvbGwgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIChub3QgZm9yIGtleWJvYXJkKVxuICAgICogQHBhcmFtIHR5cGUgbSAobW91c2UpIG9yIGsgKGtleWJvYXJkKVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBzZXRJc1Njcm9sbEFsbG93ZWQodmFsdWUsIGRpcmVjdGlvbiwgdHlwZSkge1xuICAgICAgLy91cCwgZG93biwgbGVmdCwgcmlnaHRcbiAgICAgIGlmIChkaXJlY3Rpb24gIT09ICdhbGwnKSB7XG4gICAgICAgIGlzU2Nyb2xsQWxsb3dlZFt0eXBlXVtkaXJlY3Rpb25dID0gdmFsdWU7XG4gICAgICB9IC8vYWxsIGRpcmVjdGlvbnM/XG4gICAgICBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmtleXMoaXNTY3JvbGxBbGxvd2VkW3R5cGVdKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpc1Njcm9sbEFsbG93ZWRbdHlwZV1ba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SXNTY3JvbGxBbGxvd2VkKCkge1xuICAgICAgcmV0dXJuIGlzU2Nyb2xsQWxsb3dlZDtcbiAgICB9XG5cbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uQ2xpY2tPclRvdWNoLCBvbkNsaWNrT3JUb3VjaCQyKTtcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2tPclRvdWNoJDIocGFyYW1zKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gcGFyYW1zLnRhcmdldDtcblxuICAgICAgaWYgKG1hdGNoZXModGFyZ2V0LCBTTElERVNfQVJST1dfU0VMKSB8fCBjbG9zZXN0KHRhcmdldCwgU0xJREVTX0FSUk9XX1NFTCkpIHtcbiAgICAgICAgc2xpZGVBcnJvd0hhbmRsZXIuY2FsbCh0YXJnZXQsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgfSAvL1Njcm9sbGluZyBob3Jpem9udGFsbHkgd2hlbiBjbGlja2luZyBvbiB0aGUgc2xpZGVyIGNvbnRyb2xzLlxuXG5cbiAgICBmdW5jdGlvbiBzbGlkZUFycm93SGFuZGxlcigpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgc2VjdGlvbiA9IGNsb3Nlc3QodGhpcywgU0VDVElPTl9TRUwpO1xuICAgICAgdmFyIGlzUHJldkFycm93ID0gaGFzQ2xhc3ModGhpcywgU0xJREVTX1BSRVYpIHx8IGNsb3Nlc3QodGhpcywgU0xJREVTX1BSRVZfU0VMKTtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cbiAgICAgIGlmIChpc1ByZXZBcnJvdykge1xuICAgICAgICBpZiAoZ2V0SXNTY3JvbGxBbGxvd2VkKCkubS5sZWZ0KSB7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgc2Nyb2xsVHJpZ2dlcjogJ3NsaWRlQXJyb3cnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRzLm1vdmVTbGlkZUxlZnQsIHtcbiAgICAgICAgICAgIHNlY3Rpb246IHNlY3Rpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGdldElzU2Nyb2xsQWxsb3dlZCgpLm0ucmlnaHQpIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBzY3JvbGxUcmlnZ2VyOiAnc2xpZGVBcnJvdydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBFdmVudEVtaXR0ZXIuZW1pdChldmVudHMubW92ZVNsaWRlUmlnaHQsIHtcbiAgICAgICAgICAgIHNlY3Rpb246IHNlY3Rpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIENyZWF0ZXMgdGhlIGNvbnRyb2wgYXJyb3dzIGZvciB0aGUgZ2l2ZW4gc2VjdGlvblxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNsaWRlQXJyb3dzKHNlY3Rpb24pIHtcbiAgICAgIHZhciBzZWN0aW9uRWxlbSA9IHNlY3Rpb24uaXRlbTtcbiAgICAgIHZhciBhcnJvd3MgPSBbY3JlYXRlRWxlbWVudEZyb21IVE1MKGdldE9wdGlvbnMoKS5jb250cm9sQXJyb3dzSFRNTFswXSksIGNyZWF0ZUVsZW1lbnRGcm9tSFRNTChnZXRPcHRpb25zKCkuY29udHJvbEFycm93c0hUTUxbMV0pXTtcbiAgICAgIGFmdGVyKCQoU0xJREVTX1dSQVBQRVJfU0VMLCBzZWN0aW9uRWxlbSlbMF0sIGFycm93cyk7XG4gICAgICBhZGRDbGFzcyhhcnJvd3MsIFNMSURFU19BUlJPVyk7XG4gICAgICBhZGRDbGFzcyhhcnJvd3NbMF0sIFNMSURFU19QUkVWKTtcbiAgICAgIGFkZENsYXNzKGFycm93c1sxXSwgU0xJREVTX05FWFQpO1xuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLmNvbnRyb2xBcnJvd0NvbG9yICE9PSAnI2ZmZicpIHtcbiAgICAgICAgY3NzKCQoU0xJREVTX0FSUk9XX05FWFRfU0VMLCBzZWN0aW9uRWxlbSksIHtcbiAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogJ3RyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICcgKyBnZXRPcHRpb25zKCkuY29udHJvbEFycm93Q29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIGNzcygkKFNMSURFU19BUlJPV19QUkVWX1NFTCwgc2VjdGlvbkVsZW0pLCB7XG4gICAgICAgICAgJ2JvcmRlci1jb2xvcic6ICd0cmFuc3BhcmVudCAnICsgZ2V0T3B0aW9ucygpLmNvbnRyb2xBcnJvd0NvbG9yICsgJyB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2V0T3B0aW9ucygpLmxvb3BIb3Jpem9udGFsKSB7XG4gICAgICAgIGhpZGUoJChTTElERVNfQVJST1dfUFJFVl9TRUwsIHNlY3Rpb25FbGVtKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvZ2dsZUNvbnRyb2xBcnJvd3Modikge1xuICAgICAgaWYgKCFnZXRPcHRpb25zKCkubG9vcEhvcml6b250YWwgJiYgZ2V0T3B0aW9ucygpLmNvbnRyb2xBcnJvd3MpIHtcbiAgICAgICAgLy9oaWRkaW5nIGl0IGZvciB0aGUgZmlzdCBzbGlkZSwgc2hvd2luZyBmb3IgdGhlIHJlc3RcbiAgICAgICAgdG9nZ2xlKCQoU0xJREVTX0FSUk9XX1BSRVZfU0VMLCB2LnNlY3Rpb24pLCB2LnNsaWRlSW5kZXggIT09IDApOyAvL2hpZGRpbmcgaXQgZm9yIHRoZSBsYXN0IHNsaWRlLCBzaG93aW5nIGZvciB0aGUgcmVzdFxuXG4gICAgICAgIHRvZ2dsZSgkKFNMSURFU19BUlJPV19ORVhUX1NFTCwgdi5zZWN0aW9uKSwgbmV4dCh2LmRlc3RpbnkpICE9IG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEZQLnNldFJlY29yZEhpc3RvcnkgPSBzZXRSZWNvcmRIaXN0b3J5O1xuICAgIC8qKlxuICAgICogRGVmaW5lcyB3aGV0ZXIgdG8gcmVjb3JkIHRoZSBoaXN0b3J5IGZvciBlYWNoIGhhc2ggY2hhbmdlIGluIHRoZSBVUkwuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNldFJlY29yZEhpc3RvcnkodmFsdWUsIHR5cGUpIHtcbiAgICAgIHNldFZhcmlhYmxlU3RhdGUoJ3JlY29yZEhpc3RvcnknLCB2YWx1ZSwgdHlwZSk7XG4gICAgfVxuXG4gICAgRlAuc2V0QXV0b1Njcm9sbGluZyA9IHNldEF1dG9TY3JvbGxpbmc7XG4gICAgRlAudGVzdC5zZXRBdXRvU2Nyb2xsaW5nID0gc2V0QXV0b1Njcm9sbGluZztcbiAgICAvKipcbiAgICAqIFNldHMgdGhlIGF1dG9TY3JvbGwgb3B0aW9uLlxuICAgICogSXQgY2hhbmdlcyB0aGUgc2Nyb2xsIGJhciB2aXNpYmlsaXR5IGFuZCB0aGUgaGlzdG9yeSBvZiB0aGUgc2l0ZSBhcyBhIHJlc3VsdC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2V0QXV0b1Njcm9sbGluZyh2YWx1ZSwgdHlwZSkge1xuICAgICAgLy9yZW1vdmluZyB0aGUgdHJhbnNmb3JtYXRpb25cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgc2lsZW50U2Nyb2xsKDApO1xuICAgICAgfVxuXG4gICAgICBzZXRWYXJpYWJsZVN0YXRlKCdhdXRvU2Nyb2xsaW5nJywgdmFsdWUsIHR5cGUpO1xuICAgICAgdmFyIGVsZW1lbnQgPSBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uaXRlbTtcblxuICAgICAgaWYgKGdldE9wdGlvbnMoKS5hdXRvU2Nyb2xsaW5nICYmICFnZXRPcHRpb25zKCkuc2Nyb2xsQmFyKSB7XG4gICAgICAgIGNzcygkaHRtbEJvZHksIHtcbiAgICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAgICAgICAgICAnaGVpZ2h0JzogJzEwMCUnXG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVDbGFzcygkYm9keSwgU0NST0xMQUJMRSk7XG4gICAgICAgIHNldFJlY29yZEhpc3RvcnkoZ2V0T3JpZ2luYWxzKCkucmVjb3JkSGlzdG9yeSwgJ2ludGVybmFsJyk7IC8vZm9yIElFIHRvdWNoIGRldmljZXNcblxuICAgICAgICBjc3MoZ2V0Q29udGFpbmVyKCksIHtcbiAgICAgICAgICAnLW1zLXRvdWNoLWFjdGlvbic6ICdub25lJyxcbiAgICAgICAgICAndG91Y2gtYWN0aW9uJzogJ25vbmUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAvL21vdmluZyB0aGUgY29udGFpbmVyIHVwXG4gICAgICAgICAgc2lsZW50U2Nyb2xsKGVsZW1lbnQub2Zmc2V0VG9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3NzKCRodG1sQm9keSwge1xuICAgICAgICAgICdvdmVyZmxvdyc6ICd2aXNpYmxlJyxcbiAgICAgICAgICAnaGVpZ2h0JzogJ2luaXRpYWwnXG4gICAgICAgIH0pO1xuICAgICAgICBhZGRDbGFzcygkYm9keSwgU0NST0xMQUJMRSk7XG4gICAgICAgIHZhciByZWNvcmRIaXN0b3J5ID0gIWdldE9wdGlvbnMoKS5hdXRvU2Nyb2xsaW5nID8gZmFsc2UgOiBnZXRPcmlnaW5hbHMoKS5yZWNvcmRIaXN0b3J5O1xuICAgICAgICBzZXRSZWNvcmRIaXN0b3J5KHJlY29yZEhpc3RvcnksICdpbnRlcm5hbCcpOyAvL2ZvciBJRSB0b3VjaCBkZXZpY2VzXG5cbiAgICAgICAgY3NzKGdldENvbnRhaW5lcigpLCB7XG4gICAgICAgICAgJy1tcy10b3VjaC1hY3Rpb24nOiAnJyxcbiAgICAgICAgICAndG91Y2gtYWN0aW9uJzogJydcbiAgICAgICAgfSk7IC8vc2Nyb2xsaW5nIHRoZSBwYWdlIHRvIHRoZSBzZWN0aW9uIHdpdGggbm8gYW5pbWF0aW9uXG5cbiAgICAgICAgaWYgKGVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBzY3JvbGxTZXR0aW5ncyA9IGdldFNjcm9sbFNldHRpbmdzKGVsZW1lbnQub2Zmc2V0VG9wKTtcbiAgICAgICAgICBzY3JvbGxTZXR0aW5ncy5lbGVtZW50LnNjcm9sbFRvKDAsIHNjcm9sbFNldHRpbmdzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VG1wUG9zaXRpb24odikge1xuICAgICAgcmV0dXJuIGhhc0NsYXNzKGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtLCBBVVRPX0hFSUdIVCkgPyBnZXREZXN0aW5hdGlvblBvc2l0aW9uKGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtKSA6IGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtLm9mZnNldFRvcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RGVzdGluYXRpb25Qb3NGb3JJbmZpbml0ZVNjcm9sbCh2KSB7XG4gICAgICAvLyBmb3JjaW5nIHRoZSBzY3JvbGwgdG8gdGhlIGJvdHRvbSBvZiB0aGUgZnAtYXV0by1oZWlnaHQgc2VjdGlvbiB3aGVuIHNjcm9sbGluZyB1cFxuICAgICAgaWYgKHYuaXNNb3ZlbWVudFVwICYmIGhhc0NsYXNzKHYuZWxlbWVudCwgQVVUT19IRUlHSFQpKSB7XG4gICAgICAgIHJldHVybiBnZXREZXN0aW5hdGlvblBvc2l0aW9uKHYuZWxlbWVudCkgLSBnZXRXaW5kb3dIZWlnaHQoKSArIHYuZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2LmVsZW1lbnQub2Zmc2V0VG9wO1xuICAgIH1cblxuICAgIC8vQHRzLWNoZWNrXG4gICAgLyoqXG4gICAgKiBBZGRzIHNlY3Rpb25zIGJlZm9yZSBvciBhZnRlciB0aGUgY3VycmVudCBvbmUgdG8gY3JlYXRlIHRoZSBpbmZpbml0ZSBlZmZlY3QuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluZmluaXRlU2VjdGlvbnModikge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpc0RvaW5nQ29udGlub3VzVmVydGljYWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFyIGFjdGl2ZVNlY3Rpb25JdGVtID0gZ2V0U3RhdGUoKS5hY3RpdmVTZWN0aW9uLml0ZW07IC8vIFNjcm9sbGluZyBkb3duXG5cbiAgICAgIGlmICghdi5pc01vdmVtZW50VXApIHtcbiAgICAgICAgLy8gTW92ZSBhbGwgcHJldmlvdXMgc2VjdGlvbnMgdG8gYWZ0ZXIgdGhlIGFjdGl2ZSBzZWN0aW9uXG4gICAgICAgIHZhciBwcmV2U2VjdGlvbnNSZXZlcnNlZCA9IHByZXZBbGwoYWN0aXZlU2VjdGlvbkl0ZW0sIFNFQ1RJT05fU0VMKS5yZXZlcnNlKCk7XG4gICAgICAgIGFmdGVyKGFjdGl2ZVNlY3Rpb25JdGVtLCBwcmV2U2VjdGlvbnNSZXZlcnNlZFswXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTY3JvbGxpbmcgdXBcbiAgICAgICAgLy8gTW92ZSBhbGwgbmV4dCBzZWN0aW9ucyB0byBiZWZvcmUgdGhlIGFjdGl2ZSBzZWN0aW9uXG4gICAgICAgIGJlZm9yZShhY3RpdmVTZWN0aW9uSXRlbSwgbmV4dEFsbChhY3RpdmVTZWN0aW9uSXRlbSwgU0VDVElPTl9TRUwpKTtcbiAgICAgIH0gLy8gTWFpbnRhaW4gdGhlIGRpc3BsYXllZCBwb3NpdGlvbiAobm93IHRoYXQgd2UgY2hhbmdlZCB0aGUgZWxlbWVudCBvcmRlcilcblxuXG4gICAgICBzaWxlbnRTY3JvbGwoZ2V0VG1wUG9zaXRpb24oKSk7IC8vIE1haW50YWluIHRoZSBhY3RpdmUgc2xpZGVzIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0XG5cbiAgICAgIGtlZXBTbGlkZXNQb3NpdGlvbiQxKCk7IC8vIHNhdmUgZm9yIGxhdGVyIHRoZSBlbGVtZW50cyB0aGF0IHN0aWxsIG5lZWQgdG8gYmUgcmVvcmRlcmVkXG5cbiAgICAgIHYud3JhcEFyb3VuZEVsZW1lbnRzID0gYWN0aXZlU2VjdGlvbkl0ZW07IC8vIFJlY2FsY3VsYXRlIGFuaW1hdGlvbiB2YXJpYWJsZXNcblxuICAgICAgdi5kdG9wID0gZ2V0RGVzdGluYXRpb25Qb3NGb3JJbmZpbml0ZVNjcm9sbCh2KTtcbiAgICAgIHYueU1vdmVtZW50ID0gZ2V0WW1vdmVtZW50KGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbiwgdi5lbGVtZW50KTtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICAvKipcbiAgICAqIE1haW50YWlucyB0aGUgYWN0aXZlIHNsaWRlcyBpbiB0aGUgdmlld3BvcnRcbiAgICAqIChCZWNhdXNlIHRoZSBgc2Nyb2xsYCBhbmltYXRpb24gbWlnaHQgZ2V0IGxvc3Qgd2l0aCBzb21lIGFjdGlvbnMsIHN1Y2ggYXMgd2hlbiB1c2luZyBjb250aW51b3VzVmVydGljYWwpXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGtlZXBTbGlkZXNQb3NpdGlvbiQxKCkge1xuICAgICAgdmFyIGFjdGl2ZVNsaWRlcyA9ICQoU0xJREVfQUNUSVZFX1NFTCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aXZlU2xpZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNpbGVudExhbmRzY2FwZVNjcm9sbChhY3RpdmVTbGlkZXNbaV0sICdpbnRlcm5hbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vQHRzLWNoZWNrXG4gICAgLyoqXG4gICAgKiBNYWludGFpbnMgdGhlIGFjdGl2ZSBzbGlkZXMgaW4gdGhlIHZpZXdwb3J0XG4gICAgKiAoQmVjYXVzZSB0aGUgYHNjcm9sbGAgYW5pbWF0aW9uIG1pZ2h0IGdldCBsb3N0IHdpdGggc29tZSBhY3Rpb25zLCBzdWNoIGFzIHdoZW4gdXNpbmcgY29udGludW91c1ZlcnRpY2FsKVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBrZWVwU2xpZGVzUG9zaXRpb24oKSB7XG4gICAgICB2YXIgYWN0aXZlU2xpZGVzID0gJChTTElERV9BQ1RJVkVfU0VMKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmVTbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2lsZW50TGFuZHNjYXBlU2Nyb2xsKGFjdGl2ZVNsaWRlc1tpXSwgJ2ludGVybmFsJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogRml4IHNlY3Rpb24gb3JkZXIgYWZ0ZXIgY29udGludW91c1ZlcnRpY2FsIGNoYW5nZXMgaGF2ZSBiZWVuIGFuaW1hdGVkXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY29udGludW91c1ZlcnRpY2FsRml4U2VjdGlvbk9yZGVyKHYpIHtcbiAgICAgIC8vIElmIGNvbnRpbnVvdXNWZXJ0aWNhbCBpcyBpbiBlZmZlY3QgKGFuZCBhdXRvU2Nyb2xsaW5nIHdvdWxkIGFsc28gYmUgaW4gZWZmZWN0IHRoZW4pLFxuICAgICAgLy8gZmluaXNoIG1vdmluZyB0aGUgZWxlbWVudHMgYXJvdW5kIHNvIHRoZSBkaXJlY3QgbmF2aWdhdGlvbiB3aWxsIGZ1bmN0aW9uIG1vcmUgc2ltcGx5XG4gICAgICBpZiAodi53cmFwQXJvdW5kRWxlbWVudHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh2LmlzTW92ZW1lbnRVcCkge1xuICAgICAgICBiZWZvcmUoJChTRUNUSU9OX1NFTClbMF0sIHYud3JhcEFyb3VuZEVsZW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyKCQoU0VDVElPTl9TRUwpW2dldFN0YXRlKCkuc2VjdGlvbnMubGVuZ3RoIC0gMV0sIHByZXZBbGwodi5lbGVtZW50LCBTRUNUSU9OX1NFTCkucmV2ZXJzZSgpKTtcbiAgICAgIH1cblxuICAgICAgc2lsZW50U2Nyb2xsKGdldFRtcFBvc2l0aW9uKCkpOyAvLyBNYWludGFpbiB0aGUgYWN0aXZlIHNsaWRlcyB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydFxuXG4gICAgICBrZWVwU2xpZGVzUG9zaXRpb24oKTtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgaXNEb2luZ0NvbnRpbm91c1ZlcnRpY2FsOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBNYWtlcyBzdXJlIGxhenlsb2FkIGlzIGRvbmUgZm9yIG90aGVyIHNlY3Rpb25zIGluIHRoZSB2aWV3cG9ydCB0aGF0IGFyZSBub3QgdGhlXG4gICAgKiBhY3RpdmUgb25lLiBcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gbGF6eUxvYWRPdGhlcnMoKSB7XG4gICAgICB2YXIgaGFzQXV0b0hlaWdodFNlY3Rpb25zID0gJChBVVRPX0hFSUdIVF9TRUwpWzBdIHx8IGlzUmVzcG9uc2l2ZU1vZGUoKSAmJiAkKEFVVE9fSEVJR0hUX1JFU1BPTlNJVkVfU0VMKVswXTsgLy9xdWl0dGluZyB3aGVuIGl0IGRvZXNuJ3QgYXBwbHlcblxuICAgICAgaWYgKCFnZXRPcHRpb25zKCkubGF6eUxvYWRpbmcgfHwgIWhhc0F1dG9IZWlnaHRTZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vbWFraW5nIHN1cmUgdG8gbGF6eSBsb2FkIGF1dG8taGVpZ2h0IHNlY3Rpb25zIHRoYXQgYXJlIGluIHRoZSB2aWV3cG9ydFxuXG5cbiAgICAgICQoU0VDVElPTl9TRUwgKyAnOm5vdCgnICsgQUNUSVZFX1NFTCArICcpJykuZm9yRWFjaChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICBpZiAoaXNTZWN0aW9uSW5WaWV3cG9ydChzZWN0aW9uKSkge1xuICAgICAgICAgIGxhenlMb2FkUGFuZWxzKGdldFBhbmVsQnlFbGVtZW50KGdldFN0YXRlKCkuc2VjdGlvbnMsIHNlY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc2VjdGlvbiBpcyBpbiB0aGUgdmlld3BvcnQgb3Igbm90LlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBpc1NlY3Rpb25JblZpZXdwb3J0KGVsKSB7XG4gICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHRvcCA9IHJlY3QudG9wO1xuICAgICAgdmFyIGJvdHRvbSA9IHJlY3QuYm90dG9tOyAvL3NvbWV0aW1lcyB0aGVyZSdzIGEgMXB4IG9mZnNldCBvbiB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gZXZlbiB3aGVuIHRoZSBcbiAgICAgIC8vc2VjdGlvbidzIGhlaWdodCBpcyB0aGUgd2luZG93LmlubmVySGVpZ2h0IG9uZS4gSSBndWVzcyBiZWNhdXNlIHBpeGVscyB3b24ndCBhbGxvdyBkZWNpbWFscy5cbiAgICAgIC8vdXNpbmcgdGhpcyBwcmV2ZW50cyBmcm9tIGxhenlMb2FkaW5nIHRoZSBzZWN0aW9uIHRoYXQgaXMgbm90IHlldCB2aXNpYmxlIFxuICAgICAgLy8ob25seSAxIHBpeGVsIG9mZnNldCBpcylcblxuICAgICAgdmFyIHBpeGVsT2Zmc2V0ID0gMjtcbiAgICAgIHZhciBpc1RvcEluVmlldyA9IHRvcCArIHBpeGVsT2Zmc2V0IDwgc3RhdGUud2luZG93c0hlaWdodCAmJiB0b3AgPiAwO1xuICAgICAgdmFyIGlzQm90dG9tSW5WaWV3ID0gYm90dG9tID4gcGl4ZWxPZmZzZXQgJiYgYm90dG9tIDwgc3RhdGUud2luZG93c0hlaWdodDtcbiAgICAgIHJldHVybiBpc1RvcEluVmlldyB8fCBpc0JvdHRvbUluVmlldztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b29sdGlwVGV4dEhhbmRsZXIoKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdHJpZ2dlcihwcmV2KHRoaXMpLCAnY2xpY2snKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBY3RpdmF0aW5nIHRoZSB2ZXJ0aWNhbCBuYXZpZ2F0aW9uIGJ1bGxldHMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBzbGlkZSBuYW1lLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBhY3RpdmF0ZU5hdkRvdHMobmFtZSwgc2VjdGlvbkluZGV4KSB7XG4gICAgICB2YXIgbmF2ID0gJChTRUNUSU9OX05BVl9TRUwpWzBdO1xuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLm5hdmlnYXRpb24gJiYgbmF2ICE9IG51bGwgJiYgbmF2LnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICByZW1vdmVDbGFzcygkKEFDVElWRV9TRUwsIG5hdiksIEFDVElWRSk7XG5cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICBhZGRDbGFzcygkKCdhW2hyZWY9XCIjJyArIG5hbWUgKyAnXCJdJywgbmF2KSwgQUNUSVZFKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDbGFzcygkKCdhJywgJCgnbGknLCBuYXYpW3NlY3Rpb25JbmRleF0pLCBBQ1RJVkUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhIHZlcnRpY2FsIG5hdmlnYXRpb24gYmFyLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBhZGRWZXJ0aWNhbE5hdmlnYXRpb24oKSB7XG4gICAgICByZW1vdmUoJChTRUNUSU9OX05BVl9TRUwpKTtcbiAgICAgIHZhciBuYXZpZ2F0aW9uID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgbmF2aWdhdGlvbi5zZXRBdHRyaWJ1dGUoJ2lkJywgU0VDVElPTl9OQVYpO1xuICAgICAgdmFyIGRpdlVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICBuYXZpZ2F0aW9uLmFwcGVuZENoaWxkKGRpdlVsKTtcbiAgICAgIGFwcGVuZFRvKG5hdmlnYXRpb24sICRib2R5KTtcbiAgICAgIHZhciBuYXYgPSAkKFNFQ1RJT05fTkFWX1NFTClbMF07XG4gICAgICBhZGRDbGFzcyhuYXYsICdmcC0nICsgZ2V0T3B0aW9ucygpLm5hdmlnYXRpb25Qb3NpdGlvbik7XG5cbiAgICAgIGlmIChnZXRPcHRpb25zKCkuc2hvd0FjdGl2ZVRvb2x0aXApIHtcbiAgICAgICAgYWRkQ2xhc3MobmF2LCBTSE9XX0FDVElWRV9UT09MVElQKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2V0U3RhdGUoKS5zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGdldFN0YXRlKCkuc2VjdGlvbnNbaV07XG4gICAgICAgIHZhciBsaW5rID0gJyc7XG5cbiAgICAgICAgaWYgKGdldE9wdGlvbnMoKS5hbmNob3JzLmxlbmd0aCkge1xuICAgICAgICAgIGxpbmsgPSBzZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpICs9ICc8bGk+PGEgaHJlZj1cIiMnICsgZW5jb2RlVVJJKGxpbmspICsgJ1wiPjxzcGFuIGNsYXNzPVwiZnAtc3Itb25seVwiPicgKyBnZXRCdWxsZXRMaW5rTmFtZShzZWN0aW9uLmluZGV4KCksICdTZWN0aW9uJykgKyAnPC9zcGFuPjxzcGFuPjwvc3Bhbj48L2E+JzsgLy8gT25seSBhZGQgdG9vbHRpcCBpZiBuZWVkZWQgKGRlZmluZWQgYnkgdXNlcilcblxuICAgICAgICB2YXIgdG9vbHRpcCA9IGdldE9wdGlvbnMoKS5uYXZpZ2F0aW9uVG9vbHRpcHNbc2VjdGlvbi5pbmRleCgpXTtcblxuICAgICAgICBpZiAodHlwZW9mIHRvb2x0aXAgIT09ICd1bmRlZmluZWQnICYmIHRvb2x0aXAgIT09ICcnKSB7XG4gICAgICAgICAgbGkgKz0gJzxkaXYgY2xhc3M9XCInICsgU0VDVElPTl9OQVZfVE9PTFRJUCArICcgZnAtJyArIGdldE9wdGlvbnMoKS5uYXZpZ2F0aW9uUG9zaXRpb24gKyAnXCI+JyArIHRvb2x0aXAgKyAnPC9kaXY+JztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpICs9ICc8L2xpPic7XG4gICAgICB9XG5cbiAgICAgICQoJ3VsJywgbmF2KVswXS5pbm5lckhUTUwgPSBsaTsgLy9hY3RpdmF0aW5nIHRoZSBjdXJyZW50IGFjdGl2ZSBzZWN0aW9uXG5cbiAgICAgIHZhciBidWxsZXQgPSAkKCdsaScsICQoU0VDVElPTl9OQVZfU0VMKVswXSlbZ2V0U3RhdGUoKS5hY3RpdmVTZWN0aW9uLmluZGV4KCldO1xuICAgICAgYWRkQ2xhc3MoJCgnYScsIGJ1bGxldCksIEFDVElWRSk7XG4gICAgfSAvL1Njcm9sbHMgdG8gdGhlIHNlY3Rpb24gd2hlbiBjbGlja2luZyB0aGUgbmF2aWdhdGlvbiBidWxsZXRcblxuICAgIGZ1bmN0aW9uIHNlY3Rpb25CdWxsZXRIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHNjcm9sbFRyaWdnZXI6ICd2ZXJ0aWNhbE5hdidcbiAgICAgIH0pO1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIC8vIEB0cy1pZ25vcmVcblxuICAgICAgdmFyIGluZGV4QnVsbGV0ID0gaW5kZXgoY2xvc2VzdCh0aGlzLCBTRUNUSU9OX05BVl9TRUwgKyAnIGxpJykpO1xuICAgICAgRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRzLnNjcm9sbFBhZ2UsIHtcbiAgICAgICAgZGVzdGluYXRpb246IGdldFN0YXRlKCkuc2VjdGlvbnNbaW5kZXhCdWxsZXRdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFNldHMgdG8gYWN0aXZlIHRoZSBjdXJyZW50IG1lbnUgYW5kIHZlcnRpY2FsIG5hdiBpdGVtcy5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gYWN0aXZhdGVNZW51QW5kTmF2KGFuY2hvciwgaW5kZXgpIHtcbiAgICAgIGFjdGl2YXRlTWVudUVsZW1lbnQoYW5jaG9yKTtcbiAgICAgIGFjdGl2YXRlTmF2RG90cyhhbmNob3IsIGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBY3RpdmF0aW5nIHRoZSB3ZWJzaXRlIG1haW4gbWVudSBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHNsaWRlIG5hbWUuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGFjdGl2YXRlTWVudUVsZW1lbnQobmFtZSkge1xuICAgICAgaWYgKGdldE9wdGlvbnMoKS5tZW51ICYmIGdldE9wdGlvbnMoKS5tZW51Lmxlbmd0aCkge1xuICAgICAgICAkKGdldE9wdGlvbnMoKS5tZW51KS5mb3JFYWNoKGZ1bmN0aW9uIChtZW51KSB7XG4gICAgICAgICAgaWYgKG1lbnUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoJChBQ1RJVkVfU0VMLCBtZW51KSwgQUNUSVZFKTtcbiAgICAgICAgICAgIGFkZENsYXNzKCQoJ1tkYXRhLW1lbnVhbmNob3I9XCInICsgbmFtZSArICdcIl0nLCBtZW51KSwgQUNUSVZFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIHRoZSBjYWxsYmFjayBvbmNlIHBlciBzY3JvbGwgd2hlZWwgYWN0aW9uLlxuICAgICAqIEJhc2VkIG9uIHNjcm9sbGluZyBzcGVlZCBkZWxheS5cbiAgICAgKi9cblxuICAgIHZhciBvbmNlUGVyU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhblRyaWdnZXJFdmVudCA9IHRydWU7XG4gICAgICB2YXIgcHJldldoZWVsVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHZhciBpc1Njcm9sbGluZ09uSW5pdCA9ICF3aW4uZnVsbHBhZ2VfYXBpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzY3JvbGxUcmlnZ2VyLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIHRpbWVUaHJlc2hvbGQgPSBzY3JvbGxUcmlnZ2VyID09PSAnd2hlZWwnID8gZ2V0T3B0aW9ucygpLnNjcm9sbGluZ1NwZWVkIDogMTAwO1xuICAgICAgICBjYW5UcmlnZ2VyRXZlbnQgPSBpc1Njcm9sbGluZ09uSW5pdCB8fCBjdXJyZW50VGltZSAtIHByZXZXaGVlbFRpbWUgPj0gdGltZVRocmVzaG9sZDtcbiAgICAgICAgaXNTY3JvbGxpbmdPbkluaXQgPSAhd2luLmZ1bGxwYWdlX2FwaTtcblxuICAgICAgICBpZiAoY2FuVHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2soKTtcbiAgICAgICAgICBwcmV2V2hlZWxUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcgPyByZXN1bHQgOiB0cnVlO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAqIEZpcmVzIHRoZSB3aGVlbCBldmVudCBvbmNlIHBlciBtb3VzZSB3aGVlbCB0cmlnZ2VyLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBmaXJlQ2FsbGJhY2tPbmNlUGVyU2Nyb2xsKGNhbGxiYWNrTmFtZSwgcGFyYW1zKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZ2V0T3B0aW9ucygpLmJlZm9yZUxlYXZlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBvbmNlUGVyU2Nyb2xsKGdldFN0YXRlKCkuc2Nyb2xsVHJpZ2dlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmlyZUNhbGxiYWNrKGNhbGxiYWNrTmFtZSwgcGFyYW1zKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBGUC5tb3ZlVG8gPSBtb3ZlVG87XG5cbiAgICBGUC5nZXRTY3JvbGxZID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLnNjcm9sbFk7XG4gICAgfTtcblxuICAgIHZhciBnX2FmdGVyU2VjdGlvbkxvYWRzSWQ7XG4gICAgdmFyIGdfdHJhbnNpdGlvbkxhcHNlSWQ7XG4gICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5vbkRlc3Ryb3ksIG9uRGVzdHJveSQ4KTtcbiAgICAvKipcbiAgICAqIFNjcm9sbHMgdGhlIHNpdGUgdG8gdGhlIGdpdmVuIGVsZW1lbnQgYW5kIHNjcm9sbHMgdG8gdGhlIHNsaWRlIGlmIGEgY2FsbGJhY2sgaXMgZ2l2ZW4uXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNjcm9sbFBhZ2Uoc2VjdGlvbiwgY2FsbGJhY2ssIGlzTW92ZW1lbnRVcCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzZWN0aW9uLml0ZW07XG5cbiAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvL3RoZXJlJ3Mgbm8gZWxlbWVudCB0byBzY3JvbGwsIGxlYXZpbmcgdGhlIGZ1bmN0aW9uXG5cblxuICAgICAgdmFyIGR0b3AgPSBnZXREZXN0aW5hdGlvblBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgdmFyIHNsaWRlQW5jaG9yTGluaztcbiAgICAgIHZhciBzbGlkZUluZGV4OyAvL2xvY2FsIHZhcmlhYmxlc1xuXG4gICAgICB2YXIgdiA9IHtcbiAgICAgICAgXCJlbGVtZW50XCI6IGVsZW1lbnQsXG4gICAgICAgIFwiY2FsbGJhY2tcIjogY2FsbGJhY2ssXG4gICAgICAgIFwiaXNNb3ZlbWVudFVwXCI6IGlzTW92ZW1lbnRVcCxcbiAgICAgICAgXCJkdG9wXCI6IGR0b3AsXG4gICAgICAgIFwieU1vdmVtZW50XCI6IGdldFltb3ZlbWVudChnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24sIGVsZW1lbnQpLFxuICAgICAgICBcImFuY2hvckxpbmtcIjogc2VjdGlvbi5hbmNob3IsXG4gICAgICAgIFwic2VjdGlvbkluZGV4XCI6IHNlY3Rpb24uaW5kZXgoKSxcbiAgICAgICAgXCJhY3RpdmVTbGlkZVwiOiBzZWN0aW9uLmFjdGl2ZVNsaWRlID8gc2VjdGlvbi5hY3RpdmVTbGlkZS5pdGVtIDogbnVsbCxcbiAgICAgICAgXCJsZWF2aW5nU2VjdGlvblwiOiBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uaW5kZXgoKSArIDEsXG4gICAgICAgIC8vY2FjaGluZyB0aGUgdmFsdWUgb2YgaXNSZXNpemluZyBhdCB0aGUgbW9tbWVudCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkXG4gICAgICAgIC8vYmVjYXVzZSBpdCB3aWxsIGJlIGNoZWNrZWQgbGF0ZXIgaW5zaWRlIGEgc2V0VGltZW91dCBhbmQgdGhlIHZhbHVlIG1pZ2h0IGNoYW5nZVxuICAgICAgICBcImxvY2FsSXNSZXNpemluZ1wiOiBzdGF0ZS5pc1Jlc2l6aW5nLFxuICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICBcIm9yaWdpblwiOiBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24sXG4gICAgICAgICAgXCJkZXN0aW5hdGlvblwiOiBzZWN0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlyZWN0aW9uXCI6IG51bGxcbiAgICAgIH07IC8vcXVpdGluZyB3aGVuIGRlc3RpbmF0aW9uIHNjcm9sbCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBvbmVcblxuICAgICAgaWYgKGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtID09IGVsZW1lbnQgJiYgIXN0YXRlLmlzUmVzaXppbmcgfHwgZ2V0T3B0aW9ucygpLnNjcm9sbEJhciAmJiBnZXRTY3JvbGxUb3AoKSA9PT0gdi5kdG9wICYmICFoYXNDbGFzcyhlbGVtZW50LCBBVVRPX0hFSUdIVCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodi5hY3RpdmVTbGlkZSAhPSBudWxsKSB7XG4gICAgICAgIHNsaWRlQW5jaG9yTGluayA9IGdldEF0dHIodi5hY3RpdmVTbGlkZSwgJ2RhdGEtYW5jaG9yJyk7XG4gICAgICAgIHNsaWRlSW5kZXggPSBpbmRleCh2LmFjdGl2ZVNsaWRlLCBudWxsKTtcbiAgICAgIH0gLy9jYWxsYmFjayAob25MZWF2ZSkgaWYgdGhlIHNpdGUgaXMgbm90IGp1c3QgcmVzaXppbmcgYW5kIHJlYWRqdXN0aW5nIHRoZSBzbGlkZXNcblxuXG4gICAgICBpZiAoIXYubG9jYWxJc1Jlc2l6aW5nKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB2LnlNb3ZlbWVudDsgLy9yZXF1aXJlZCBmb3IgY29udGlub3VzVmVydGljYWxcblxuICAgICAgICBpZiAodHlwZW9mIGlzTW92ZW1lbnRVcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkaXJlY3Rpb24gPSBpc01vdmVtZW50VXAgPyAndXAnIDogJ2Rvd24nO1xuICAgICAgICB9IC8vZm9yIHRoZSBjYWxsYmFja1xuXG5cbiAgICAgICAgdi5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZ2V0T3B0aW9ucygpLmJlZm9yZUxlYXZlKSkge1xuICAgICAgICAgIGlmIChmaXJlQ2FsbGJhY2tPbmNlUGVyU2Nyb2xsKCdiZWZvcmVMZWF2ZScsIHYpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGdldE9wdGlvbnMoKS5vbkxlYXZlKSkge1xuICAgICAgICAgIGlmICghZmlyZUNhbGxiYWNrKCdvbkxlYXZlJywgdikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgY29udGludW91c1ZlcnRpY2FsICYmIHdlIG5lZWQgdG8gd3JhcCBhcm91bmRcblxuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLmF1dG9TY3JvbGxpbmcgJiYgZ2V0T3B0aW9ucygpLmNvbnRpbnVvdXNWZXJ0aWNhbCAmJiB0eXBlb2Ygdi5pc01vdmVtZW50VXAgIT09IFwidW5kZWZpbmVkXCIgJiYgKCF2LmlzTW92ZW1lbnRVcCAmJiB2LnlNb3ZlbWVudCA9PSAndXAnIHx8IC8vIEludGVuZGluZyB0byBzY3JvbGwgZG93biBidXQgYWJvdXQgdG8gZ28gdXAgb3JcbiAgICAgIHYuaXNNb3ZlbWVudFVwICYmIHYueU1vdmVtZW50ID09ICdkb3duJykpIHtcbiAgICAgICAgLy8gaW50ZW5kaW5nIHRvIHNjcm9sbCB1cCBidXQgYWJvdXQgdG8gZ28gZG93blxuICAgICAgICB2ID0gY3JlYXRlSW5maW5pdGVTZWN0aW9ucyh2KTtcbiAgICAgIH0gLy9wYXVzaW5nIG1lZGlhIG9mIHRoZSBsZWF2aW5nIHNlY3Rpb24gKGlmIHdlIGFyZSBub3QganVzdCByZXNpemluZywgYXMgZGVzdGluYXRpbm8gd2lsbCBiZSB0aGUgc2FtZSBvbmUpXG5cblxuICAgICAgaWYgKCF2LmxvY2FsSXNSZXNpemluZykge1xuICAgICAgICBzdG9wTWVkaWEoZ2V0U3RhdGUoKS5hY3RpdmVTZWN0aW9uLml0ZW0pO1xuICAgICAgfVxuXG4gICAgICBhZGRDbGFzcyhlbGVtZW50LCBBQ1RJVkUpO1xuICAgICAgcmVtb3ZlQ2xhc3Moc2libGluZ3MoZWxlbWVudCksIEFDVElWRSk7XG4gICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgbGF6eUxvYWRQYW5lbHMoc2VjdGlvbik7IC8vcHJldmVudGluZyBmcm9tIGFjdGl2YXRpbmcgdGhlIE1vdXNlV2hlZWxIYW5kbGVyIGV2ZW50XG4gICAgICAvL21vcmUgdGhhbiBvbmNlIGlmIHRoZSBwYWdlIGlzIHNjcm9sbGluZ1xuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGNhblNjcm9sbDogRlAudGVzdC5pc1Rlc3RpbmdcbiAgICAgIH0pO1xuICAgICAgc2V0UGFnZVN0YXR1cyhzbGlkZUluZGV4LCBzbGlkZUFuY2hvckxpbmssIHYuYW5jaG9yTGluayk7XG4gICAgICBFdmVudEVtaXR0ZXIuZW1pdChldmVudHMub25MZWF2ZSwgdik7XG4gICAgICBwZXJmb3JtTW92ZW1lbnQodik7IC8vZmxhZyB0byBhdm9pZCBjYWxsaW5nbiBgc2Nyb2xsUGFnZSgpYCB0d2ljZSBpbiBjYXNlIG9mIHVzaW5nIGFuY2hvciBsaW5rc1xuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGxhc3RTY3JvbGxlZERlc3Rpbnk6IHYuYW5jaG9yTGlua1xuICAgICAgfSk7IC8vYXZvaWQgZmlyaW5nIGl0IHR3aWNlIChhcyBpdCBkb2VzIGFsc28gb24gc2Nyb2xsKVxuXG4gICAgICBhY3RpdmF0ZU1lbnVBbmROYXYodi5hbmNob3JMaW5rLCB2LnNlY3Rpb25JbmRleCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EZXN0cm95JDgoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZ19hZnRlclNlY3Rpb25Mb2Fkc0lkKTtcbiAgICAgIGNsZWFyVGltZW91dChnX3RyYW5zaXRpb25MYXBzZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBZIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uIGFuZFxuICAgICogdGhlIGhlaWdodCBvZiB0aGUgc2VjdGlvbi5cbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBnZXREZXN0aW5hdGlvblBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICB2YXIgZWxlbWVudFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wOyAvL3RvcCBvZiB0aGUgZGVzaW5hdGlvbiB3aWxsIGJlIGF0IHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IGVsZW1lbnRUb3A7XG4gICAgICB2YXIgaXNTY3JvbGxpbmdEb3duID0gZWxlbWVudFRvcCA+IHN0YXRlLnByZXZpb3VzRGVzdFRvcDtcbiAgICAgIHZhciBzZWN0aW9uQm90dG9tID0gcG9zaXRpb24gLSBnZXRXaW5kb3dIZWlnaHQoKSArIGVsZW1lbnRIZWlnaHQ7XG4gICAgICB2YXIgYmlnU2VjdGlvbnNEZXN0aW5hdGlvbiA9IGdldE9wdGlvbnMoKS5iaWdTZWN0aW9uc0Rlc3RpbmF0aW9uOyAvL2lzIHRoZSBkZXN0aW5hdGlvbiBlbGVtZW50IGJpZ2dlciB0aGFuIHRoZSB2aWV3cG9ydD9cblxuICAgICAgaWYgKGVsZW1lbnRIZWlnaHQgPiBnZXRXaW5kb3dIZWlnaHQoKSkge1xuICAgICAgICAvL3Njcm9sbGluZyB1cD9cbiAgICAgICAgaWYgKCFpc1Njcm9sbGluZ0Rvd24gJiYgIWJpZ1NlY3Rpb25zRGVzdGluYXRpb24gfHwgYmlnU2VjdGlvbnNEZXN0aW5hdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBwb3NpdGlvbiA9IHNlY3Rpb25Cb3R0b207XG4gICAgICAgIH1cbiAgICAgIH0gLy9zZWN0aW9ucyBlcXVhbCBvciBzbWFsbGVyIHRoYW4gdGhlIHZpZXdwb3J0IGhlaWdodCAmJiBzY3JvbGxpbmcgZG93bj8gfHwgIGlzIHJlc2l6aW5nIGFuZCBpdHMgaW4gdGhlIGxhc3Qgc2VjdGlvblxuICAgICAgZWxzZSBpZiAoaXNTY3JvbGxpbmdEb3duIHx8IHN0YXRlLmlzUmVzaXppbmcgJiYgbmV4dChlbGVtZW50KSA9PSBudWxsKSB7XG4gICAgICAgIC8vVGhlIGJvdHRvbSBvZiB0aGUgZGVzdGluYXRpb24gd2lsbCBiZSBhdCB0aGUgYm90dG9tIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICBwb3NpdGlvbiA9IHNlY3Rpb25Cb3R0b207XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgS2VlcGluZyByZWNvcmQgb2YgdGhlIGxhc3Qgc2Nyb2xsZWQgcG9zaXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgICAgTm8gY29udmVudGlvbmFsIG1ldGhvZHMgY2FuIGJlIHVzZWQgYXMgdGhlIHNjcm9sbCBiYXIgbWlnaHQgbm90IGJlIHByZXNlbnRcbiAgICAgIEFORCB0aGUgc2VjdGlvbiBtaWdodCBub3QgYmUgYWN0aXZlIGlmIGl0IGlzIGF1dG8taGVpZ2h0IGFuZCBkaWRudCByZWFjaCB0aGUgbWlkZGxlXG4gICAgICBvZiB0aGUgdmlld3BvcnQuXG4gICAgICAqL1xuXG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgcHJldmlvdXNEZXN0VG9wOiBwb3NpdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICogUGVyZm9ybXMgdGhlIHZlcnRpY2FsIG1vdmVtZW50IChieSBDU1MzIG9yIGJ5IGpRdWVyeSlcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gcGVyZm9ybU1vdmVtZW50KHYpIHtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgdG91Y2hEaXJlY3Rpb246ICdub25lJyxcbiAgICAgICAgc2Nyb2xsWTogTWF0aC5yb3VuZCh2LmR0b3ApXG4gICAgICB9KTtcbiAgICAgIEV2ZW50RW1pdHRlci5lbWl0KGV2ZW50cy5vblBlcmZvcm1Nb3ZlbWVudCwgdik7XG4gICAgICB2YXIgaXNGYXN0U3BlZWQgPSBnZXRPcHRpb25zKCkuc2Nyb2xsaW5nU3BlZWQgPCA3MDA7XG4gICAgICB2YXIgdHJhbnNpdGlvbkxhcHNlID0gaXNGYXN0U3BlZWQgPyA3MDAgOiBnZXRPcHRpb25zKCkuc2Nyb2xsaW5nU3BlZWQ7IC8vIHVzaW5nIENTUzMgdHJhbnNsYXRlIGZ1bmN0aW9uYWxpdHlcblxuICAgICAgaWYgKGdldE9wdGlvbnMoKS5jc3MzICYmIGdldE9wdGlvbnMoKS5hdXRvU2Nyb2xsaW5nICYmICFnZXRPcHRpb25zKCkuc2Nyb2xsQmFyKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBzZWN0aW9uIGNhbiBoYXZlIGEgbmVnYXRpdmUgdmFsdWUgaW4gaU9TIDEwLiBOb3QgcXVpdGUgc3VyZSB3aHk6IC0wLjAxNDI4MjIyNjU2MjVcbiAgICAgICAgLy8gdGhhdCdzIHdoeSB3ZSByb3VuZCBpdCB0byAwLlxuICAgICAgICB2YXIgdHJhbnNsYXRlM2QgPSAndHJhbnNsYXRlM2QoMHB4LCAtJyArIE1hdGgucm91bmQodi5kdG9wKSArICdweCwgMHB4KSc7XG4gICAgICAgIHRyYW5zZm9ybUNvbnRhaW5lcih0cmFuc2xhdGUzZCwgdHJ1ZSk7IC8vZXZlbiB3aGVuIHRoZSBzY3JvbGxpbmdTcGVlZCBpcyAwIHRoZXJlJ3MgYSBsaXR0bGUgZGVsYXksIHdoaWNoIG1pZ2h0IGNhdXNlIHRoZVxuICAgICAgICAvL3Njcm9sbGluZ1NwZWVkIHRvIGNoYW5nZSBpbiBjYXNlIG9mIHVzaW5nIHNpbGVudE1vdmVUbygpO8OnXG5cbiAgICAgICAgaWYgKGdldE9wdGlvbnMoKS5zY3JvbGxpbmdTcGVlZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChnX2FmdGVyU2VjdGlvbkxvYWRzSWQpO1xuICAgICAgICAgIGdfYWZ0ZXJTZWN0aW9uTG9hZHNJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWZ0ZXJTZWN0aW9uTG9hZHMkMSh2KTsgLy9kaXNhYmxpbmcgY2FuU2Nyb2xsIHdoZW4gdXNpbmcgZmFzdFNwZWVkXG5cbiAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgY2FuU2Nyb2xsOiAhaXNGYXN0U3BlZWQgfHwgRlAudGVzdC5pc1Rlc3RpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGdldE9wdGlvbnMoKS5zY3JvbGxpbmdTcGVlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZ0ZXJTZWN0aW9uTG9hZHMkMSh2KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyB1c2luZyBKUyB0byBhbmltYXRlXG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHNjcm9sbFNldHRpbmdzID0gZ2V0U2Nyb2xsU2V0dGluZ3Modi5kdG9wKTtcbiAgICAgICAgRlAudGVzdC50b3AgPSAtdi5kdG9wICsgJ3B4JztcbiAgICAgICAgY2xlYXJUaW1lb3V0KGdfYWZ0ZXJTZWN0aW9uTG9hZHNJZCk7XG4gICAgICAgIHNjcm9sbFRvKHNjcm9sbFNldHRpbmdzLmVsZW1lbnQsIHNjcm9sbFNldHRpbmdzLm9wdGlvbnMsIGdldE9wdGlvbnMoKS5zY3JvbGxpbmdTcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChnZXRPcHRpb25zKCkuc2Nyb2xsQmFyKSB7XG4gICAgICAgICAgICAvKiBIYWNrIVxuICAgICAgICAgICAgVGhlIHRpbWVvdXQgcHJldmVudHMgc2V0dGluZyB0aGUgbW9zdCBkb21pbmFudCBzZWN0aW9uIGluIHRoZSB2aWV3cG9ydCBhcyBcImFjdGl2ZVwiIHdoZW4gdGhlIHVzZXJcbiAgICAgICAgICAgIHNjcm9sbGVkIHRvIGEgc21hbGxlciBzZWN0aW9uIGJ5IHVzaW5nIHRoZSBtb3VzZXdoZWVsIChhdXRvIHNjcm9sbGluZykgcmF0aGVyIHRoYW4gZHJhZ2luZyB0aGUgc2Nyb2xsIGJhci5cbiAgICAgICAgICAgICBXaGVuIHVzaW5nIHNjcm9sbEJhcjp0cnVlIEl0IHNlZW1zIGxpa2UgdGhlIHNjcm9sbCBldmVudHMgc3RpbGwgZ2V0dGluZyBwcm9wYWdhdGVkIGV2ZW4gYWZ0ZXIgdGhlIHNjcm9sbGluZyBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdfYWZ0ZXJTZWN0aW9uTG9hZHNJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBhZnRlclNlY3Rpb25Mb2FkcyQxKHYpO1xuICAgICAgICAgICAgfSwgMzApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZnRlclNlY3Rpb25Mb2FkcyQxKHYpOyAvL2Rpc2FibGluZyBjYW5TY3JvbGwgd2hlbiB1c2luZyBmYXN0U3BlZWRcblxuICAgICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgICBjYW5TY3JvbGw6ICFpc0Zhc3RTcGVlZCB8fCBGUC50ZXN0LmlzVGVzdGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gZW5hYmxpbmcgY2FuU2Nyb2xsIGFmdGVyIHRoZSBtaW5pbXVtIHRyYW5zaXRpb24gbGFwc1xuXG5cbiAgICAgIGlmIChpc0Zhc3RTcGVlZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZ190cmFuc2l0aW9uTGFwc2VJZCk7XG4gICAgICAgIGdfdHJhbnNpdGlvbkxhcHNlSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBjYW5TY3JvbGw6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdHJhbnNpdGlvbkxhcHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBBY3Rpb25zIHRvIGRvIG9uY2UgdGhlIHNlY3Rpb24gaXMgbG9hZGVkLlxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGFmdGVyU2VjdGlvbkxvYWRzJDEodikge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpc0JleW9uZEZ1bGxwYWdlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjb250aW51b3VzVmVydGljYWxGaXhTZWN0aW9uT3JkZXIodik7IC8vY2FsbGJhY2sgKGFmdGVyTG9hZCkgaWYgdGhlIHNpdGUgaXMgbm90IGp1c3QgcmVzaXppbmcgYW5kIHJlYWRqdXN0aW5nIHRoZSBzbGlkZXNcblxuICAgICAgaWYgKGlzRnVuY3Rpb24oZ2V0T3B0aW9ucygpLmFmdGVyTG9hZCkgJiYgIXYubG9jYWxJc1Jlc2l6aW5nKSB7XG4gICAgICAgIGZpcmVDYWxsYmFjaygnYWZ0ZXJMb2FkJywgdik7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZVN0YXRlKCk7XG5cbiAgICAgIGlmICghdi5sb2NhbElzUmVzaXppbmcpIHtcbiAgICAgICAgcGxheU1lZGlhKHYuZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGFkZENsYXNzKHYuZWxlbWVudCwgQ09NUExFVEVMWSk7XG4gICAgICByZW1vdmVDbGFzcyhzaWJsaW5ncyh2LmVsZW1lbnQpLCBDT01QTEVURUxZKTtcbiAgICAgIGxhenlMb2FkT3RoZXJzKCk7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGNhblNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBFdmVudEVtaXR0ZXIuZW1pdChldmVudHMuYWZ0ZXJTZWN0aW9uTG9hZHMsIHYpO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbih2LmNhbGxiYWNrKSkge1xuICAgICAgICB2LmNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRlAuc2V0Rml0VG9TZWN0aW9uID0gc2V0Rml0VG9TZWN0aW9uO1xuICAgIEZQLmZpdFRvU2VjdGlvbiA9IGZpdFRvU2VjdGlvbjtcbiAgICAvKipcbiAgICAqIFNldHMgZml0VG9TZWN0aW9uXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNldEZpdFRvU2VjdGlvbih2YWx1ZSwgdHlwZSkge1xuICAgICAgc2V0VmFyaWFibGVTdGF0ZSgnZml0VG9TZWN0aW9uJywgdmFsdWUsIHR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEZpdHMgdGhlIHNpdGUgdG8gdGhlIG5lYXJlc3QgYWN0aXZlIHNlY3Rpb25cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gZml0VG9TZWN0aW9uKCkge1xuICAgICAgLy9jaGVja2luZyBmaXRUb1NlY3Rpb24gYWdhaW4gaW4gY2FzZSBpdCB3YXMgc2V0IHRvIGZhbHNlIGJlZm9yZSB0aGUgdGltZW91dCBkZWxheVxuICAgICAgaWYgKHN0YXRlLmNhblNjcm9sbCAmJiBnZXRPcHRpb25zKCkuZml0VG9TZWN0aW9uKSB7XG4gICAgICAgIC8vYWxsb3dzIHRvIHNjcm9sbCB0byBhbiBhY3RpdmUgc2VjdGlvbiBhbmRcbiAgICAgICAgLy9pZiB0aGUgc2VjdGlvbiBpcyBhbHJlYWR5IGFjdGl2ZSwgd2UgcHJldmVudCBmaXJpbmcgY2FsbGJhY2tzXG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc1Jlc2l6aW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBzY3JvbGxQYWdlKHN0YXRlLmFjdGl2ZVNlY3Rpb24pO1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgaXNSZXNpemluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgRlAuc2V0UmVzcG9uc2l2ZSA9IHNldFJlc3BvbnNpdmU7XG4gICAgLyoqXG4gICAgKiBDaGVja3MgaWYgdGhlIHNpdGUgbmVlZHMgdG8gZ2V0IHJlc3BvbnNpdmUgYW5kIGRpc2FibGVzIGF1dG9TY3JvbGxpbmcgaWYgc28uXG4gICAgKiBBIGNsYXNzIGBmcC1yZXNwb25zaXZlYCBpcyBhZGRlZCB0byB0aGUgcGx1Z2luJ3MgY29udGFpbmVyIGluIGNhc2UgdGhlIHVzZXIgd2FudHMgdG8gdXNlIGl0IGZvciBoaXMgb3duIHJlc3BvbnNpdmUgQ1NTLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiByZXNwb25zaXZlKCkge1xuICAgICAgdmFyIHdpZHRoTGltaXQgPSBnZXRPcHRpb25zKCkucmVzcG9uc2l2ZSB8fCBnZXRPcHRpb25zKCkucmVzcG9uc2l2ZVdpZHRoOyAvL2JhY2t3YXJkcyBjb21wYXRpYmxpdHlcblxuICAgICAgdmFyIGhlaWdodExpbWl0ID0gZ2V0T3B0aW9ucygpLnJlc3BvbnNpdmVIZWlnaHQ7IC8vb25seSBjYWxjdWxhdGluZyB3aGF0IHdlIG5lZWQuIFJlbWVtYmVyIGl0cyBjYWxsZWQgb24gdGhlIHJlc2l6ZSBldmVudC5cblxuICAgICAgdmFyIGlzQnJlYWtpbmdQb2ludFdpZHRoID0gd2lkdGhMaW1pdCAmJiB3aW4uaW5uZXJXaWR0aCA8IHdpZHRoTGltaXQ7XG4gICAgICB2YXIgaXNCcmVha2luZ1BvaW50SGVpZ2h0ID0gaGVpZ2h0TGltaXQgJiYgd2luLmlubmVySGVpZ2h0IDwgaGVpZ2h0TGltaXQ7XG5cbiAgICAgIGlmICh3aWR0aExpbWl0ICYmIGhlaWdodExpbWl0KSB7XG4gICAgICAgIHNldFJlc3BvbnNpdmUoaXNCcmVha2luZ1BvaW50V2lkdGggfHwgaXNCcmVha2luZ1BvaW50SGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAod2lkdGhMaW1pdCkge1xuICAgICAgICBzZXRSZXNwb25zaXZlKGlzQnJlYWtpbmdQb2ludFdpZHRoKTtcbiAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0TGltaXQpIHtcbiAgICAgICAgc2V0UmVzcG9uc2l2ZShpc0JyZWFraW5nUG9pbnRIZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIFR1cm5zIGZ1bGxQYWdlLmpzIHRvIG5vcm1hbCBzY3JvbGxpbmcgbW9kZSB3aGVuIHRoZSB2aWV3cG9ydCBgd2lkdGhgIG9yIGBoZWlnaHRgXG4gICAgKiBhcmUgc21hbGxlciB0aGFuIHRoZSBzZXQgbGltaXQgdmFsdWVzLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBzZXRSZXNwb25zaXZlKGFjdGl2ZSkge1xuICAgICAgdmFyIGlzUmVzcG9uc2l2ZSA9IGlzUmVzcG9uc2l2ZU1vZGUoKTtcblxuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBpZiAoIWlzUmVzcG9uc2l2ZSkge1xuICAgICAgICAgIHNldEF1dG9TY3JvbGxpbmcoZmFsc2UsICdpbnRlcm5hbCcpO1xuICAgICAgICAgIHNldEZpdFRvU2VjdGlvbihmYWxzZSwgJ2ludGVybmFsJyk7XG4gICAgICAgICAgaGlkZSgkKFNFQ1RJT05fTkFWX1NFTCkpO1xuICAgICAgICAgIGFkZENsYXNzKCRib2R5LCBSRVNQT05TSVZFKTtcblxuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGdldE9wdGlvbnMoKS5hZnRlclJlc3BvbnNpdmUpKSB7XG4gICAgICAgICAgICBnZXRPcHRpb25zKCkuYWZ0ZXJSZXNwb25zaXZlLmNhbGwoZ2V0Q29udGFpbmVyKCksIGFjdGl2ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUmVzcG9uc2l2ZSkge1xuICAgICAgICBzZXRBdXRvU2Nyb2xsaW5nKGdldE9yaWdpbmFscygpLmF1dG9TY3JvbGxpbmcsICdpbnRlcm5hbCcpO1xuICAgICAgICBzZXRGaXRUb1NlY3Rpb24oZ2V0T3JpZ2luYWxzKCkuYXV0b1Njcm9sbGluZywgJ2ludGVybmFsJyk7XG4gICAgICAgIHNob3coJChTRUNUSU9OX05BVl9TRUwpKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoJGJvZHksIFJFU1BPTlNJVkUpO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGdldE9wdGlvbnMoKS5hZnRlclJlc3BvbnNpdmUpKSB7XG4gICAgICAgICAgZ2V0T3B0aW9ucygpLmFmdGVyUmVzcG9uc2l2ZS5jYWxsKGdldENvbnRhaW5lcigpLCBhY3RpdmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGZ1bGxwYWdlLmpzIGlzIGluIHJlc3BvbnNpdmUgbW9kZSBvciBub3QuXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gaXNSZXNwb25zaXZlTW9kZSgpIHtcbiAgICAgIHJldHVybiBoYXNDbGFzcygkYm9keSwgUkVTUE9OU0lWRSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGFibGVDbGFzcyhlbGVtZW50KSB7XG4gICAgICBpZiAoIWdldE9wdGlvbnMoKS52ZXJ0aWNhbENlbnRlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gT3ZlcmZsb3dpbmcgc2VjdGlvbnMgd2hlbiBzY3JvbGxPdmVyZmxvdyBpcyBkaXNhYmxlZCB3aWxsIGJlIGF1dG9IZWlnaHRcbiAgICAgIC8vIGFuZCB3b24ndCByZXF1aXJlIHZlcnRpY2FsIGFsaWdtZW50XG5cblxuICAgICAgaWYgKCFnZXRPcHRpb25zKCkuc2Nyb2xsT3ZlcmZsb3cgJiYgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLnNob3VsZEJlU2Nyb2xsYWJsZShlbGVtZW50Lml0ZW0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzY3JvbGxPdmVyZmxvd0hhbmRsZXIuaXNTY3JvbGxhYmxlKGVsZW1lbnQpKSB7XG4gICAgICAgIC8vSW4gY2FzZSB3ZSBhcmUgc3R5bGluZyBmb3IgdGhlIDJuZCB0aW1lIGFzIGluIHdpdGggcmVwb25zaXZlU2xpZGVzXG4gICAgICAgIGlmICghaGFzQ2xhc3MoZWxlbWVudC5pdGVtLCBUQUJMRSkpIHtcbiAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50Lml0ZW0sIFRBQkxFKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdGFydGluZ1NlY3Rpb24gPSBudWxsO1xuICAgIEZQLmdldEFjdGl2ZVNlY3Rpb24gPSBnZXRBY3RpdmVTZWN0aW9uO1xuICAgIGZ1bmN0aW9uIGdldFN0YXJ0aW5nU2VjdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGFydGluZ1NlY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICogU3R5bGluZyB2ZXJ0aWNhbCBzZWN0aW9uc1xuICAgICovXG5cbiAgICBmdW5jdGlvbiBzdHlsZVNlY3Rpb24oc2VjdGlvbikge1xuICAgICAgdmFyIHNlY3Rpb25FbGVtID0gc2VjdGlvbi5pdGVtO1xuICAgICAgdmFyIGhhc1NsaWRlcyA9IHNlY3Rpb24uYWxsU2xpZGVzSXRlbXMubGVuZ3RoO1xuICAgICAgdmFyIGluZGV4ID0gc2VjdGlvbi5pbmRleCgpOyAvL2lmIG5vIGFjdGl2ZSBzZWN0aW9uIGlzIGRlZmluZWQsIHRoZSAxc3Qgb25lIHdpbGwgYmUgdGhlIGRlZmF1bHQgb25lXG5cbiAgICAgIGlmICghZ2V0U3RhdGUoKS5hY3RpdmVTZWN0aW9uICYmIHNlY3Rpb24uaXNWaXNpYmxlKSB7XG4gICAgICAgIGFkZENsYXNzKHNlY3Rpb25FbGVtLCBBQ1RJVkUpO1xuICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0YXJ0aW5nU2VjdGlvbiAmJiBzZWN0aW9uLmlzVmlzaWJsZSkge1xuICAgICAgICBzdGFydGluZ1NlY3Rpb24gPSBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uaXRlbTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldE9wdGlvbnMoKS5wYWRkaW5nVG9wKSB7XG4gICAgICAgIGNzcyhzZWN0aW9uRWxlbSwge1xuICAgICAgICAgICdwYWRkaW5nLXRvcCc6IGdldE9wdGlvbnMoKS5wYWRkaW5nVG9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLnBhZGRpbmdCb3R0b20pIHtcbiAgICAgICAgY3NzKHNlY3Rpb25FbGVtLCB7XG4gICAgICAgICAgJ3BhZGRpbmctYm90dG9tJzogZ2V0T3B0aW9ucygpLnBhZGRpbmdCb3R0b21cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZ2V0T3B0aW9ucygpLnNlY3Rpb25zQ29sb3JbaW5kZXhdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjc3Moc2VjdGlvbkVsZW0sIHtcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IGdldE9wdGlvbnMoKS5zZWN0aW9uc0NvbG9yW2luZGV4XVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBnZXRPcHRpb25zKCkuYW5jaG9yc1tpbmRleF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlY3Rpb25FbGVtLnNldEF0dHJpYnV0ZSgnZGF0YS1hbmNob3InLCBzZWN0aW9uLmFuY2hvcik7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzU2xpZGVzKSB7XG4gICAgICAgIGFkZFRhYmxlQ2xhc3Moc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogR2V0cyB0aGUgYWN0aXZlIHNlY3Rpb24uXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldEFjdGl2ZVNlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0U3RhdGUoKS5hY3RpdmVTZWN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Gcm9tUGFuZWwocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5pc1NlY3Rpb24gPyBwYW5lbCA6IHBhbmVsLnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgZ19mb2N1c1Njcm9sbGFibGVJZDtcbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLmJpbmRFdmVudHMsIGJpbmRFdmVudHMkYik7XG5cbiAgICBmdW5jdGlvbiBiaW5kRXZlbnRzJGIoKSB7XG4gICAgICAvLyBXZSBjYW4ndCBmb2N1cyBzY3JvbGxPdmVyZmxvdyBiZWZvcmUgc2Nyb2xsaW5nXG4gICAgICAvLyB0byB0aGUgYW5jaG9yIChpZiB3ZSBuZWVkIHRvKVxuICAgICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5vbkFmdGVyUmVuZGVyTm9BbmNob3IsIGFmdGVyUmVuZGVyKTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMub25MZWF2ZSwgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLm9uTGVhdmUpO1xuICAgICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5vblNsaWRlTGVhdmUsIHNjcm9sbE92ZXJmbG93SGFuZGxlci5vbkxlYXZlKTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYWZ0ZXJTbGlkZUxvYWRzLCBzY3JvbGxPdmVyZmxvd0hhbmRsZXIuYWZ0ZXJMb2FkKTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYWZ0ZXJTZWN0aW9uTG9hZHMsIHNjcm9sbE92ZXJmbG93SGFuZGxlci5hZnRlckxvYWQpO1xuICAgICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5vbkRlc3Ryb3ksIG9uRGVzdHJveSQ3KTtcbiAgICAgIGRvY0FkZEV2ZW50KCdrZXl1cCcsIHNjcm9sbE92ZXJmbG93SGFuZGxlci5rZXlVcEhhbmRsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFmdGVyUmVuZGVyKCkge1xuICAgICAgaWYgKGdldE9wdGlvbnMoKS5zY3JvbGxPdmVyZmxvdyAmJiAhZ2V0T3B0aW9ucygpLnNjcm9sbEJhcikge1xuICAgICAgICBzY3JvbGxPdmVyZmxvd0hhbmRsZXIubWFrZVNjcm9sbGFibGUoKTtcbiAgICAgICAgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLmZvY3VzU2Nyb2xsYWJsZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRGVzdHJveSQ3KCkge1xuICAgICAgRXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50cy5vbkFmdGVyUmVuZGVyTm9BbmNob3IsIGFmdGVyUmVuZGVyKTtcbiAgICAgIGRvY1JlbW92ZUV2ZW50KCdrZXl1cCcsIHNjcm9sbE92ZXJmbG93SGFuZGxlci5rZXlVcEhhbmRsZXIpO1xuICAgIH1cblxuICAgIHZhciBzY3JvbGxPdmVyZmxvd0hhbmRsZXIgPSB7XG4gICAgICBmb2N1c2VkRWxlbTogbnVsbCxcbiAgICAgIHNob3VsZEZvY3VzU2Nyb2xsYWJsZTogdHJ1ZSxcbiAgICAgIGlzSW5uZXJTY3JvbGxBbGxvd2VkOiB0cnVlLFxuICAgICAgdGltZUJlZm9yZVJlYWNoaW5nTGltaXQ6IG51bGwsXG4gICAgICB0aW1lTGFzdFNjcm9sbDogbnVsbCxcbiAgICAgIHByZXZlbnRTY3JvbGxXaXRoTW91c2VXaGVlbDogZnVuY3Rpb24gcHJldmVudFNjcm9sbFdpdGhNb3VzZVdoZWVsKGUpIHtcbiAgICAgICAgdmFyIGFjdGl2ZVNlY3Rpb24gPSBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb247XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5jYW5TY3JvbGwgfHwgaXNJbnNpZGVJZnJhbWUoKSAmJiBnZXRPcHRpb25zKCkuc2Nyb2xsT3ZlcmZsb3cgJiYgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLmlzU2Nyb2xsYWJsZShhY3RpdmVTZWN0aW9uKSAmJiBzY3JvbGxPdmVyZmxvd0hhbmRsZXIuaXNTY3JvbGxlZChnZXRTdGF0ZSgpLndoZWVsRGlyZWN0aW9uLCBhY3RpdmVTZWN0aW9uLml0ZW0pKSB7XG4gICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJldmVudFNjcm9sbFdpdGhLZXlib2FyZDogZnVuY3Rpb24gcHJldmVudFNjcm9sbFdpdGhLZXlib2FyZChlKSB7XG4gICAgICAgIGlmICghaXNJbnNpZGVJbnB1dCgpICYmIGdldE9wdGlvbnMoKS5rZXlib2FyZFNjcm9sbGluZykge1xuICAgICAgICAgIHZhciBkaXJlY3Rpb25LZXlzID0gWzM4LCAzMywgMzIsIDQwLCAzNCwgMzYsIDM1XTtcblxuICAgICAgICAgIGlmIChkaXJlY3Rpb25LZXlzLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xICYmICFzY3JvbGxPdmVyZmxvd0hhbmRsZXIuaXNJbm5lclNjcm9sbEFsbG93ZWQpIHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGtleVVwSGFuZGxlcjogZnVuY3Rpb24ga2V5VXBIYW5kbGVyKCkge1xuICAgICAgICBzY3JvbGxPdmVyZmxvd0hhbmRsZXIuc2hvdWxkRm9jdXNTY3JvbGxhYmxlID0gc3RhdGUuY2FuU2Nyb2xsO1xuICAgICAgfSxcbiAgICAgIC8vIExlYXZpbmcgc2VjdGlvbnMgb3Igc2xpZGVzXG4gICAgICBvbkxlYXZlOiBmdW5jdGlvbiBvbkxlYXZlKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZ19mb2N1c1Njcm9sbGFibGVJZCk7XG4gICAgICAgIHNjcm9sbE92ZXJmbG93SGFuZGxlci5pc0lubmVyU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIC8vIExvYWRpbmcgc2VjdGlvbnMgb3Igc2xpZGVzXG4gICAgICBhZnRlckxvYWQ6IGZ1bmN0aW9uIGFmdGVyTG9hZCgpIHtcbiAgICAgICAgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLmlzSW5uZXJTY3JvbGxBbGxvd2VkID0gZmFsc2U7IC8vIERlbGF5aW5nIGl0IHRvIGF2b2lkIGlzc3VlcyBvbiBTYWZhcmkgd2hlbiBmb2N1c2luZyBlbGVtZW50cyAjNDQ4NCAmICM0NDkzXG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KGdfZm9jdXNTY3JvbGxhYmxlSWQpO1xuICAgICAgICBnX2ZvY3VzU2Nyb2xsYWJsZUlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLnNob3VsZEZvY3VzU2Nyb2xsYWJsZSA9IHN0YXRlLmNhblNjcm9sbDtcbiAgICAgICAgfSwgMjAwKTtcbiAgICAgIH0sXG4gICAgICAvLyBVbmZvY3VzaW5nIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgZnJvbSB0aGUgb3JnaW4gc2VjdGlvbi9zbGlkZVxuICAgICAgdW5mb2N1c1Njcm9sbGFibGU6IGZ1bmN0aW9uIHVuZm9jdXNTY3JvbGxhYmxlKCkge1xuICAgICAgICBpZiAoZG9jLmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuZm9jdXNlZEVsZW0pIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhpcy5mb2N1c2VkRWxlbS5ibHVyKCk7XG4gICAgICAgICAgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLmlzSW5uZXJTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmb2N1c1Njcm9sbGFibGU6IGZ1bmN0aW9uIGZvY3VzU2Nyb2xsYWJsZSgpIHtcbiAgICAgICAgaWYgKCFnZXRPcHRpb25zKCkuc2Nyb2xsT3ZlcmZsb3cgfHwgIXNjcm9sbE92ZXJmbG93SGFuZGxlci5zaG91bGRGb2N1c1Njcm9sbGFibGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGxPdmVyZmxvd0hhbmRsZXIudW5mb2N1c1Njcm9sbGFibGUoKTtcbiAgICAgICAgdmFyIHNjcm9sbGFibGVJdGVtID0gc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLmdldFNjcm9sbGFibGVJdGVtKGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtKTsgLy8gT24gZGVza3RvcCB3ZSBmb2N1cyB0aGUgc2Nyb2xsYWJsZSB0byBiZSBhYmxlIHRvIHVzZSB0aGUgbW91c2Ugd2hlZWxcbiAgICAgICAgLy8gV2UgYXZvaWQgaXQgb24gbW9iaWxlIGR1ZSB0byBhIGJ1ZyBpbiBpT1MgU2FmYXJpXG5cbiAgICAgICAgaWYgKHNjcm9sbGFibGVJdGVtICYmICFpc1RvdWNoRGV2aWNlICYmICFpc1RvdWNoKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c2VkRWxlbSA9IHNjcm9sbGFibGVJdGVtOyAvLyBGb3JjaW5nIHRoZSBmb2N1cyBvbiB0aGUgbmV4dCBwYWludCBcbiAgICAgICAgICAvLyB0byBhdm9pZCBpc3N1ZSAjNDQ4NCAmICM0NDkzIG9uIFNhZmFyaVxuXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjcm9sbGFibGVJdGVtLmZvY3VzKHtcbiAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY3JvbGxPdmVyZmxvd0hhbmRsZXIuaXNJbm5lclNjcm9sbEFsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLnNob3VsZEZvY3VzU2Nyb2xsYWJsZSA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIG1ha2VTY3JvbGxhYmxlOiBmdW5jdGlvbiBtYWtlU2Nyb2xsYWJsZSgpIHtcbiAgICAgICAgaWYgKGdldE9wdGlvbnMoKS5zY3JvbGxPdmVyZmxvd01hY1N0eWxlICYmICFpc01hY0RldmljZSkge1xuICAgICAgICAgIGFkZENsYXNzKCRib2R5LCAnZnAtc2Nyb2xsLW1hYycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0U3RhdGUoKS5wYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBpZiAoZWwuc2xpZGVzICYmIGVsLnNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzQ2xhc3MoZWwuaXRlbSwgQVVUT19IRUlHSFRfUkVTUE9OU0lWRSkgJiYgaXNSZXNwb25zaXZlTW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0U2xpZGVPclNlY3Rpb24oZWwuaXRlbSk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkQmVTY3JvbGxhYmxlID0gc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLnNob3VsZEJlU2Nyb2xsYWJsZShlbC5pdGVtKTtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gZ2V0U2VjdGlvbkZyb21QYW5lbChlbCk7XG5cbiAgICAgICAgICAgIGlmIChpc0lFMTEpIHtcbiAgICAgICAgICAgICAgdmFyIHRvZ2dsZUFjdGlvbiA9IHNob3VsZEJlU2Nyb2xsYWJsZSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnO1xuICAgICAgICAgICAgICB1dGlsc1t0b2dnbGVBY3Rpb25dKHNlY3Rpb24uaXRlbSwgSVNfT1ZFUkZMT1cpO1xuICAgICAgICAgICAgICB1dGlsc1t0b2dnbGVBY3Rpb25dKGVsLml0ZW0sIElTX09WRVJGTE9XKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZENsYXNzKHNlY3Rpb24uaXRlbSwgSVNfT1ZFUkZMT1cpO1xuICAgICAgICAgICAgICBhZGRDbGFzcyhlbC5pdGVtLCBJU19PVkVSRkxPVyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZWwuaGFzU2Nyb2xsKSB7XG4gICAgICAgICAgICAgIHNjcm9sbE92ZXJmbG93SGFuZGxlci5jcmVhdGVXcmFwcGVyKGl0ZW0pO1xuICAgICAgICAgICAgICBzY3JvbGxPdmVyZmxvd0hhbmRsZXIuYmluZEV2ZW50cyhpdGVtKTtcbiAgICAgICAgICAgIH0gLy8gdXBkYXRpbmcgdGhlIHN0YXRlIG5vdyBpbiBjYXNlIFxuICAgICAgICAgICAgLy8gdGhpcyBpcyBleGVjdXRlZCBvbiBwYWdlIGxvYWQgKGFmdGVyIGltYWdlcyBsb2FkKVxuXG5cbiAgICAgICAgICAgIGVsLmhhc1Njcm9sbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBiaW5kRXZlbnRzOiBmdW5jdGlvbiBiaW5kRXZlbnRzKGl0ZW0pIHtcbiAgICAgICAgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLmdldFNjcm9sbGFibGVJdGVtKGl0ZW0pLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNjcm9sbE92ZXJmbG93SGFuZGxlci5vblBhbmVsU2Nyb2xsKTtcbiAgICAgICAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHNjcm9sbE92ZXJmbG93SGFuZGxlci5wcmV2ZW50U2Nyb2xsV2l0aE1vdXNlV2hlZWwsIHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgaXRlbS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLnByZXZlbnRTY3JvbGxXaXRoS2V5Ym9hcmQsIHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjcmVhdGVXcmFwcGVyOiBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGl0ZW0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93V3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBvdmVyZmxvd1dyYXBwZXIuY2xhc3NOYW1lID0gT1ZFUkZMT1c7XG4gICAgICAgIHdyYXBJbm5lcihpdGVtLCBvdmVyZmxvd1dyYXBwZXIpO1xuICAgICAgICBvdmVyZmxvd1dyYXBwZXIuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3lXcmFwcGVyOiBmdW5jdGlvbiBkZXN0cm95V3JhcHBlcihpdGVtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvd1dyYXBwZXIgPSAkKE9WRVJGTE9XX1NFTCwgaXRlbSlbMF07XG5cbiAgICAgICAgaWYgKG92ZXJmbG93V3JhcHBlcikge1xuICAgICAgICAgIHVud3JhcChvdmVyZmxvd1dyYXBwZXIpO1xuICAgICAgICAgIGl0ZW0ucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0U2Nyb2xsYWJsZUl0ZW06IGZ1bmN0aW9uIGdldFNjcm9sbGFibGVJdGVtKHNlY3Rpb25JdGVtKSB7XG4gICAgICAgIHZhciBwYW5lbCA9IGdldFNsaWRlT3JTZWN0aW9uKHNlY3Rpb25JdGVtKTtcbiAgICAgICAgcmV0dXJuICQoT1ZFUkZMT1dfU0VMLCBwYW5lbClbMF0gfHwgcGFuZWw7XG4gICAgICB9LFxuICAgICAgaGFzU2Nyb2xsOiBmdW5jdGlvbiBoYXNTY3JvbGwocGFuZWxJdGVtKSB7XG4gICAgICAgIHJldHVybiBoYXNDbGFzcyhwYW5lbEl0ZW0sIE9WRVJGTE9XKSB8fCAkKE9WRVJGTE9XX1NFTCwgcGFuZWxJdGVtKVswXSAhPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGlzU2Nyb2xsYWJsZTogZnVuY3Rpb24gaXNTY3JvbGxhYmxlKHBhbmVsKSB7XG4gICAgICAgIHJldHVybiBwYW5lbC5pc1NlY3Rpb24gJiYgcGFuZWwuYWN0aXZlU2xpZGUgPyBwYW5lbC5hY3RpdmVTbGlkZS5oYXNTY3JvbGwgOiBwYW5lbC5oYXNTY3JvbGw7XG4gICAgICB9LFxuICAgICAgc2hvdWxkQmVTY3JvbGxhYmxlOiBmdW5jdGlvbiBzaG91bGRCZVNjcm9sbGFibGUoaXRlbSkge1xuICAgICAgICB2YXIgc2Nyb2xsYWJsZSA9IHNjcm9sbE92ZXJmbG93SGFuZGxlci5nZXRTY3JvbGxhYmxlSXRlbShpdGVtKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0ID4gd2luLmlubmVySGVpZ2h0O1xuICAgICAgfSxcbiAgICAgIGlzU2Nyb2xsZWQ6IGZ1bmN0aW9uIGlzU2Nyb2xsZWQoZGlyZWN0aW9uLCBlbCkge1xuICAgICAgICBpZiAoIXN0YXRlLmNhblNjcm9sbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSAvLyB3ZSB3b24ndCBhbGxvdyBzY3JvbGxvdmVyZmxvdyBvbiBzY3JvbGxCYXI6dHJ1ZVxuXG5cbiAgICAgICAgaWYgKGdldE9wdGlvbnMoKS5zY3JvbGxCYXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY3JvbGxhYmxlSXRlbSA9IHNjcm9sbE92ZXJmbG93SGFuZGxlci5nZXRTY3JvbGxhYmxlSXRlbShlbCk7XG5cbiAgICAgICAgaWYgKCFnZXRPcHRpb25zKCkuc2Nyb2xsT3ZlcmZsb3cgfHwgIWhhc0NsYXNzKHNjcm9sbGFibGVJdGVtLCBPVkVSRkxPVykgfHwgLy8gQ2hlY2tpbmcgdGhlIHNlY3Rpb24gZmlyc3QgXG4gICAgICAgIC8vIEluIGNhc2UgdGhleSBhcHBseSB0byBib3RoIHNlY3Rpb24gKyBzbGlkZSAjNDUwNVxuICAgICAgICBoYXNDbGFzcyhlbCwgJ2ZwLW5vc2Nyb2xsJykgfHwgLy8gQ2hlY2tpbmcgdGhlIHNsaWRlIChpbiBjYXNlIGl0IGhhcylcbiAgICAgICAgaGFzQ2xhc3MoZ2V0U2xpZGVPclNlY3Rpb24oZWwpLCAnZnAtbm9zY3JvbGwnKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIGllMTEgd3JvbmdseSBjYWxjdWxhdGVzIHNjcm9sbEhlaWdodCB3aGVuIHVzaW5nIHRoZSBDU1Mgc3R5bGVcbiAgICAgICAgLy8gb3ZlcmZsb3c6IGF1dG8gICBJdCBhZGRzIDEgbW9yZSBwaXhlbCBjb21wYXJlZCB0byBvZmZzZXRIZWlnaHRcblxuXG4gICAgICAgIHZhciBpZTExb2Zmc2V0ID0gaXNJRTExID8gMSA6IDA7XG4gICAgICAgIHZhciBwb3NpdGlvblkgPSBzY3JvbGxhYmxlSXRlbS5zY3JvbGxUb3A7XG4gICAgICAgIHZhciBpc1RvcFJlYWNoZWQgPSBkaXJlY3Rpb24gPT09ICd1cCcgJiYgcG9zaXRpb25ZIDw9IDA7XG4gICAgICAgIHZhciBpc0JvdHRvbVJlYWNoZWQgPSBkaXJlY3Rpb24gPT09ICdkb3duJyAmJiBzY3JvbGxhYmxlSXRlbS5zY3JvbGxIZWlnaHQgPD0gTWF0aC5jZWlsKHNjcm9sbGFibGVJdGVtLm9mZnNldEhlaWdodCArIHBvc2l0aW9uWSkgKyBpZTExb2Zmc2V0O1xuICAgICAgICB2YXIgaXNTY3JvbGxlZCA9IGlzVG9wUmVhY2hlZCB8fCBpc0JvdHRvbVJlYWNoZWQ7XG5cbiAgICAgICAgaWYgKCFpc1Njcm9sbGVkICYmIGRpcmVjdGlvbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgdGhpcy50aW1lQmVmb3JlUmVhY2hpbmdMaW1pdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzU2Nyb2xsZWQ7XG4gICAgICB9LFxuICAgICAgc2hvdWxkTW92ZVBhZ2U6IGZ1bmN0aW9uIHNob3VsZE1vdmVQYWdlKCkge1xuICAgICAgICB0aGlzLnRpbWVMYXN0U2Nyb2xsID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciB0aW1lRGlmZiA9IHRoaXMudGltZUxhc3RTY3JvbGwgLSBzY3JvbGxPdmVyZmxvd0hhbmRsZXIudGltZUJlZm9yZVJlYWNoaW5nTGltaXQ7XG4gICAgICAgIHZhciBpc1VzaW5nVG91Y2ggPSBpc1RvdWNoRGV2aWNlIHx8IGlzVG91Y2g7XG4gICAgICAgIHZhciBpc0dyYWJiaW5nID0gaXNVc2luZ1RvdWNoICYmIHN0YXRlLmlzR3JhYmJpbmc7XG4gICAgICAgIHZhciBpc05vdEZpcnN0VGltZVJlYWNoaW5nTGltaXQgPSBzdGF0ZS5pc1VzaW5nV2hlZWwgJiYgdGltZURpZmYgPiA2MDA7XG4gICAgICAgIHJldHVybiBpc0dyYWJiaW5nICYmIHRpbWVEaWZmID4gNDAwIHx8IGlzTm90Rmlyc3RUaW1lUmVhY2hpbmdMaW1pdDtcbiAgICAgIH0sXG4gICAgICBvblBhbmVsU2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2UG9zaXRpb24gPSAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gZS50YXJnZXQuc2Nyb2xsVG9wO1xuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBzdGF0ZS50b3VjaERpcmVjdGlvbiAhPT0gJ25vbmUnID8gc3RhdGUudG91Y2hEaXJlY3Rpb24gOiBwcmV2UG9zaXRpb24gPCBjdXJyZW50UG9zaXRpb24gPyAnZG93bicgOiAndXAnO1xuICAgICAgICAgIHByZXZQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGdldE9wdGlvbnMoKS5vblNjcm9sbE92ZXJmbG93KSkge1xuICAgICAgICAgICAgZmlyZUNhbGxiYWNrKCdvblNjcm9sbE92ZXJmbG93Jywge1xuICAgICAgICAgICAgICBwb3NpdGlvbjogY3VycmVudFBvc2l0aW9uLFxuICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc0NsYXNzKGUudGFyZ2V0LCBPVkVSRkxPVykgJiYgc3RhdGUuY2FuU2Nyb2xsKSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLmlzU2Nyb2xsZWQoZGlyZWN0aW9uLCBlLnRhcmdldCkgJiYgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLnNob3VsZE1vdmVQYWdlKCkpIHtcbiAgICAgICAgICAgICAgLy8gQ2hlY2tpbmcgYWdhaW4gaWYgd2UgaGF2ZSBhIHNjcm9sbGFibGUgY29udGVudFxuICAgICAgICAgICAgICAvLyBUbyBhdm9pZCBpc3N1ZXMgbGlrZSAjNDQ3OSB3aGVyZSB0aGUgc2Nyb2xsIGV2ZW50IGdldHNcbiAgICAgICAgICAgICAgLy8gdHJpZ2dlcmVkIGFmdGVyIHJlbW92aW5nL2hpZGRpbmcgY29udGVudCBpZiB0aGlzIHdhcyBzY3JvbGxlZFxuICAgICAgICAgICAgICBpZiAoc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLnNob3VsZEJlU2Nyb2xsYWJsZShnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBFdmVudEVtaXR0ZXIuZW1pdChldmVudHMub25TY3JvbGxPdmVyZmxvd1Njcm9sbGVkLCB7XG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSgpXG4gICAgfTtcblxuICAgIHZhciBnX2FmdGVyU2xpZGVMb2Fkc0lkO1xuICAgIEZQLmxhbmRzY2FwZVNjcm9sbCA9IGxhbmRzY2FwZVNjcm9sbDtcbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLmJpbmRFdmVudHMsIGJpbmRFdmVudHMkYSk7XG5cbiAgICBmdW5jdGlvbiBiaW5kRXZlbnRzJGEoKSB7XG4gICAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uUGVyZm9ybU1vdmVtZW50LCBvblBlcmZvcm1Nb3ZlbWVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25QZXJmb3JtTW92ZW1lbnQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZ19hZnRlclNsaWRlTG9hZHNJZCk7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHNsaWRlTW92aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogU2Nyb2xscyBob3Jpem9udGFsIHNsaWRlcnMuXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gbGFuZHNjYXBlU2Nyb2xsKHNsaWRlcywgZGVzdGlueSwgZGlyZWN0aW9uKSB7XG4gICAgICB2YXIgc2VjdGlvbkVsZW0gPSBjbG9zZXN0KHNsaWRlcywgU0VDVElPTl9TRUwpO1xuICAgICAgdmFyIHNlY3Rpb24gPSBnZXRTdGF0ZSgpLnNlY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gc2VjdGlvbi5pdGVtID09IHNlY3Rpb25FbGVtO1xuICAgICAgfSlbMF07XG4gICAgICB2YXIgc2xpZGUgPSBzZWN0aW9uLnNsaWRlcy5maWx0ZXIoZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICAgIHJldHVybiBzbGlkZS5pdGVtID09IGRlc3Rpbnk7XG4gICAgICB9KVswXTtcbiAgICAgIHZhciB2ID0ge1xuICAgICAgICBcInNsaWRlc1wiOiBzbGlkZXMsXG4gICAgICAgIFwiZGVzdGlueVwiOiBkZXN0aW55LFxuICAgICAgICBcImRpcmVjdGlvblwiOiBkaXJlY3Rpb24sXG4gICAgICAgIFwiZGVzdGlueVBvc1wiOiB7XG4gICAgICAgICAgXCJsZWZ0XCI6IGRlc3Rpbnkub2Zmc2V0TGVmdFxuICAgICAgICB9LFxuICAgICAgICBcInNsaWRlSW5kZXhcIjogc2xpZGUuaW5kZXgoKSxcbiAgICAgICAgXCJzZWN0aW9uXCI6IHNlY3Rpb25FbGVtLFxuICAgICAgICBcInNlY3Rpb25JbmRleFwiOiBzZWN0aW9uLmluZGV4KCksXG4gICAgICAgIFwiYW5jaG9yTGlua1wiOiBzZWN0aW9uLmFuY2hvcixcbiAgICAgICAgXCJzbGlkZXNOYXZcIjogJChTTElERVNfTkFWX1NFTCwgc2VjdGlvbkVsZW0pWzBdLFxuICAgICAgICBcInNsaWRlQW5jaG9yXCI6IHNsaWRlLmFuY2hvcixcbiAgICAgICAgXCJwcmV2U2xpZGVcIjogc2VjdGlvbi5hY3RpdmVTbGlkZS5pdGVtLFxuICAgICAgICBcInByZXZTbGlkZUluZGV4XCI6IHNlY3Rpb24uYWN0aXZlU2xpZGUuaW5kZXgoKSxcbiAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgXCJzZWN0aW9uXCI6IHNlY3Rpb24sXG4gICAgICAgICAgXCJvcmlnaW5cIjogc2VjdGlvbi5hY3RpdmVTbGlkZSxcbiAgICAgICAgICBcImRlc3RpbmF0aW9uXCI6IHNsaWRlXG4gICAgICAgIH0sXG4gICAgICAgIC8vY2FjaGluZyB0aGUgdmFsdWUgb2YgaXNSZXNpemluZyBhdCB0aGUgbW9tbWVudCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkXG4gICAgICAgIC8vYmVjYXVzZSBpdCB3aWxsIGJlIGNoZWNrZWQgbGF0ZXIgaW5zaWRlIGEgc2V0VGltZW91dCBhbmQgdGhlIHZhbHVlIG1pZ2h0IGNoYW5nZVxuICAgICAgICBcImxvY2FsSXNSZXNpemluZ1wiOiBzdGF0ZS5pc1Jlc2l6aW5nXG4gICAgICB9O1xuICAgICAgdi54TW92ZW1lbnQgPSBnZXRYbW92ZW1lbnQodi5wcmV2U2xpZGVJbmRleCwgdi5zbGlkZUluZGV4KTtcbiAgICAgIHYuZGlyZWN0aW9uID0gdi5kaXJlY3Rpb24gPyB2LmRpcmVjdGlvbiA6IHYueE1vdmVtZW50OyAvL2ltcG9ydGFudCEhIE9ubHkgZG8gaXQgd2hlbiBub3QgcmVzaXppbmdcblxuICAgICAgaWYgKCF2LmxvY2FsSXNSZXNpemluZykge1xuICAgICAgICAvL3ByZXZlbnRpbmcgZnJvbSBzY3JvbGxpbmcgdG8gdGhlIG5leHQvcHJldiBzZWN0aW9uIHdoZW4gdXNpbmcgc2Nyb2xsSG9yaXpvbnRhbGx5XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBjYW5TY3JvbGw6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLm9uU2xpZGVMZWF2ZSkge1xuICAgICAgICAvL2lmIHRoZSBzaXRlIGlzIG5vdCBqdXN0IHJlc2l6aW5nIGFuZCByZWFkanVzdGluZyB0aGUgc2xpZGVzXG4gICAgICAgIGlmICghdi5sb2NhbElzUmVzaXppbmcgJiYgdi54TW92ZW1lbnQgIT09ICdub25lJykge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGdldE9wdGlvbnMoKS5vblNsaWRlTGVhdmUpKSB7XG4gICAgICAgICAgICBpZiAoZmlyZUNhbGxiYWNrKCdvblNsaWRlTGVhdmUnLCB2KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHNsaWRlTW92aW5nOiBmYWxzZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZGRDbGFzcyhkZXN0aW55LCBBQ1RJVkUpO1xuICAgICAgcmVtb3ZlQ2xhc3Moc2libGluZ3MoZGVzdGlueSksIEFDVElWRSk7XG4gICAgICB1cGRhdGVTdGF0ZSgpO1xuXG4gICAgICBpZiAoIXYubG9jYWxJc1Jlc2l6aW5nKSB7XG4gICAgICAgIHN0b3BNZWRpYSh2LnByZXZTbGlkZSk7XG4gICAgICAgIGxhenlMb2FkUGFuZWxzKHNsaWRlKTtcbiAgICAgIH1cblxuICAgICAgdG9nZ2xlQ29udHJvbEFycm93cyh2KTsgLy9vbmx5IGNoYW5naW5nIHRoZSBVUkwgaWYgdGhlIHNsaWRlcyBhcmUgaW4gdGhlIGN1cnJlbnQgc2VjdGlvbiAobm90IGZvciByZXNpemUgcmUtYWRqdXN0aW5nKVxuXG4gICAgICBpZiAoc2VjdGlvbi5pc0FjdGl2ZSAmJiAhdi5sb2NhbElzUmVzaXppbmcpIHtcbiAgICAgICAgc2V0UGFnZVN0YXR1cyh2LnNsaWRlSW5kZXgsIHYuc2xpZGVBbmNob3IsIHYuYW5jaG9yTGluayk7XG4gICAgICB9XG5cbiAgICAgIEV2ZW50RW1pdHRlci5lbWl0KGV2ZW50cy5vblNsaWRlTGVhdmUsIHYpO1xuICAgICAgcGVyZm9ybUhvcml6b250YWxNb3ZlKHNsaWRlcywgdiwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogUGVyZm9ybXMgdGhlIGhvcml6b250YWwgbW92ZW1lbnQuIChDU1MzIG9yIGpRdWVyeSlcbiAgICAqXG4gICAgKiBAcGFyYW0gZmlyZUNhbGxiYWNrIHtCb29sZWFufSAtIGRldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZmlyZSB0aGUgY2FsbGJhY2tcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gcGVyZm9ybUhvcml6b250YWxNb3ZlKHNsaWRlcywgdiwgZmlyZUNhbGxiYWNrKSB7XG4gICAgICB2YXIgZGVzdGlueVBvcyA9IHYuZGVzdGlueVBvcztcbiAgICAgIGFjdGl2ZVNsaWRlc05hdmlnYXRpb24odi5zbGlkZXNOYXYsIHYuc2xpZGVJbmRleCk7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHNjcm9sbFg6IE1hdGgucm91bmQoZGVzdGlueVBvcy5sZWZ0KVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChnZXRPcHRpb25zKCkuY3NzMykge1xuICAgICAgICB2YXIgdHJhbnNsYXRlM2QgPSAndHJhbnNsYXRlM2QoLScgKyBNYXRoLnJvdW5kKGRlc3RpbnlQb3MubGVmdCkgKyAncHgsIDBweCwgMHB4KSc7XG4gICAgICAgIEZQLnRlc3QudHJhbnNsYXRlM2RIW3Yuc2VjdGlvbkluZGV4XSA9IHRyYW5zbGF0ZTNkO1xuICAgICAgICBjc3MoYWRkQW5pbWF0aW9uKCQoU0xJREVTX0NPTlRBSU5FUl9TRUwsIHNsaWRlcykpLCBnZXRUcmFuc2Zvcm1zKHRyYW5zbGF0ZTNkKSk7XG4gICAgICAgIGNsZWFyVGltZW91dChnX2FmdGVyU2xpZGVMb2Fkc0lkKTtcbiAgICAgICAgZ19hZnRlclNsaWRlTG9hZHNJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmaXJlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGFmdGVyU2xpZGVMb2Fkcyh2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGdldE9wdGlvbnMoKS5zY3JvbGxpbmdTcGVlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBGUC50ZXN0LmxlZnRbdi5zZWN0aW9uSW5kZXhdID0gTWF0aC5yb3VuZChkZXN0aW55UG9zLmxlZnQpO1xuICAgICAgICBzY3JvbGxUbyhzbGlkZXMsIE1hdGgucm91bmQoZGVzdGlueVBvcy5sZWZ0KSwgZ2V0T3B0aW9ucygpLnNjcm9sbGluZ1NwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZpcmVDYWxsYmFjaykge1xuICAgICAgICAgICAgYWZ0ZXJTbGlkZUxvYWRzKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0dW5zIGByaWdodGAgb3IgYGxlZnRgIGRlcGVuZGluZyBvbiB0aGUgc2Nyb2xsaW5nIG1vdmVtZW50IHRvIHJlYWNoIGl0cyBkZXN0aW5hdGlvblxuICAgICogZnJvbSB0aGUgY3VycmVudCBzbGlkZS5cbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBnZXRYbW92ZW1lbnQoZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICBpZiAoZnJvbUluZGV4ID09IHRvSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb21JbmRleCA+IHRvSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EZXN0cm95JDYoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZ19hZnRlclNsaWRlTG9hZHNJZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWZ0ZXJTbGlkZUxvYWRzKHYpIHtcbiAgICAgIC8vaWYgdGhlIHNpdGUgaXMgbm90IGp1c3QgcmVzaXppbmcgYW5kIHJlYWRqdXN0aW5nIHRoZSBzbGlkZXNcbiAgICAgIGlmICghdi5sb2NhbElzUmVzaXppbmcpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZ2V0T3B0aW9ucygpLmFmdGVyU2xpZGVMb2FkKSkge1xuICAgICAgICAgIGZpcmVDYWxsYmFjaygnYWZ0ZXJTbGlkZUxvYWQnLCB2KTtcbiAgICAgICAgfSAvL25lZWRzIHRvIGJlIGluc2lkZSB0aGUgY29uZGl0aW9uIHRvIHByZXZlbnQgcHJvYmxlbXMgd2l0aCBjb250aW51b3VzVmVydGljYWwgYW5kIHNjcm9sbEhvcml6b250YWxseVxuICAgICAgICAvL2FuZCB0byBwcmV2ZW50IGRvdWJsZSBzY3JvbGwgcmlnaHQgYWZ0ZXIgYSB3aW5kb3dzIHJlc2l6ZVxuXG5cbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGNhblNjcm9sbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcGxheU1lZGlhKHYuZGVzdGlueSk7XG4gICAgICAgIEV2ZW50RW1pdHRlci5lbWl0KGV2ZW50cy5hZnRlclNsaWRlTG9hZHMsIHYpO1xuICAgICAgfSAvL2xldHRpbmcgdGhlbSBzbGlkZSBhZ2FpblxuXG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgc2xpZGVNb3Zpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFNsaWRlcyBzaWxlbnRseSAod2l0aCBubyBhbmltYXRpb24pIHRoZSBhY3RpdmUgc2xpZGVyIHRvIHRoZSBnaXZlbiBzbGlkZS5cbiAgICAqIEBwYXJhbSBub0NhbGxiYWNrIHtib29sfSB0cnVlIG9yIGRlZmluZWQgLT4gbm8gY2FsbGJhY2tzXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNpbGVudExhbmRzY2FwZVNjcm9sbChhY3RpdmVTbGlkZSwgbm9DYWxsYmFja3MpIHtcbiAgICAgIHNldFNjcm9sbGluZ1NwZWVkKDAsICdpbnRlcm5hbCcpO1xuXG4gICAgICBpZiAodHlwZW9mIG5vQ2FsbGJhY2tzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvL3ByZXZlbnRpbmcgZmlyaW5nIGNhbGxiYWNrcyBhZnRlclNsaWRlTG9hZCBldGMuXG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc1Jlc2l6aW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBsYW5kc2NhcGVTY3JvbGwoY2xvc2VzdChhY3RpdmVTbGlkZSwgU0xJREVTX1dSQVBQRVJfU0VMKSwgYWN0aXZlU2xpZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIG5vQ2FsbGJhY2tzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgaXNSZXNpemluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNldFNjcm9sbGluZ1NwZWVkKGdldE9yaWdpbmFscygpLnNjcm9sbGluZ1NwZWVkLCAnaW50ZXJuYWwnKTtcbiAgICB9XG5cbiAgICB2YXIgZ19wcmV2QWN0aXZlU2VjdGlvbkluZGV4ID0gbnVsbDtcbiAgICB2YXIgZ19wcmV2QWN0aXZlU2xpZGVJbmRleCA9IG51bGw7XG4gICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5vbkRlc3Ryb3lBbGwsIG9uRGVzdHJveUFsbCk7XG5cbiAgICBmdW5jdGlvbiBvbkRlc3Ryb3lBbGwoKSB7XG4gICAgICBnX3ByZXZBY3RpdmVTZWN0aW9uSW5kZXggPSBudWxsO1xuICAgICAgZ19wcmV2QWN0aXZlU2xpZGVJbmRleCA9IG51bGw7XG4gICAgfVxuICAgIC8qKiBcbiAgICAgKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgYXBwLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTdGF0ZSgpIHtcbiAgICAgIHN0YXRlLmFjdGl2ZVNlY3Rpb24gPSBudWxsO1xuICAgICAgc3RhdGUuc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IGhhc0NsYXNzKHNlY3Rpb24uaXRlbSwgQUNUSVZFKTtcbiAgICAgICAgc2VjdGlvbi5pc0FjdGl2ZSA9IGlzQWN0aXZlO1xuICAgICAgICBzZWN0aW9uLmhhc1Njcm9sbCA9IHNjcm9sbE92ZXJmbG93SGFuZGxlci5oYXNTY3JvbGwoc2VjdGlvbi5pdGVtKTtcblxuICAgICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgICBzdGF0ZS5hY3RpdmVTZWN0aW9uID0gc2VjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWN0aW9uLnNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWN0aW9uLmFjdGl2ZVNsaWRlID0gbnVsbDtcbiAgICAgICAgICBzZWN0aW9uLnNsaWRlcy5tYXAoZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICAgICAgICB2YXIgaXNBY3RpdmVTbGlkZSA9IGhhc0NsYXNzKHNsaWRlLml0ZW0sIEFDVElWRSk7XG4gICAgICAgICAgICBzbGlkZS5oYXNTY3JvbGwgPSBzY3JvbGxPdmVyZmxvd0hhbmRsZXIuaGFzU2Nyb2xsKHNlY3Rpb24uaXRlbSk7XG4gICAgICAgICAgICBzbGlkZS5pc0FjdGl2ZSA9IGlzQWN0aXZlU2xpZGU7XG5cbiAgICAgICAgICAgIGlmIChpc0FjdGl2ZVNsaWRlKSB7XG4gICAgICAgICAgICAgIHNlY3Rpb24uYWN0aXZlU2xpZGUgPSBzbGlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzY3JvbGxUb05ld0FjdGl2ZVBhbmVsKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0cnVjdHVyYWxTdGF0ZSgpIHtcbiAgICAgIHZhciBhbGxTZWN0aW9uSXRlbXMgPSAkKGdldE9wdGlvbnMoKS5zZWN0aW9uU2VsZWN0b3IsIGdldENvbnRhaW5lcigpKTtcbiAgICAgIHZhciBzZWN0aW9uc0l0ZW1zID0gZ2V0VmlzaWJsZShhbGxTZWN0aW9uSXRlbXMpO1xuICAgICAgdmFyIGFsbFNlY3Rpb25zID0gQXJyYXkuZnJvbShhbGxTZWN0aW9uSXRlbXMpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlY3Rpb25QYW5lbChpdGVtKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNlY3Rpb25zID0gYWxsU2VjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmlzVmlzaWJsZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNsaWRlcyA9IHNlY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY2MuY29uY2F0KHNlY3Rpb24uc2xpZGVzKTtcbiAgICAgIH0sIFtdKTsgLy8ga2VlcGluZyB0cmFjayBvZiB0aGUgcHJldmlvdXNseSBhY3RpdmUgc2VjdGlvblxuXG4gICAgICBnX3ByZXZBY3RpdmVTZWN0aW9uSW5kZXggPSBnZXRQcmV2QWN0aXZlUGFuZWxJbmRleChzdGF0ZS5hY3RpdmVTZWN0aW9uKTtcbiAgICAgIGdfcHJldkFjdGl2ZVNsaWRlSW5kZXggPSBnZXRQcmV2QWN0aXZlUGFuZWxJbmRleChzdGF0ZS5hY3RpdmVTZWN0aW9uID8gc3RhdGUuYWN0aXZlU2VjdGlvbi5hY3RpdmVTbGlkZSA6IG51bGwpO1xuICAgICAgc3RhdGUubnVtU2VjdGlvbnMgPSBzZWN0aW9uc0l0ZW1zLmxlbmd0aDtcbiAgICAgIHN0YXRlLm51bVNsaWRlcyA9IHNlY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY2MgKyBzZWN0aW9uLnNsaWRlcy5sZW5ndGg7XG4gICAgICB9LCAwKTtcbiAgICAgIHN0YXRlLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgICBzdGF0ZS5zZWN0aW9uc0luY2x1ZGluZ0hpZGRlbiA9IGFsbFNlY3Rpb25zO1xuICAgICAgc3RhdGUuc2xpZGVzID0gc2xpZGVzO1xuICAgICAgc3RhdGUucGFuZWxzID0gc3RhdGUuc2VjdGlvbnMuY29uY2F0KHN0YXRlLnNsaWRlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJldkFjdGl2ZVBhbmVsSW5kZXgoYWN0aXZlUGFuZWwpIHtcbiAgICAgIGlmICghYWN0aXZlUGFuZWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2QWN0aXZlUGFuZWxJdGVtID0gYWN0aXZlUGFuZWwgPyBhY3RpdmVQYW5lbC5pdGVtIDogbnVsbDtcbiAgICAgIHZhciBoaWRkZW5QYW5lbHMgPSBhY3RpdmVQYW5lbC5pc1NlY3Rpb24gPyBzdGF0ZS5zZWN0aW9uc0luY2x1ZGluZ0hpZGRlbiA6IHN0YXRlLmFjdGl2ZVNlY3Rpb24uc2xpZGVzSW5jbHVkaW5nSGlkZGVuO1xuXG4gICAgICBpZiAocHJldkFjdGl2ZVBhbmVsSXRlbSkge1xuICAgICAgICB2YXIgcGFuZWwgPSBnZXRQYW5lbEJ5RWxlbWVudChoaWRkZW5QYW5lbHMsIHByZXZBY3RpdmVQYW5lbEl0ZW0pO1xuICAgICAgICByZXR1cm4gcGFuZWwgPyBwYW5lbC5pbmRleCgpIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gY2hhbmdlcyBpbiB0aGUgRE9NIHRha2UgcGxhY2UgdGhlcmUncyBhIGNoYW5nZSBcbiAgICAgKiB0aGUgYWN0aXZlIHNlY3Rpb24gaXMgbm93IGhpZGRlbiBvciByZW1vdmVkLiBcbiAgICAgKiBmdWxsUGFnZS5qcyB3aWxsIHNjcm9sbCB0byB0aGUgY2xvc2VzdCBzZWN0aW9uIG5lYXJieS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsVG9OZXdBY3RpdmVQYW5lbCgpIHtcbiAgICAgIHZhciBhY3RpdmVTZWN0aW9uID0gc3RhdGUuYWN0aXZlU2VjdGlvbjtcbiAgICAgIHZhciBhY3RpdmVTZWN0aW9uSGFzU2xpZGVzID0gc3RhdGUuYWN0aXZlU2VjdGlvbiA/IHN0YXRlLmFjdGl2ZVNlY3Rpb24uc2xpZGVzLmxlbmd0aCA6IGZhbHNlO1xuICAgICAgdmFyIGFjdGl2ZVNsaWRlID0gc3RhdGUuYWN0aXZlU2VjdGlvbiA/IHN0YXRlLmFjdGl2ZVNlY3Rpb24uYWN0aXZlU2xpZGUgOiBudWxsOyAvLyBIaWRkaW5nIC8gcmVtb3ZpbmcgdGhlIGFjdGl2ZSBzZWN0aW9uID9cblxuICAgICAgaWYgKCFhY3RpdmVTZWN0aW9uICYmIHN0YXRlLnNlY3Rpb25zLmxlbmd0aCAmJiAhZ2V0U3RhdGUoKS5pc0JleW9uZEZ1bGxwYWdlICYmIGdfcHJldkFjdGl2ZVNlY3Rpb25JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbmV3QWN0aXZlU2VjdGlvbiA9IGdldE5ld0FjdGl2ZVBhbmVsKGdfcHJldkFjdGl2ZVNlY3Rpb25JbmRleCwgc3RhdGUuc2VjdGlvbnMpO1xuXG4gICAgICAgIGlmIChuZXdBY3RpdmVTZWN0aW9uKSB7XG4gICAgICAgICAgc3RhdGUuYWN0aXZlU2VjdGlvbiA9IG5ld0FjdGl2ZVNlY3Rpb247XG4gICAgICAgICAgc3RhdGUuYWN0aXZlU2VjdGlvbi5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgYWRkQ2xhc3Moc3RhdGUuYWN0aXZlU2VjdGlvbi5pdGVtLCBBQ1RJVkUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZVNlY3Rpb24pIHtcbiAgICAgICAgICBzaWxlbnRTY3JvbGwoc3RhdGUuYWN0aXZlU2VjdGlvbi5pdGVtLm9mZnNldFRvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZVNlY3Rpb25IYXNTbGlkZXMgJiYgIWFjdGl2ZVNsaWRlICYmIGdfcHJldkFjdGl2ZVNsaWRlSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG5ld0FjdGl2ZVNsaWRlID0gZ2V0TmV3QWN0aXZlUGFuZWwoZ19wcmV2QWN0aXZlU2xpZGVJbmRleCwgc3RhdGUuYWN0aXZlU2VjdGlvbi5zbGlkZXMpO1xuXG4gICAgICAgIGlmIChuZXdBY3RpdmVTbGlkZSkge1xuICAgICAgICAgIHN0YXRlLmFjdGl2ZVNlY3Rpb24uYWN0aXZlU2xpZGUgPSBuZXdBY3RpdmVTbGlkZTtcbiAgICAgICAgICBzdGF0ZS5hY3RpdmVTZWN0aW9uLmFjdGl2ZVNsaWRlLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICBhZGRDbGFzcyhzdGF0ZS5hY3RpdmVTZWN0aW9uLmFjdGl2ZVNsaWRlLml0ZW0sIEFDVElWRSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuYWN0aXZlU2VjdGlvbi5hY3RpdmVTbGlkZSkge1xuICAgICAgICAgIHNpbGVudExhbmRzY2FwZVNjcm9sbChzdGF0ZS5hY3RpdmVTZWN0aW9uLmFjdGl2ZVNsaWRlLml0ZW0sICdpbnRlcm5hbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TmV3QWN0aXZlUGFuZWwocHJldkFjdGl2ZVBhbmVsSW5kZXgsIHNpYmxpbmdzKSB7XG4gICAgICB2YXIgbmV3QWN0aXZlU2VjdGlvbjtcbiAgICAgIHZhciBwcmV2SW5kZXggPSBwcmV2QWN0aXZlUGFuZWxJbmRleCAtIDE7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gcHJldkFjdGl2ZVBhbmVsSW5kZXg7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbmV3QWN0aXZlU2VjdGlvbiA9IHNpYmxpbmdzW3ByZXZJbmRleF0gfHwgc2libGluZ3NbbmV4dEluZGV4XTtcblxuICAgICAgICBpZiAobmV3QWN0aXZlU2VjdGlvbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkluZGV4ID0gcHJldkluZGV4IC0gMTtcbiAgICAgICAgbmV4dEluZGV4ID0gbmV4dEluZGV4ICsgMTtcbiAgICAgIH0gd2hpbGUgKHByZXZJbmRleCA+PSAwIHx8IG5leHRJbmRleCA8IHNpYmxpbmdzLmxlbmd0aCk7XG5cbiAgICAgIHJldHVybiBuZXdBY3RpdmVTZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNlY3Rpb24gb2JqZWN0XG4gICAgKi9cblxuXG4gICAgdmFyIFNlY3Rpb25QYW5lbCA9IGZ1bmN0aW9uIFNlY3Rpb25QYW5lbChlbCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgW10ucHVzaC5jYWxsKGFyZ3VtZW50cywgZ2V0T3B0aW9ucygpLnNlY3Rpb25TZWxlY3Rvcik7XG4gICAgICBJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLmFsbFNsaWRlc0l0ZW1zID0gJChnZXRPcHRpb25zKCkuc2xpZGVTZWxlY3RvciwgZWwpO1xuICAgICAgdGhpcy5zbGlkZXNJbmNsdWRpbmdIaWRkZW4gPSBBcnJheS5mcm9tKHRoaXMuYWxsU2xpZGVzSXRlbXMpLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWRlUGFuZWwoaXRlbSwgX3RoaXMpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNsaWRlcyA9IHRoaXMuc2xpZGVzSW5jbHVkaW5nSGlkZGVuLmZpbHRlcihmdW5jdGlvbiAoc2xpZGVQYW5lbCkge1xuICAgICAgICByZXR1cm4gc2xpZGVQYW5lbC5pc1Zpc2libGU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWN0aXZlU2xpZGUgPSB0aGlzLnNsaWRlcy5sZW5ndGggPyB0aGlzLnNsaWRlcy5maWx0ZXIoZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICAgIHJldHVybiBzbGlkZS5pc0FjdGl2ZTtcbiAgICAgIH0pWzBdIHx8IHRoaXMuc2xpZGVzWzBdIDogbnVsbDtcbiAgICB9O1xuICAgIFNlY3Rpb25QYW5lbC5wcm90b3R5cGUgPSBJdGVtLnByb3RvdHlwZTtcbiAgICBTZWN0aW9uUGFuZWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VjdGlvblBhbmVsO1xuICAgIC8qKlxuICAgICogU2xpZGUgb2JqZWN0XG4gICAgKi9cblxuICAgIHZhciBTbGlkZVBhbmVsID0gZnVuY3Rpb24gU2xpZGVQYW5lbChlbCwgc2VjdGlvbikge1xuICAgICAgdGhpcy5wYXJlbnQgPSBzZWN0aW9uO1xuICAgICAgSXRlbS5jYWxsKHRoaXMsIGVsLCBnZXRPcHRpb25zKCkuc2xpZGVTZWxlY3Rvcik7XG4gICAgfTtcblxuICAgIFNsaWRlUGFuZWwucHJvdG90eXBlID0gSXRlbS5wcm90b3R5cGU7XG4gICAgU2xpZGVQYW5lbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZWN0aW9uUGFuZWw7XG5cbiAgICAvKipcbiAgICAqIEFkZHMgaW50ZXJuYWwgY2xhc3NlcyB0byBiZSBhYmxlIHRvIHByb3ZpZGUgY3VzdG9taXphYmxlIHNlbGVjdG9yc1xuICAgICoga2VlcGluZyB0aGUgbGluayB3aXRoIHRoZSBzdHlsZSBzaGVldC5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gYWRkSW50ZXJuYWxTZWxlY3RvcnMoKSB7XG4gICAgICBhZGRDbGFzcygkKGdldE9wdGlvbnMoKS5zZWN0aW9uU2VsZWN0b3IsIGdldENvbnRhaW5lcigpKSwgU0VDVElPTik7XG4gICAgICBhZGRDbGFzcygkKGdldE9wdGlvbnMoKS5zbGlkZVNlbGVjdG9yLCBnZXRDb250YWluZXIoKSksIFNMSURFKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFN0eWxlcyB0aGUgaG9yaXpvbnRhbCBzbGlkZXMgZm9yIGEgc2VjdGlvbi5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gc3R5bGVTbGlkZXMoc2VjdGlvbikge1xuICAgICAgdmFyIG51bVNsaWRlcyA9IHNlY3Rpb24uc2xpZGVzLmxlbmd0aDtcbiAgICAgIHZhciBzbGlkZXNFbGVtcyA9IHNlY3Rpb24uYWxsU2xpZGVzSXRlbXM7XG4gICAgICB2YXIgc2xpZGVzID0gc2VjdGlvbi5zbGlkZXM7XG4gICAgICB2YXIgc2xpZGVyV2lkdGggPSBudW1TbGlkZXMgKiAxMDA7XG4gICAgICB2YXIgc2xpZGVXaWR0aCA9IDEwMCAvIG51bVNsaWRlcztcblxuICAgICAgaWYgKCEkKFNMSURFU19XUkFQUEVSX1NFTCwgc2VjdGlvbi5pdGVtKVswXSkge1xuICAgICAgICB2YXIgc2xpZGVzV3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2xpZGVzV3JhcHBlci5jbGFzc05hbWUgPSBTTElERVNfV1JBUFBFUjsgLy9mcC1zbGlkZXNcblxuICAgICAgICB3cmFwQWxsKHNsaWRlc0VsZW1zLCBzbGlkZXNXcmFwcGVyKTtcbiAgICAgICAgdmFyIHNsaWRlc0NvbnRhaW5lciA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2xpZGVzQ29udGFpbmVyLmNsYXNzTmFtZSA9IFNMSURFU19DT05UQUlORVI7IC8vZnAtc2xpZGVzQ29udGFpbmVyXG5cbiAgICAgICAgd3JhcEFsbChzbGlkZXNFbGVtcywgc2xpZGVzQ29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgICAgY3NzKCQoU0xJREVTX0NPTlRBSU5FUl9TRUwsIHNlY3Rpb24uaXRlbSksIHtcbiAgICAgICAgJ3dpZHRoJzogc2xpZGVyV2lkdGggKyAnJSdcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobnVtU2xpZGVzID4gMSkge1xuICAgICAgICBpZiAoZ2V0T3B0aW9ucygpLmNvbnRyb2xBcnJvd3MpIHtcbiAgICAgICAgICBjcmVhdGVTbGlkZUFycm93cyhzZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZXRPcHRpb25zKCkuc2xpZGVzTmF2aWdhdGlvbikge1xuICAgICAgICAgIGFkZFNsaWRlc05hdmlnYXRpb24oc2VjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2xpZGVzLmZvckVhY2goZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICAgIGNzcyhzbGlkZS5pdGVtLCB7XG4gICAgICAgICAgJ3dpZHRoJzogc2xpZGVXaWR0aCArICclJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ2V0T3B0aW9ucygpLnZlcnRpY2FsQ2VudGVyZWQpIHtcbiAgICAgICAgICBhZGRUYWJsZUNsYXNzKHNsaWRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRpbmdTbGlkZSA9IHNlY3Rpb24uYWN0aXZlU2xpZGUgfHwgbnVsbDsgLy9pZiB0aGUgc2xpZGUgd29uJ3QgYmUgYW4gc3RhcnRpbmcgcG9pbnQsIHRoZSBkZWZhdWx0IHdpbGwgYmUgdGhlIGZpcnN0IG9uZVxuICAgICAgLy90aGUgYWN0aXZlIHNlY3Rpb24gaXNuJ3QgdGhlIGZpcnN0IG9uZT8gSXMgbm90IHRoZSBmaXJzdCBzbGlkZSBvZiB0aGUgZmlyc3Qgc2VjdGlvbj8gVGhlbiB3ZSBsb2FkIHRoYXQgc2VjdGlvbi9zbGlkZSBieSBkZWZhdWx0LlxuXG4gICAgICBpZiAoc3RhcnRpbmdTbGlkZSAhPSBudWxsICYmIHN0YXRlLmFjdGl2ZVNlY3Rpb24gJiYgKHN0YXRlLmFjdGl2ZVNlY3Rpb24uaW5kZXgoKSAhPT0gMCB8fCBzdGF0ZS5hY3RpdmVTZWN0aW9uLmluZGV4KCkgPT09IDAgJiYgc3RhcnRpbmdTbGlkZS5pbmRleCgpICE9PSAwKSkge1xuICAgICAgICBzaWxlbnRMYW5kc2NhcGVTY3JvbGwoc3RhcnRpbmdTbGlkZS5pdGVtLCAnaW50ZXJuYWwnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZENsYXNzKHNsaWRlc0VsZW1zWzBdLCBBQ1RJVkUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnX3dyYXBwZXJPYnNlcnZlcjtcbiAgICB2YXIgZ193cmFwcGVyT2JzZXJ2ZUNvbmZpZyA9IHtcbiAgICAgIGF0dHJpYnV0ZXM6IGZhbHNlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYmluZEV2ZW50cywgYmluZEV2ZW50cyQ5KTtcbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uRGVzdHJveSwgdW5iaW5kRXZlbnRzKTtcbiAgICBGUFtcInJlbmRlclwiXSA9IG9uQ29udGVudENoYW5nZTtcblxuICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMkOSgpIHtcbiAgICAgIGlmIChnZXRPcHRpb25zKCkub2JzZXJ2ZXIgJiYgXCJNdXRhdGlvbk9ic2VydmVyXCIgaW4gd2luZG93ICYmICQoV1JBUFBFUl9TRUwpWzBdKSB7XG4gICAgICAgIGdfd3JhcHBlck9ic2VydmVyID0gY3JlYXRlT2JzZXJ2ZXIoJChXUkFQUEVSX1NFTClbMF0sIG9uQ29udGVudENoYW5nZSwgZ193cmFwcGVyT2JzZXJ2ZUNvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuY29udGVudENoYW5nZWQsIG9uQ29udGVudENoYW5nZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5iaW5kRXZlbnRzKCkge1xuICAgICAgaWYgKGdfd3JhcHBlck9ic2VydmVyKSB7XG4gICAgICAgIGdfd3JhcHBlck9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZ193cmFwcGVyT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTXV0YXRpb24gb2JzZXJ2ZXIuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKHRhcmdldCwgY2FsbGJhY2ssIGNvbmZpZykge1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIGNvbmZpZyk7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlkU2xpZGVzQ2hhbmdlKCkge1xuICAgICAgcmV0dXJuIGdldFZpc2libGUoJChnZXRPcHRpb25zKCkuc2xpZGVTZWxlY3RvciwgZ2V0Q29udGFpbmVyKCkpKS5sZW5ndGggIT09IGdldFN0YXRlKCkubnVtU2xpZGVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZFNlY3Rpb25zQ2hhbmdlKCkge1xuICAgICAgcmV0dXJuIGdldFZpc2libGUoJChnZXRPcHRpb25zKCkuc2VjdGlvblNlbGVjdG9yLCBnZXRDb250YWluZXIoKSkpLmxlbmd0aCAhPT0gZ2V0U3RhdGUoKS5udW1TZWN0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWRTZWN0aW9uc09yU2xpZGVzQ2hhbmdlKCkge1xuICAgICAgcmV0dXJuIGRpZFNsaWRlc0NoYW5nZSgpIHx8IGRpZFNlY3Rpb25zQ2hhbmdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbiB0byBjaGFuZ2VzIG9uIHNlY3Rpb25zIGFuZCBmaXJlcyByZUJ1aWxkXG4gICAgICogd2hlbiB0aG9zZSBjaGFuZ2VzIGFmZmVjdCB0aGUgc2VjdGlvbiBoZWlnaHQuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIG9uQ29udGVudENoYW5nZShtdXRhdGlvbnMpIHtcbiAgICAgIHZhciBfZGlkU2xpZGVzQ2hhbmdlID0gZGlkU2xpZGVzQ2hhbmdlKCk7XG5cbiAgICAgIGlmIChkaWRTZWN0aW9uc09yU2xpZGVzQ2hhbmdlKCkgJiYgIXN0YXRlLmlzRG9pbmdDb250aW5vdXNWZXJ0aWNhbCkge1xuICAgICAgICBpZiAoZ2V0T3B0aW9ucygpLm9ic2VydmVyICYmIGdfd3JhcHBlck9ic2VydmVyKSB7XG4gICAgICAgICAgLy8gVGVtcG9yYWxseSBkaXNhYmxpbmcgdGhlIG9ic2VydmVyIHdoaWxlIFxuICAgICAgICAgIC8vIHdlIG1vZGlkeSB0aGUgRE9NIGFnYWluXG4gICAgICAgICAgZ193cmFwcGVyT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlU3RydWN0dXJhbFN0YXRlKCk7XG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7IC8vIFJlbW92aW5nIG5hdnMgYW5kIGFuY2hvcnMgb3B0aW9uc1xuXG4gICAgICAgIGdldE9wdGlvbnMoKS5hbmNob3JzID0gW107XG4gICAgICAgIHJlbW92ZSgkKFNFQ1RJT05fTkFWX1NFTCkpO1xuICAgICAgICBhZGRJbnRlcm5hbFNlbGVjdG9ycygpO1xuICAgICAgICBzZXRPcHRpb25zRnJvbURPTSgpO1xuXG4gICAgICAgIGlmIChnZXRPcHRpb25zKCkubmF2aWdhdGlvbikge1xuICAgICAgICAgIGFkZFZlcnRpY2FsTmF2aWdhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9kaWRTbGlkZXNDaGFuZ2UpIHtcbiAgICAgICAgICByZW1vdmUoJChTTElERVNfTkFWX1NFTCkpO1xuICAgICAgICAgIHJlbW92ZSgkKFNMSURFU19BUlJPV19TRUwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFN0YXRlKCkuc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAgIGlmIChzZWN0aW9uLnNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChfZGlkU2xpZGVzQ2hhbmdlKSB7XG4gICAgICAgICAgICAgIHN0eWxlU2xpZGVzKHNlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZVNlY3Rpb24oc2VjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldE9wdGlvbnMoKS5vYnNlcnZlciAmJiBnX3dyYXBwZXJPYnNlcnZlciAmJiAkKFdSQVBQRVJfU0VMKVswXSkge1xuICAgICAgICBnX3dyYXBwZXJPYnNlcnZlci5vYnNlcnZlKCQoV1JBUFBFUl9TRUwpWzBdLCBnX3dyYXBwZXJPYnNlcnZlQ29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3VwcG9ydHNQYXNzaXZlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy9jaGVrcyBmb3IgcGFzc2l2ZSBldmVudCBzdXBwb3J0XG4gICAgICB2YXIgZ19zdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgZ19zdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvd0FkZEV2ZW50KFwidGVzdFBhc3NpdmVcIiwgbnVsbCwgb3B0cyk7XG4gICAgICAgIHdpbmRvd1JlbW92ZUV2ZW50KFwidGVzdFBhc3NpdmVcIiwgbnVsbCwgb3B0cyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ19zdXBwb3J0c1Bhc3NpdmU7XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGZ1bmN0aW9uIGdldFBhc3NpdmVPcHRpb25zSWZQb3NzaWJsZSgpIHtcbiAgICAgIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVFdmVudHMoKSA/IHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0gOiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgd2hlZWxEYXRhSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcHJldlRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgdmFyIF9zY3JvbGxpbmdzID0gW107XG4gICAgICB2YXIgaXNTY3JvbGxpbmdWZXJ0aWNhbGx5O1xuICAgICAgdmFyIGRpcmVjdGlvbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZ2lzdGVyRXZlbnQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnQoZSkge1xuICAgICAgICAgIGUgPSBlIHx8IHdpbi5ldmVudDtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBlLndoZWVsRGVsdGEgfHwgLWUuZGVsdGFZIHx8IC1lLmRldGFpbDtcbiAgICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgdmFsdWUpKTtcbiAgICAgICAgICB2YXIgaG9yaXpvbnRhbERldGVjdGlvbiA9IHR5cGVvZiBlLndoZWVsRGVsdGFYICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZS5kZWx0YVggIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgIGlzU2Nyb2xsaW5nVmVydGljYWxseSA9IE1hdGguYWJzKGUud2hlZWxEZWx0YVgpIDwgTWF0aC5hYnMoZS53aGVlbERlbHRhKSB8fCBNYXRoLmFicyhlLmRlbHRhWCkgPCBNYXRoLmFicyhlLmRlbHRhWSkgfHwgIWhvcml6b250YWxEZXRlY3Rpb247XG4gICAgICAgICAgdmFyIGN1clRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICBkaXJlY3Rpb24gPSBkZWx0YSA8IDAgPyAnZG93bicgOiAndXAnOyAvL0xpbWl0aW5nIHRoZSBhcnJheSB0byAxNTAgKGxldHMgbm90IHdhc3RlIG1lbW9yeSEpXG5cbiAgICAgICAgICBpZiAoX3Njcm9sbGluZ3MubGVuZ3RoID4gMTQ5KSB7XG4gICAgICAgICAgICBfc2Nyb2xsaW5ncy5zaGlmdCgpO1xuICAgICAgICAgIH0gLy9rZWVwaW5nIHJlY29yZCBvZiB0aGUgcHJldmlvdXMgc2Nyb2xsaW5nc1xuXG5cbiAgICAgICAgICBfc2Nyb2xsaW5ncy5wdXNoKE1hdGguYWJzKHZhbHVlKSk7IC8vdGltZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGxhc3Qgc2Nyb2xsIGFuZCB0aGUgY3VycmVudCBvbmVcblxuXG4gICAgICAgICAgdmFyIHRpbWVEaWZmID0gY3VyVGltZSAtIF9wcmV2VGltZTtcbiAgICAgICAgICBfcHJldlRpbWUgPSBjdXJUaW1lOyAvL2hhdmVuJ3QgdGhleSBzY3JvbGxlZCBpbiBhIHdoaWxlP1xuICAgICAgICAgIC8vKGVub3VnaCB0byBiZSBjb25zaWRlciBhIGRpZmZlcmVudCBzY3JvbGxpbmcgYWN0aW9uIHRvIHNjcm9sbCBhbm90aGVyIHNlY3Rpb24pXG5cbiAgICAgICAgICBpZiAodGltZURpZmYgPiAyMDApIHtcbiAgICAgICAgICAgIC8vZW1wdHlpbmcgdGhlIGFycmF5LCB3ZSBkb250IGNhcmUgYWJvdXQgb2xkIHNjcm9sbGluZ3MgZm9yIG91ciBhdmVyYWdlc1xuICAgICAgICAgICAgX3Njcm9sbGluZ3MgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzQWNjZWxlcmF0aW5nOiBmdW5jdGlvbiBpc0FjY2VsZXJhdGluZygpIHtcbiAgICAgICAgICB2YXIgYXZlcmFnZUVuZCA9IGdldEF2ZXJhZ2UoX3Njcm9sbGluZ3MsIDEwKTtcbiAgICAgICAgICB2YXIgYXZlcmFnZU1pZGRsZSA9IGdldEF2ZXJhZ2UoX3Njcm9sbGluZ3MsIDcwKTtcbiAgICAgICAgICB2YXIgaXNBY2NlbGVyYXRpbmcgPSBhdmVyYWdlRW5kID49IGF2ZXJhZ2VNaWRkbGU7XG4gICAgICAgICAgcmV0dXJuIF9zY3JvbGxpbmdzLmxlbmd0aCA/IGlzQWNjZWxlcmF0aW5nICYmIGlzU2Nyb2xsaW5nVmVydGljYWxseSA6IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBnZXREaXJlY3Rpb246IGZ1bmN0aW9uIGdldERpcmVjdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGZ1bmN0aW9uIHNjcm9sbEJleW9uZEZ1bGxQYWdlKCkge1xuICAgICAgdmFyIGR0b3AgPSBnZXREZXN0aW5hdGlvbk9mZnNldCgpO1xuICAgICAgdmFyIHNjcm9sbFNldHRpbmdzID0gZ2V0U2Nyb2xsU2V0dGluZ3MoZHRvcCk7XG4gICAgICBGUC50ZXN0LnRvcCA9IC1kdG9wICsgJ3B4JztcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgY2FuU2Nyb2xsOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBzY3JvbGxUbyhzY3JvbGxTZXR0aW5ncy5lbGVtZW50LCBzY3JvbGxTZXR0aW5ncy5vcHRpb25zLCBnZXRPcHRpb25zKCkuc2Nyb2xsaW5nU3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXNCZXlvbmRGdWxscGFnZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGNhblNjcm9sbDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAzMCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKCkge1xuICAgICAgaWYgKCFpc0Z1bGxQYWdlQWJvdmUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY3JvbGxVcFRvRnVsbHBhZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nyb2xsVXBUb0Z1bGxwYWdlKCkge1xuICAgICAgdmFyIHNjcm9sbFNldHRpbmdzID0gZ2V0U2Nyb2xsU2V0dGluZ3MoZ2V0TGFzdChnZXRTdGF0ZSgpLnNlY3Rpb25zKS5pdGVtLm9mZnNldFRvcCk7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGNhblNjcm9sbDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgc2Nyb2xsVG8oc2Nyb2xsU2V0dGluZ3MuZWxlbWVudCwgc2Nyb2xsU2V0dGluZ3Mub3B0aW9ucywgZ2V0T3B0aW9ucygpLnNjcm9sbGluZ1NwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBjYW5TY3JvbGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0JleW9uZEZ1bGxwYWdlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzQWJvdXRUb1Njcm9sbFRvRnVsbFBhZ2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGVzdGluYXRpb25PZmZzZXQoKSB7XG4gICAgICBpZiAoIWdldE9wdGlvbnMoKS5jc3MzKSB7XG4gICAgICAgIHJldHVybiBnZXRMYXN0KGdldFN0YXRlKCkuc2VjdGlvbnMpLml0ZW0ub2Zmc2V0VG9wICsgZ2V0TGFzdChnZXRTdGF0ZSgpLnNlY3Rpb25zKS5pdGVtLm9mZnNldEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFNjcm9sbFRvcCgpICsgZ2V0V2luZG93SGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmV5b25kRnVsbFBhZ2VIYW5kbGVyKGNvbnRhaW5lciwgZSkge1xuICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB2YXIgcGF1c2VTY3JvbGwgPSBnZXRTdGF0ZSgpLmlzQmV5b25kRnVsbHBhZ2UgJiYgY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSA+PSAwICYmIHdoZWVsRGF0YUhhbmRsZXIuZ2V0RGlyZWN0aW9uKCkgPT09ICd1cCc7XG4gICAgICB2YXIgZ19pc0Fib3V0VG9TY3JvbGxUb0Z1bGxQYWdlID0gZ2V0U3RhdGUoKS5pc0Fib3V0VG9TY3JvbGxUb0Z1bGxQYWdlO1xuXG4gICAgICBpZiAoZ19pc0Fib3V0VG9TY3JvbGxUb0Z1bGxQYWdlKSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRTdGF0ZSgpLmlzQmV5b25kRnVsbHBhZ2UpIHtcbiAgICAgICAgaWYgKCFwYXVzZVNjcm9sbCkge1xuICAgICAgICAgIGtleWZyYW1lVGltZSgnc2V0JywgJ2JleW9uZEZ1bGxwYWdlJywgMTAwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNob3VsZFNldEZpeGVkUG9zaXRpb24gPSAhZ19pc0Fib3V0VG9TY3JvbGxUb0Z1bGxQYWdlICYmICgha2V5ZnJhbWVUaW1lKCdpc05ld0tleWZyYW1lJywgJ2JleW9uZEZ1bGxwYWdlJykgfHwgIXdoZWVsRGF0YUhhbmRsZXIuaXNBY2NlbGVyYXRpbmcoKSk7XG4gICAgICAgICAgdmFyIHNjcm9sbFNldHRpbmdzO1xuXG4gICAgICAgICAgaWYgKHNob3VsZFNldEZpeGVkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHNjcm9sbFNldHRpbmdzID0gZ2V0U2Nyb2xsU2V0dGluZ3MoZ2V0TGFzdChnZXRTdGF0ZSgpLnNlY3Rpb25zKS5pdGVtLm9mZnNldFRvcCArIGdldExhc3QoZ2V0U3RhdGUoKS5zZWN0aW9ucykuaXRlbS5vZmZzZXRIZWlnaHQpO1xuICAgICAgICAgICAgc2Nyb2xsU2V0dGluZ3MuZWxlbWVudC5zY3JvbGxUbygwLCBzY3JvbGxTZXR0aW5ncy5vcHRpb25zKTtcbiAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgaXNBYm91dFRvU2Nyb2xsVG9GdWxsUGFnZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmICh3aGVlbERhdGFIYW5kbGVyLmlzQWNjZWxlcmF0aW5nKCkpIHtcbiAgICAgICAgICAgIHBhdXNlU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIGlzQWJvdXRUb1Njcm9sbFRvRnVsbFBhZ2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgICBzY3JvbGxUcmlnZ2VyOiAnd2hlZWwnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNjcm9sbFVwVG9GdWxscGFnZSgpO1xuICAgICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFnX2lzQWJvdXRUb1Njcm9sbFRvRnVsbFBhZ2UpIHtcbiAgICAgICAgICAvLyBhbGxvdyBub3JtYWwgc2Nyb2xsaW5nLCBidXQgcXVpdHRpbmdcbiAgICAgICAgICBpZiAoIXBhdXNlU2Nyb2xsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5ZnJhbWVUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlzTmV3ID0gZmFsc2U7XG4gICAgICB2YXIgZnJhbWVzID0ge307XG4gICAgICB2YXIgdGltZWZyYW1lcyA9IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24sIG5hbWUsIHRpbWVmcmFtZSkge1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICBmcmFtZXNbbmFtZV0gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRpbWVmcmFtZXNbbmFtZV0gPSB0aW1lZnJhbWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2lzTmV3S2V5ZnJhbWUnOlxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGlzTmV3ID0gY3VycmVudCAtIGZyYW1lc1tuYW1lXSA+IHRpbWVmcmFtZXNbbmFtZV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc05ldztcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgRlAubW92ZVNlY3Rpb25Eb3duID0gbW92ZVNlY3Rpb25Eb3duO1xuICAgIC8qKlxuICAgICogTW92ZXMgdGhlIHBhZ2UgZG93biBvbmUgc2VjdGlvbi5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gbW92ZVNlY3Rpb25Eb3duKCkge1xuICAgICAgdmFyIG5leHQgPSBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24ubmV4dCgpOyAvL2xvb3BpbmcgdG8gdGhlIHRvcCBpZiB0aGVyZSdzIG5vIG1vcmUgc2VjdGlvbnMgYmVsb3dcblxuICAgICAgaWYgKCFuZXh0ICYmIChnZXRPcHRpb25zKCkubG9vcEJvdHRvbSB8fCBnZXRPcHRpb25zKCkuY29udGludW91c1ZlcnRpY2FsKSkge1xuICAgICAgICBuZXh0ID0gZ2V0U3RhdGUoKS5zZWN0aW9uc1swXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICBzY3JvbGxQYWdlKG5leHQsIG51bGwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQ29udGVudEJleW9uZEZ1bGxQYWdlKCkpIHtcbiAgICAgICAgRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRzLnNjcm9sbEJleW9uZEZ1bGxwYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNDb250ZW50QmV5b25kRnVsbFBhZ2UoKSB7XG4gICAgICByZXR1cm4gZ2V0Q29udGFpbmVyKCkuc2Nyb2xsSGVpZ2h0IDwgJGJvZHkuc2Nyb2xsSGVpZ2h0ICYmIGdldE9wdGlvbnMoKS5zY3JvbGxCYXIgJiYgZ2V0T3B0aW9ucygpLnNjcm9sbEJleW9uZEZ1bGxwYWdlO1xuICAgIH1cblxuICAgIEZQLm1vdmVTZWN0aW9uVXAgPSBtb3ZlU2VjdGlvblVwO1xuICAgIC8qKlxuICAgICogTW92ZXMgdGhlIHBhZ2UgdXAgb25lIHNlY3Rpb24uXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIG1vdmVTZWN0aW9uVXAoKSB7XG4gICAgICB2YXIgcHJldiA9IGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5wcmV2KCk7IC8vbG9vcGluZyB0byB0aGUgYm90dG9tIGlmIHRoZXJlJ3Mgbm8gbW9yZSBzZWN0aW9ucyBhYm92ZVxuXG4gICAgICBpZiAoIXByZXYgJiYgKGdldE9wdGlvbnMoKS5sb29wVG9wIHx8IGdldE9wdGlvbnMoKS5jb250aW51b3VzVmVydGljYWwpKSB7XG4gICAgICAgIHByZXYgPSBnZXRMYXN0KGdldFN0YXRlKCkuc2VjdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldiAhPSBudWxsKSB7XG4gICAgICAgIHNjcm9sbFBhZ2UocHJldiwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9sZFBhZ2VZID0gMDtcbiAgICAvKipcbiAgICAqIERldGVjdGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtb3VzZSBtb3ZlbWVudC5cbiAgICAqIFVzZWQgb25seSBmb3IgdGhlIG1pZGRsZSBidXR0b24gb2YgdGhlIG1vdXNlLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBtb3VzZU1vdmVIYW5kbGVyKGUpIHtcbiAgICAgIGlmICghZ2V0T3B0aW9ucygpLmF1dG9TY3JvbGxpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuY2FuU2Nyb2xsKSB7XG4gICAgICAgIC8vIG1vdmluZyB1cFxuICAgICAgICBpZiAoZS5wYWdlWSA8IG9sZFBhZ2VZICYmIGdldElzU2Nyb2xsQWxsb3dlZCgpLm0udXApIHtcbiAgICAgICAgICBtb3ZlU2VjdGlvblVwKCk7XG4gICAgICAgIH0gLy8gbW92aW5nIGRvd25cbiAgICAgICAgZWxzZSBpZiAoZS5wYWdlWSA+IG9sZFBhZ2VZICYmIGdldElzU2Nyb2xsQWxsb3dlZCgpLm0uZG93bikge1xuICAgICAgICAgIG1vdmVTZWN0aW9uRG93bigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9sZFBhZ2VZID0gZS5wYWdlWTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0T2xkUGFnZVkodmFsdWUpIHtcbiAgICAgIG9sZFBhZ2VZID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmVzIHRoZSB3YXkgb2Ygc2Nyb2xsaW5nIHVwIG9yIGRvd246XG4gICAgKiBieSAnYXV0b21hdGljYWxseScgc2Nyb2xsaW5nIGEgc2VjdGlvbiBvciBieSB1c2luZyB0aGUgZGVmYXVsdCBhbmQgbm9ybWFsIHNjcm9sbGluZy5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2Nyb2xsaW5nKHR5cGUpIHtcbiAgICAgIGlmICghZ2V0SXNTY3JvbGxBbGxvd2VkKCkubVt0eXBlXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzY3JvbGxTZWN0aW9uID0gdHlwZSA9PT0gJ2Rvd24nID8gbW92ZVNlY3Rpb25Eb3duIDogbW92ZVNlY3Rpb25VcDtcblxuICAgICAgaWYgKGdldE9wdGlvbnMoKS5zY3JvbGxPdmVyZmxvdyAmJiBzY3JvbGxPdmVyZmxvd0hhbmRsZXIuaXNTY3JvbGxhYmxlKGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbikpIHtcbiAgICAgICAgLy9pcyB0aGUgc2Nyb2xsYmFyIGF0IHRoZSBzdGFydC9lbmQgb2YgdGhlIHNjcm9sbD9cbiAgICAgICAgaWYgKHNjcm9sbE92ZXJmbG93SGFuZGxlci5pc1Njcm9sbGVkKHR5cGUsIGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtKSAmJiBzY3JvbGxPdmVyZmxvd0hhbmRsZXIuc2hvdWxkTW92ZVBhZ2UoKSkge1xuICAgICAgICAgIHNjcm9sbFNlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsU2VjdGlvbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0b3VjaFN0YXJ0WSA9IDA7XG4gICAgdmFyIHRvdWNoU3RhcnRYID0gMDtcbiAgICB2YXIgdG91Y2hFbmRZID0gMDtcbiAgICB2YXIgdG91Y2hFbmRYID0gMDtcbiAgICB2YXIgTVNQb2ludGVyID0gZ2V0TVNQb2ludGVyKCk7XG4gICAgdmFyIHBvaW50ZXJzID0ge1xuICAgICAgdG91Y2htb3ZlOiAnb250b3VjaG1vdmUnIGluIHdpbmRvdyA/ICd0b3VjaG1vdmUnIDogTVNQb2ludGVyID8gTVNQb2ludGVyLm1vdmUgOiBudWxsLFxuICAgICAgdG91Y2hzdGFydDogJ29udG91Y2hzdGFydCcgaW4gd2luZG93ID8gJ3RvdWNoc3RhcnQnIDogTVNQb2ludGVyID8gTVNQb2ludGVyLmRvd24gOiBudWxsXG4gICAgfTtcbiAgICAvKipcbiAgICAqIEFkZHMgdGhlIHBvc3NpYmlsaXR5IHRvIGF1dG8gc2Nyb2xsIHRocm91Z2ggc2VjdGlvbnMgb24gdG91Y2ggZGV2aWNlcy5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gYWRkVG91Y2hIYW5kbGVyKCkge1xuICAgICAgaWYgKCFwb2ludGVycy50b3VjaG1vdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNUb3VjaERldmljZSB8fCBpc1RvdWNoKSB7XG4gICAgICAgIGlmIChnZXRPcHRpb25zKCkuYXV0b1Njcm9sbGluZykge1xuICAgICAgICAgICRib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIocG9pbnRlcnMudG91Y2htb3ZlLCBwcmV2ZW50Qm91bmNpbmcsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgJGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihwb2ludGVycy50b3VjaG1vdmUsIHByZXZlbnRCb3VuY2luZywge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaFdyYXBwZXIgPSBnZXRPcHRpb25zKCkudG91Y2hXcmFwcGVyO1xuICAgICAgICB0b3VjaFdyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihwb2ludGVycy50b3VjaHN0YXJ0LCB0b3VjaFN0YXJ0SGFuZGxlcik7XG4gICAgICAgIHRvdWNoV3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKHBvaW50ZXJzLnRvdWNobW92ZSwgdG91Y2hNb3ZlSGFuZGxlciwge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0b3VjaFdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihwb2ludGVycy50b3VjaHN0YXJ0LCB0b3VjaFN0YXJ0SGFuZGxlcik7XG4gICAgICAgIHRvdWNoV3JhcHBlci5hZGRFdmVudExpc3RlbmVyKHBvaW50ZXJzLnRvdWNobW92ZSwgdG91Y2hNb3ZlSGFuZGxlciwge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIFJlbW92ZXMgdGhlIGF1dG8gc2Nyb2xsaW5nIGZvciB0b3VjaCBkZXZpY2VzLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiByZW1vdmVUb3VjaEhhbmRsZXIoKSB7XG4gICAgICBpZiAoIXBvaW50ZXJzLnRvdWNobW92ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1RvdWNoRGV2aWNlIHx8IGlzVG91Y2gpIHtcbiAgICAgICAgLy8gbm9ybWFsU2Nyb2xsRWxlbWVudHMgcmVxdWlyZXMgaXQgb2ZmICMyNjkxXG4gICAgICAgIGlmIChnZXRPcHRpb25zKCkuYXV0b1Njcm9sbGluZykge1xuICAgICAgICAgICRib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIocG9pbnRlcnMudG91Y2htb3ZlLCB0b3VjaE1vdmVIYW5kbGVyLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgICRib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIocG9pbnRlcnMudG91Y2htb3ZlLCBwcmV2ZW50Qm91bmNpbmcsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hXcmFwcGVyID0gZ2V0T3B0aW9ucygpLnRvdWNoV3JhcHBlcjtcbiAgICAgICAgdG91Y2hXcmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIocG9pbnRlcnMudG91Y2hzdGFydCwgdG91Y2hTdGFydEhhbmRsZXIpO1xuICAgICAgICB0b3VjaFdyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihwb2ludGVycy50b3VjaG1vdmUsIHRvdWNoTW92ZUhhbmRsZXIsIHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogRGV0ZWN0aW5nIHRvdWNoIGV2ZW50c1xuXG4gICAgKiBBcyB3ZSBhcmUgY2hhbmdpbmcgdGhlIHRvcCBwcm9wZXJ0eSBvZiB0aGUgcGFnZSBvbiBzY3JvbGxpbmcsIHdlIGNhbiBub3QgdXNlIHRoZSB0cmFkaXRpb25hbCB3YXkgdG8gZGV0ZWN0IGl0LlxuICAgICogVGhpcyB3YXksIHRoZSB0b3VjaHN0YXJ0IGFuZCB0aGUgdG91Y2ggbW92ZXMgc2hvd3MgYW4gc21hbGwgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZW0gd2hpY2ggaXMgdGhlXG4gICAgKiB1c2VkIG9uZSB0byBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbi5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gdG91Y2hNb3ZlSGFuZGxlcihlKSB7XG4gICAgICB2YXIgYWN0aXZlU2VjdGlvbiA9IGNsb3Nlc3QoZS50YXJnZXQsIFNFQ1RJT05fU0VMKSB8fCBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uaXRlbTtcbiAgICAgIHZhciBoYXNBY3RpdmVTZWN0aW9uT3ZlcmZsb3cgPSBzY3JvbGxPdmVyZmxvd0hhbmRsZXIuaXNTY3JvbGxhYmxlKGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbik7XG5cbiAgICAgIGlmIChpc1JlYWxseVRvdWNoKGUpKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0dyYWJiaW5nOiB0cnVlLFxuICAgICAgICAgIGlzVXNpbmdXaGVlbDogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGdldE9wdGlvbnMoKS5hdXRvU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgaWYgKGhhc0FjdGl2ZVNlY3Rpb25PdmVyZmxvdyAmJiAhc3RhdGUuY2FuU2Nyb2xsIHx8IGdldE9wdGlvbnMoKS5zY3JvbGxCYXIpIHtcbiAgICAgICAgICAgIC8vcHJldmVudGluZyB0aGUgZWFzaW5nIG9uIGlPUyBkZXZpY2VzXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hFdmVudHMgPSBnZXRFdmVudHNQYWdlKGUpO1xuICAgICAgICB0b3VjaEVuZFkgPSB0b3VjaEV2ZW50cy55O1xuICAgICAgICB0b3VjaEVuZFggPSB0b3VjaEV2ZW50cy54O1xuICAgICAgICB2YXIgaXNWZXJ0aWNhbE1vdmVtZW50RW5vdWdoID0gTWF0aC5hYnModG91Y2hTdGFydFkgLSB0b3VjaEVuZFkpID4gd2luLmlubmVySGVpZ2h0IC8gMTAwICogZ2V0T3B0aW9ucygpLnRvdWNoU2Vuc2l0aXZpdHk7XG4gICAgICAgIHZhciBpc0hvcml6b250YWxNb3ZlbWVudEVub3VnaCA9IE1hdGguYWJzKHRvdWNoU3RhcnRYIC0gdG91Y2hFbmRYKSA+IGdldFdpbmRvd1dpZHRoKCkgLyAxMDAgKiBnZXRPcHRpb25zKCkudG91Y2hTZW5zaXRpdml0eTtcbiAgICAgICAgdmFyIGlzSG9yaXpvbnRhbFByZWRvbWluYW50TW92ZSA9ICQoU0xJREVTX1dSQVBQRVJfU0VMLCBhY3RpdmVTZWN0aW9uKS5sZW5ndGggJiYgTWF0aC5hYnModG91Y2hTdGFydFggLSB0b3VjaEVuZFgpID4gTWF0aC5hYnModG91Y2hTdGFydFkgLSB0b3VjaEVuZFkpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uSCA9IHRvdWNoU3RhcnRYID4gdG91Y2hFbmRYID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgdmFyIGRpcmVjdGlvblYgPSB0b3VjaFN0YXJ0WSA+IHRvdWNoRW5kWSA/ICdkb3duJyA6ICd1cCc7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBpc0hvcml6b250YWxQcmVkb21pbmFudE1vdmUgPyBkaXJlY3Rpb25IIDogZGlyZWN0aW9uVjtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIHRvdWNoRGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfSk7IC8vaWYgbW92ZW1lbnQgaW4gdGhlIFggYXh5cyBpcyBncmVhdGVyIHRoYW4gaW4gdGhlIFkgYW5kIHRoZSBjdXJyZWN0IHNlY3Rpb24gaGFzIHNsaWRlcy4uLlxuXG4gICAgICAgIGlmIChpc0hvcml6b250YWxQcmVkb21pbmFudE1vdmUpIHtcbiAgICAgICAgICAvL2lzIHRoZSBtb3ZlbWVudCBncmVhdGVyIHRoYW4gdGhlIG1pbmltdW0gcmVzaXN0YW5jZSB0byBzY3JvbGw/XG4gICAgICAgICAgaWYgKCFzdGF0ZS5zbGlkZU1vdmluZyAmJiBpc0hvcml6b250YWxNb3ZlbWVudEVub3VnaCkge1xuICAgICAgICAgICAgaWYgKHRvdWNoU3RhcnRYID4gdG91Y2hFbmRYKSB7XG4gICAgICAgICAgICAgIGlmIChnZXRJc1Njcm9sbEFsbG93ZWQoKS5tLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRzLm1vdmVTbGlkZVJpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICBzZWN0aW9uOiBhY3RpdmVTZWN0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChnZXRJc1Njcm9sbEFsbG93ZWQoKS5tLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBFdmVudEVtaXR0ZXIuZW1pdChldmVudHMubW92ZVNsaWRlTGVmdCwge1xuICAgICAgICAgICAgICAgICAgc2VjdGlvbjogYWN0aXZlU2VjdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vdmVydGljYWwgc2Nyb2xsaW5nIChvbmx5IHdoZW4gYXV0b1Njcm9sbGluZyBpcyBlbmFibGVkKVxuICAgICAgICBlbHNlIGlmIChnZXRPcHRpb25zKCkuYXV0b1Njcm9sbGluZyAmJiBzdGF0ZS5jYW5TY3JvbGwpIHtcbiAgICAgICAgICAvL2lzIHRoZSBtb3ZlbWVudCBncmVhdGVyIHRoYW4gdGhlIG1pbmltdW0gcmVzaXN0YW5jZSB0byBzY3JvbGw/XG4gICAgICAgICAgaWYgKGlzVmVydGljYWxNb3ZlbWVudEVub3VnaCkge1xuICAgICAgICAgICAgc2Nyb2xsaW5nKGRpcmVjdGlvblYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEFzIElFID49IDEwIGZpcmVzIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50cyB3aGVuIHVzaW5nIGEgbW91c2UgaW4gYSB0b3VjaHNjcmVlblxuICAgICogdGhpcyB3YXkgd2UgbWFrZSBzdXJlIHRoYXQgaXMgcmVhbGx5IGEgdG91Y2ggZXZlbnQgd2hhdCBJRSBpcyBkZXRlY3RpbmcuXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gaXNSZWFsbHlUb3VjaChlKSB7XG4gICAgICAvL2lmIGlzIG5vdCBJRSAgIHx8ICBJRSBpcyBkZXRlY3RpbmcgYHRvdWNoYCBvciBgcGVuYFxuICAgICAgcmV0dXJuIHR5cGVvZiBlLnBvaW50ZXJUeXBlID09PSAndW5kZWZpbmVkJyB8fCBlLnBvaW50ZXJUeXBlICE9ICdtb3VzZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICogSGFuZGxlciBmb3IgdGhlIHRvdWNoIHN0YXJ0IGV2ZW50LlxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHRvdWNoU3RhcnRIYW5kbGVyKGUpIHtcbiAgICAgIC8vc3RvcHBpbmcgdGhlIGF1dG8gc2Nyb2xsIHRvIGFkanVzdCB0byBhIHNlY3Rpb25cbiAgICAgIGlmIChnZXRPcHRpb25zKCkuZml0VG9TZWN0aW9uKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3RpdmVBbmltYXRpb246IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNSZWFsbHlUb3VjaChlKSkge1xuICAgICAgICB2YXIgdG91Y2hFdmVudHMgPSBnZXRFdmVudHNQYWdlKGUpO1xuICAgICAgICB0b3VjaFN0YXJ0WSA9IHRvdWNoRXZlbnRzLnk7XG4gICAgICAgIHRvdWNoU3RhcnRYID0gdG91Y2hFdmVudHMueDtcbiAgICAgIH1cblxuICAgICAgd2luZG93QWRkRXZlbnQoJ3RvdWNoZW5kJywgdG91Y2hFbmRIYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBIYW5kbGVyIGZvciB0aGUgdG91Y2ggZW5kIGV2ZW50LlxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHRvdWNoRW5kSGFuZGxlcigpIHtcbiAgICAgIHdpbmRvd1JlbW92ZUV2ZW50KCd0b3VjaGVuZCcsIHRvdWNoRW5kSGFuZGxlcik7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGlzR3JhYmJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBHZXRzIHRoZSBwYWdlWCBhbmQgcGFnZVkgcHJvcGVydGllcyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIuXG4gICAgKiBodHRwczovL2dpdGh1Yi5jb20vYWx2YXJvdHJpZ28vZnVsbFBhZ2UuanMvaXNzdWVzLzE5NCNpc3N1ZWNvbW1lbnQtMzQwNjk4NTRcbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBnZXRFdmVudHNQYWdlKGUpIHtcbiAgICAgIHZhciBldmVudHMgPSB7fTtcbiAgICAgIGV2ZW50cy55ID0gdHlwZW9mIGUucGFnZVkgIT09ICd1bmRlZmluZWQnICYmIChlLnBhZ2VZIHx8IGUucGFnZVgpID8gZS5wYWdlWSA6IGUudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgIGV2ZW50cy54ID0gdHlwZW9mIGUucGFnZVggIT09ICd1bmRlZmluZWQnICYmIChlLnBhZ2VZIHx8IGUucGFnZVgpID8gZS5wYWdlWCA6IGUudG91Y2hlc1swXS5wYWdlWDsgLy9pbiB0b3VjaCBkZXZpY2VzIHdpdGggc2Nyb2xsQmFyOnRydWUsIGUucGFnZVkgaXMgZGV0ZWN0ZWQsIGJ1dCB3ZSBoYXZlIHRvIGRlYWwgd2l0aCB0b3VjaCBldmVudHMuICMxMDA4XG5cbiAgICAgIGlmIChpc1RvdWNoICYmIGlzUmVhbGx5VG91Y2goZSkgJiYgZ2V0T3B0aW9ucygpLnNjcm9sbEJhciAmJiB0eXBlb2YgZS50b3VjaGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBldmVudHMueSA9IGUudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgZXZlbnRzLnggPSBlLnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudHM7XG4gICAgfVxuICAgIC8qXG4gICAgKiBSZXR1cm5zIGFuZCBvYmplY3Qgd2l0aCBNaWNyb3NvZnQgcG9pbnRlcnMgKGZvciBJRTwxMSBhbmQgZm9yIElFID49IDExKVxuICAgICogaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2RuMzA0ODg2KHY9dnMuODUpLmFzcHhcbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBnZXRNU1BvaW50ZXIoKSB7XG4gICAgICB2YXIgcG9pbnRlcjsgLy9JRSA+PSAxMSAmIHJlc3Qgb2YgYnJvd3NlcnNcblxuICAgICAgaWYgKHdpbi5Qb2ludGVyRXZlbnQpIHtcbiAgICAgICAgcG9pbnRlciA9IHtcbiAgICAgICAgICBkb3duOiAncG9pbnRlcmRvd24nLFxuICAgICAgICAgIG1vdmU6ICdwb2ludGVybW92ZSdcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvaW50ZXI7XG4gICAgfVxuICAgIC8qXG4gICAgKiBQcmV2ZW50aW5nIGJvdW5jaW5nIGluIGlPUyAjMjI4NVxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHByZXZlbnRCb3VuY2luZyhlKSB7XG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLmF1dG9TY3JvbGxpbmcgJiYgaXNSZWFsbHlUb3VjaChlKSAmJiBnZXRJc1Njcm9sbEFsbG93ZWQoKS5tLnVwKSB7XG4gICAgICAgIC8vcHJldmVudGluZyB0aGUgZWFzaW5nIG9uIGlPUyBkZXZpY2VzXG4gICAgICAgIGlmICghc3RhdGUuY2FuU2Nyb2xsKSB7XG4gICAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBGUC5tb3ZlU2xpZGVMZWZ0ID0gbW92ZVNsaWRlTGVmdDtcbiAgICBGUC5tb3ZlU2xpZGVSaWdodCA9IG1vdmVTbGlkZVJpZ2h0O1xuICAgIC8qKlxuICAgICogU2xpZGVzIGEgc2xpZGVyIHRvIHRoZSBnaXZlbiBkaXJlY3Rpb24uXG4gICAgKiBPcHRpb25hbCBgc2VjdGlvbmAgcGFyYW0uXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIG1vdmVTbGlkZShkaXJlY3Rpb24sIHNlY3Rpb24pIHtcbiAgICAgIHZhciBhY3RpdmVTZWN0aW9uSXRlbSA9IHNlY3Rpb24gPT0gbnVsbCA/IGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtIDogc2VjdGlvbjtcbiAgICAgIHZhciBhY3RpdmVTZWN0aW9uID0gZ2V0UGFuZWxCeUVsZW1lbnQoc3RhdGUuc2VjdGlvbnMsIGFjdGl2ZVNlY3Rpb25JdGVtKTtcbiAgICAgIHZhciBzbGlkZXMgPSAkKFNMSURFU19XUkFQUEVSX1NFTCwgYWN0aXZlU2VjdGlvbkl0ZW0pWzBdOyAvLyBtb3JlIHRoYW4gb25lIHNsaWRlIG5lZWRlZCBhbmQgbm90aGluZyBzaG91bGQgYmUgc2xpZGluZ1xuXG4gICAgICBpZiAoc2xpZGVzID09IG51bGwgfHwgc3RhdGUuc2xpZGVNb3ZpbmcgfHwgYWN0aXZlU2VjdGlvbi5zbGlkZXMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50U2xpZGUgPSBhY3RpdmVTZWN0aW9uLmFjdGl2ZVNsaWRlO1xuICAgICAgdmFyIGRlc3RpbnkgPSBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/IGN1cnJlbnRTbGlkZS5wcmV2KCkgOiBjdXJyZW50U2xpZGUubmV4dCgpOyAvL2lzbid0IHRoZXJlIGEgbmV4dCBzbGlkZSBpbiB0aGUgc2VjdWVuY2U/XG5cbiAgICAgIGlmICghZGVzdGlueSkge1xuICAgICAgICAvL3Jlc3BlY3QgbG9vcEhvcml6b250YWwgc2V0dGluZ1xuICAgICAgICBpZiAoIWdldE9wdGlvbnMoKS5sb29wSG9yaXpvbnRhbCkgcmV0dXJuO1xuICAgICAgICBkZXN0aW55ID0gZGlyZWN0aW9uID09PSAnbGVmdCcgPyBnZXRMYXN0KGFjdGl2ZVNlY3Rpb24uc2xpZGVzKSA6IGFjdGl2ZVNlY3Rpb24uc2xpZGVzWzBdO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHNsaWRlTW92aW5nOiAhRlAudGVzdC5pc1Rlc3RpbmdcbiAgICAgIH0pO1xuICAgICAgbGFuZHNjYXBlU2Nyb2xsKHNsaWRlcywgZGVzdGlueS5pdGVtLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNsaWRlcyBsZWZ0IHRoZSBzbGlkZXIgb2YgdGhlIGFjdGl2ZSBzZWN0aW9uLlxuICAgICogT3B0aW9uYWwgYHNlY3Rpb25gIHBhcmFtLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBtb3ZlU2xpZGVMZWZ0KHNlY3Rpb24pIHtcbiAgICAgIG1vdmVTbGlkZSgnbGVmdCcsIHNlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNsaWRlcyByaWdodCB0aGUgc2xpZGVyIG9mIHRoZSBhY3RpdmUgc2VjdGlvbi5cbiAgICAqIE9wdGlvbmFsIGBzZWN0aW9uYCBwYXJhbS5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gbW92ZVNsaWRlUmlnaHQoc2VjdGlvbikge1xuICAgICAgbW92ZVNsaWRlKCdyaWdodCcsIHNlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogR2V0cyBhIHNlY3Rpb24gYnkgaXRzIGFuY2hvciAvIGluZGV4XG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25CeUFuY2hvcihzZWN0aW9uQW5jaG9yKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IGdldFN0YXRlKCkuc2VjdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBzZWN0aW9uLmFuY2hvciA9PT0gc2VjdGlvbkFuY2hvcjtcbiAgICAgIH0pWzBdO1xuXG4gICAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgICAgdmFyIHNlY3Rpb25JbmRleCA9IHR5cGVvZiBzZWN0aW9uQW5jaG9yICE9PSAndW5kZWZpbmVkJyA/IHNlY3Rpb25BbmNob3IgLSAxIDogMDtcbiAgICAgICAgc2VjdGlvbiA9IGdldFN0YXRlKCkuc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBTY3JvbGxzIHRoZSBzbGlkZXIgdG8gdGhlIGdpdmVuIHNsaWRlIGRlc3RpbmF0aW9uIGZvciB0aGUgZ2l2ZW4gc2VjdGlvblxuICAgICovXG5cbiAgICBmdW5jdGlvbiBzY3JvbGxTbGlkZXIoc2xpZGVFbGVtKSB7XG4gICAgICBpZiAoc2xpZGVFbGVtICE9IG51bGwpIHtcbiAgICAgICAgbGFuZHNjYXBlU2Nyb2xsKGNsb3Nlc3Qoc2xpZGVFbGVtLCBTTElERVNfV1JBUFBFUl9TRUwpLCBzbGlkZUVsZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogU2Nyb2xscyB0byB0aGUgZ2l2ZW4gc2VjdGlvbiBhbmQgc2xpZGUgYW5jaG9yc1xuICAgICovXG5cbiAgICBmdW5jdGlvbiBzY3JvbGxQYWdlQW5kU2xpZGUoc2VjdGlvbkFuY2hvciwgc2xpZGVBbmNob3IpIHtcbiAgICAgIHZhciBzZWN0aW9uID0gZ2V0U2VjdGlvbkJ5QW5jaG9yKHNlY3Rpb25BbmNob3IpOyAvL2RvIG5vdGhpbmcgaWYgdGhlcmUncyBubyBzZWN0aW9uIHdpdGggdGhlIGdpdmVuIGFuY2hvciBuYW1lXG5cbiAgICAgIGlmIChzZWN0aW9uID09IG51bGwpIHJldHVybjtcbiAgICAgIHZhciBzbGlkZUVsZW0gPSBnZXRTbGlkZUJ5QW5jaG9yKHNsaWRlQW5jaG9yLCBzZWN0aW9uKTsgLy93ZSBuZWVkIHRvIHNjcm9sbCB0byB0aGUgc2VjdGlvbiBhbmQgdGhlbiB0byB0aGUgc2xpZGVcblxuICAgICAgaWYgKCghc2VjdGlvbi5hbmNob3IgfHwgc2VjdGlvbi5hbmNob3IgIT09IHN0YXRlLmxhc3RTY3JvbGxlZERlc3RpbnkpICYmICFoYXNDbGFzcyhzZWN0aW9uLml0ZW0sIEFDVElWRSkpIHtcbiAgICAgICAgc2Nyb2xsUGFnZShzZWN0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2Nyb2xsU2xpZGVyKHNsaWRlRWxlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvL2lmIHdlIHdlcmUgYWxyZWFkeSBpbiB0aGUgc2VjdGlvblxuICAgICAgZWxzZSB7XG4gICAgICAgIHNjcm9sbFNsaWRlcihzbGlkZUVsZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgYSBzbGlkZSBpbnNpZGUgYSBnaXZlbiBzZWN0aW9uIGJ5IGl0cyBhbmNob3IgLyBpbmRleFxuICAgICovXG5cbiAgICBmdW5jdGlvbiBnZXRTbGlkZUJ5QW5jaG9yKHNsaWRlQW5jaG9yLCBzZWN0aW9uKSB7XG4gICAgICB2YXIgc2xpZGUgPSBzZWN0aW9uLnNsaWRlcy5maWx0ZXIoZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICAgIHJldHVybiBzbGlkZS5hbmNob3IgPT09IHNsaWRlQW5jaG9yO1xuICAgICAgfSlbMF07XG5cbiAgICAgIGlmIChzbGlkZSA9PSBudWxsKSB7XG4gICAgICAgIHNsaWRlQW5jaG9yID0gdHlwZW9mIHNsaWRlQW5jaG9yICE9PSAndW5kZWZpbmVkJyA/IHNsaWRlQW5jaG9yIDogMDtcbiAgICAgICAgc2xpZGUgPSBzZWN0aW9uLnNsaWRlc1tzbGlkZUFuY2hvcl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzbGlkZSA/IHNsaWRlLml0ZW0gOiBudWxsO1xuICAgIH1cblxuICAgIEZQLm1vdmVUbyA9IG1vdmVUbyQxO1xuICAgIC8qKlxuICAgICogTW92ZXMgdGhlIHBhZ2UgdG8gdGhlIGdpdmVuIHNlY3Rpb24gYW5kIHNsaWRlLlxuICAgICogQW5jaG9ycyBvciBpbmRleCBwb3NpdGlvbnMgY2FuIGJlIHVzZWQgYXMgcGFyYW1zLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBtb3ZlVG8kMShzZWN0aW9uQW5jaG9yLCBzbGlkZUFuY2hvcikge1xuICAgICAgdmFyIGRlc3RpbnkgPSBnZXRTZWN0aW9uQnlBbmNob3Ioc2VjdGlvbkFuY2hvcik7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVBbmNob3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNjcm9sbFBhZ2VBbmRTbGlkZShzZWN0aW9uQW5jaG9yLCBzbGlkZUFuY2hvcik7XG4gICAgICB9IGVsc2UgaWYgKGRlc3RpbnkgIT0gbnVsbCkge1xuICAgICAgICBzY3JvbGxQYWdlKGRlc3RpbnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vQHRzLWNoZWNrXG4gICAgdmFyIGdfY29udHJvbFByZXNzZWQ7XG4gICAgdmFyIGdfa2V5ZG93bklkO1xuICAgIHZhciBnX2VsVG9Gb2N1cztcbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLmJpbmRFdmVudHMsIGJpbmRFdmVudHMkOCk7XG5cbiAgICBmdW5jdGlvbiBiaW5kRXZlbnRzJDgoKSB7XG4gICAgICAvL3doZW4gb3BlbmluZyBhIG5ldyB0YWIgKGN0cmwgKyB0KSwgYGNvbnRyb2xgIHdvbid0IGJlIHByZXNzZWQgd2hlbiBjb21pbmcgYmFjay5cbiAgICAgIHdpbmRvd0FkZEV2ZW50KCdibHVyJywgYmx1ckhhbmRsZXIpOyAvL1NsaWRpbmcgd2l0aCBhcnJvdyBrZXlzLCBib3RoLCB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbFxuXG4gICAgICBkb2NBZGRFdmVudCgna2V5ZG93bicsIGtleWRvd25IYW5kbGVyKTsgLy90byBwcmV2ZW50IHNjcm9sbGluZyB3aGlsZSB6b29taW5nXG5cbiAgICAgIGRvY0FkZEV2ZW50KCdrZXl1cCcsIGtleVVwSGFuZGxlcik7XG4gICAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uRGVzdHJveSwgb25EZXN0cm95JDUpO1xuICAgICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5hZnRlclNsaWRlTG9hZHMsIG9uQWZ0ZXJTbGlkZUxvYWRzKTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYWZ0ZXJTZWN0aW9uTG9hZHMsIGFmdGVyU2VjdGlvbkxvYWRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRlc3Ryb3kkNSgpIHtcbiAgICAgIGNsZWFyVGltZW91dChnX2tleWRvd25JZCk7XG4gICAgICBkb2NSZW1vdmVFdmVudCgna2V5ZG93bicsIGtleWRvd25IYW5kbGVyKTtcbiAgICAgIGRvY1JlbW92ZUV2ZW50KCdrZXl1cCcsIGtleVVwSGFuZGxlcik7XG4gICAgfSAvL1NsaWRpbmcgd2l0aCBhcnJvdyBrZXlzLCBib3RoLCB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbFxuXG5cbiAgICBmdW5jdGlvbiBrZXlkb3duSGFuZGxlcihlKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZ19rZXlkb3duSWQpO1xuICAgICAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICB2YXIgaXNQcmVzc2luZ0hvcml6b250YWxBcnJvd3MgPSBbMzcsIDM5XS5pbmRleE9mKGtleUNvZGUpID4gLTE7XG4gICAgICB2YXIgY2FuU2Nyb2xsV2l0aEtleWJvYXJkID0gZ2V0T3B0aW9ucygpLmF1dG9TY3JvbGxpbmcgfHwgZ2V0T3B0aW9ucygpLmZpdFRvU2VjdGlvbiB8fCBpc1ByZXNzaW5nSG9yaXpvbnRhbEFycm93czsgLy90YWI/XG5cbiAgICAgIGlmIChrZXlDb2RlID09PSA5KSB7XG4gICAgICAgIG9uVGFiKGUpO1xuICAgICAgfSBlbHNlIGlmICghaXNJbnNpZGVJbnB1dCgpICYmIGdldE9wdGlvbnMoKS5rZXlib2FyZFNjcm9sbGluZyAmJiBjYW5TY3JvbGxXaXRoS2V5Ym9hcmQpIHtcbiAgICAgICAgZ19jb250cm9sUHJlc3NlZCA9IGUuY3RybEtleTtcbiAgICAgICAgZ19rZXlkb3duSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvbmtleWRvd24oZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEtleWRvd24gZXZlbnRcbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBvbmtleWRvd24oZSkge1xuICAgICAgdmFyIHNoaWZ0UHJlc3NlZCA9IGUuc2hpZnRLZXk7XG4gICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgICAgdmFyIGlzTWVkaWFGb2N1c2VkID0gbWF0Y2hlcyhhY3RpdmVFbGVtZW50LCAndmlkZW8nKSB8fCBtYXRjaGVzKGFjdGl2ZUVsZW1lbnQsICdhdWRpbycpO1xuICAgICAgdmFyIGlzU2Nyb2xsZWQgPSB7XG4gICAgICAgIHVwOiBzY3JvbGxPdmVyZmxvd0hhbmRsZXIuaXNTY3JvbGxlZCgndXAnLCBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uaXRlbSksXG4gICAgICAgIGRvd246IHNjcm9sbE92ZXJmbG93SGFuZGxlci5pc1Njcm9sbGVkKCdkb3duJywgZ2V0U3RhdGUoKS5hY3RpdmVTZWN0aW9uLml0ZW0pXG4gICAgICB9O1xuICAgICAgdmFyIGlzVXNpbmdIb3Jpem9udGFsQXJyb3dLZXlzID0gWzM3LCAzOV0uaW5kZXhPZihlLmtleUNvZGUpID4gLTE7XG4gICAgICBjYW5jZWxEaXJlY3Rpb25LZXlFdmVudHMoZSk7IC8vZG8gbm90aGluZyBpZiB3ZSBjYW4gbm90IHNjcm9sbCBvciB3ZSBhcmUgbm90IHVzaW5nIGhvcml6b3RuYWwga2V5IGFycm93cy5cblxuICAgICAgaWYgKCFzdGF0ZS5jYW5TY3JvbGwgJiYgIWlzVXNpbmdIb3Jpem9udGFsQXJyb3dLZXlzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBzY3JvbGxUcmlnZ2VyOiAna2V5ZG93bidcbiAgICAgIH0pO1xuXG4gICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAvL3VwXG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgaWYgKGdldElzU2Nyb2xsQWxsb3dlZCgpLmsudXAgJiYgaXNTY3JvbGxlZC51cCkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmlzQmV5b25kRnVsbHBhZ2UpIHtcbiAgICAgICAgICAgICAgRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRzLm9uS2V5RG93biwge1xuICAgICAgICAgICAgICAgIGU6IGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtb3ZlU2VjdGlvblVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbE92ZXJmbG93SGFuZGxlci5mb2N1c1Njcm9sbGFibGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9kb3duXG5cbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAvL3NwYWNlYmFyXG4gICAgICAgICAgaWYgKHNoaWZ0UHJlc3NlZCAmJiBnZXRJc1Njcm9sbEFsbG93ZWQoKS5rLnVwICYmICFpc01lZGlhRm9jdXNlZCAmJiBpc1Njcm9sbGVkLnVwKSB7XG4gICAgICAgICAgICBtb3ZlU2VjdGlvblVwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgaWYgKGdldElzU2Nyb2xsQWxsb3dlZCgpLmsuZG93biAmJiBpc1Njcm9sbGVkLmRvd24pIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0JleW9uZEZ1bGxwYWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gLy8gc3BhY2UgYmFyP1xuXG5cbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgIT09IDMyIHx8ICFpc01lZGlhRm9jdXNlZCkge1xuICAgICAgICAgICAgICBtb3ZlU2VjdGlvbkRvd24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLmZvY3VzU2Nyb2xsYWJsZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvL0hvbWVcblxuICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgIGlmIChnZXRJc1Njcm9sbEFsbG93ZWQoKS5rLnVwKSB7XG4gICAgICAgICAgICBtb3ZlVG8kMSgxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9FbmRcblxuICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgIGlmIChnZXRJc1Njcm9sbEFsbG93ZWQoKS5rLmRvd24pIHtcbiAgICAgICAgICAgIG1vdmVUbyQxKGdldFN0YXRlKCkuc2VjdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy9sZWZ0XG5cbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICBpZiAoZ2V0SXNTY3JvbGxBbGxvd2VkKCkuay5sZWZ0KSB7XG4gICAgICAgICAgICBtb3ZlU2xpZGVMZWZ0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vcmlnaHRcblxuICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgIGlmIChnZXRJc1Njcm9sbEFsbG93ZWQoKS5rLnJpZ2h0KSB7XG4gICAgICAgICAgICBtb3ZlU2xpZGVSaWdodCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBleGl0IHRoaXMgaGFuZGxlciBmb3Igb3RoZXIga2V5c1xuICAgICAgfVxuICAgIH0gLy90byBwcmV2ZW50IHNjcm9sbGluZyB3aGlsZSB6b29taW5nXG5cblxuICAgIGZ1bmN0aW9uIGtleVVwSGFuZGxlcihlKSB7XG4gICAgICBpZiAoc3RhdGUuaXNXaW5kb3dGb2N1c2VkKSB7XG4gICAgICAgIC8vdGhlIGtleXVwIGdldHMgZmlyZWQgb24gbmV3IHRhYiBjdHJsICsgdCBpbiBGaXJlZm94XG4gICAgICAgIGdfY29udHJvbFByZXNzZWQgPSBlLmN0cmxLZXk7XG4gICAgICB9XG4gICAgfSAvL3doZW4gb3BlbmluZyBhIG5ldyB0YWIgKGN0cmwgKyB0KSwgYGNvbnRyb2xgIHdvbid0IGJlIHByZXNzZWQgd2hlbiBjb21pbmcgYmFjay5cblxuXG4gICAgZnVuY3Rpb24gYmx1ckhhbmRsZXIoKSB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGlzV2luZG93Rm9jdXNlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZ19jb250cm9sUHJlc3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAqIE1ha2VzIHN1cmUgdGhlIHRhYiBrZXkgd2lsbCBvbmx5IGZvY3VzIGVsZW1lbnRzIHdpdGhpbiB0aGUgY3VycmVudCBzZWN0aW9uL3NsaWRlXG4gICAgKiBwcmV2ZW50aW5nIHRoaXMgd2F5IGZyb20gYnJlYWtpbmcgdGhlIHBhZ2UuXG4gICAgKiBCYXNlZCBvbiBcIk1vZGFscyBhbmQga2V5Ym9hcmQgdHJhcHNcIlxuICAgICogZnJvbSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL2FjY2Vzc2liaWxpdHkvZm9jdXMvdXNpbmctdGFiaW5kZXhcbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBvblRhYihlKSB7XG4gICAgICB2YXIgaXNTaGlmdFByZXNzZWQgPSBlLnNoaWZ0S2V5O1xuICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICAgIHZhciBmb2N1c2FibGVFbGVtZW50cyA9IGdldEZvY3VzYWJsZXMoZ2V0U2xpZGVPclNlY3Rpb24oZ2V0U3RhdGUoKS5hY3RpdmVTZWN0aW9uLml0ZW0pKTtcblxuICAgICAgZnVuY3Rpb24gcHJldmVudEFuZEZvY3VzRmlyc3QoZSkge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgcmV0dXJuIGZvY3VzYWJsZUVsZW1lbnRzWzBdID8gZm9jdXNhYmxlRWxlbWVudHNbMF0uZm9jdXMoKSA6IG51bGw7XG4gICAgICB9IC8vIGRlYWN0aXZhdGluZyB0YWIgd2hpbGUgc2Nyb2xsaW5nICM0NTUwXG5cblxuICAgICAgaWYgKCFzdGF0ZS5jYW5TY3JvbGwpIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy9vdXRzaWRlIGFueSBzZWN0aW9uIG9yIHNsaWRlPyBMZXQncyBub3QgaGlqYWNrIHRoZSB0YWIhXG5cblxuICAgICAgaWYgKGlzRm9jdXNPdXRzaWRlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy9pcyB0aGVyZSBhbiBlbGVtZW50IHdpdGggZm9jdXM/XG5cblxuICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGNsb3Nlc3QoYWN0aXZlRWxlbWVudCwgU0VDVElPTl9BQ1RJVkVfU0VMICsgJywnICsgU0VDVElPTl9BQ1RJVkVfU0VMICsgJyAnICsgU0xJREVfQUNUSVZFX1NFTCkgPT0gbnVsbCkge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBwcmV2ZW50QW5kRm9jdXNGaXJzdChlKTtcbiAgICAgICAgfVxuICAgICAgfSAvL25vIGVsZW1lbnQgaWYgZm9jdXNlZD8gTGV0J3MgZm9jdXMgdGhlIGZpcnN0IG9uZSBvZiB0aGUgc2VjdGlvbi9zbGlkZVxuICAgICAgZWxzZSB7XG4gICAgICAgIHByZXZlbnRBbmRGb2N1c0ZpcnN0KGUpO1xuICAgICAgfSAvL3doZW4gcmVhY2hlZCB0aGUgZmlyc3Qgb3IgbGFzdCBmb2N1c2FibGUgZWxlbWVudCBvZiB0aGUgc2VjdGlvbi9zbGlkZVxuICAgICAgLy93ZSBwcmV2ZW50IHRoZSB0YWIgYWN0aW9uIHRvIGtlZXAgaXQgaW4gdGhlIGxhc3QgZm9jdXNhYmxlIGVsZW1lbnRcblxuXG4gICAgICB2YXIgaXNGaXJzdEZvY3VzYWJsZUluU2VjdGlvbiA9IGFjdGl2ZUVsZW1lbnQgPT0gZm9jdXNhYmxlRWxlbWVudHNbMF07XG4gICAgICB2YXIgaXNMYXN0Rm9jdXNhYmxlSW5TZWN0aW9uID0gYWN0aXZlRWxlbWVudCA9PSBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBpc05leHRJdGVtID0gIWlzU2hpZnRQcmVzc2VkICYmIGlzTGFzdEZvY3VzYWJsZUluU2VjdGlvbjtcbiAgICAgIHZhciBpc1ByZXZJdGVtID0gaXNTaGlmdFByZXNzZWQgJiYgaXNGaXJzdEZvY3VzYWJsZUluU2VjdGlvbjtcblxuICAgICAgaWYgKGlzUHJldkl0ZW0gfHwgaXNOZXh0SXRlbSkge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgdmFyIGZvY3VzSW5mbyA9IGdldFBhbmVsV2l0aEZvY3VzYWJsZShpc1ByZXZJdGVtKTtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uUGFuZWwgPSBmb2N1c0luZm8gPyBmb2N1c0luZm8ucGFuZWwgOiBudWxsO1xuXG4gICAgICAgIGlmIChkZXN0aW5hdGlvblBhbmVsKSB7XG4gICAgICAgICAgdmFyIGRlc3RpbmF0aW9uU2VjdGlvbiA9IGRlc3RpbmF0aW9uUGFuZWwuaXNTZWN0aW9uID8gZGVzdGluYXRpb25QYW5lbCA6IGRlc3RpbmF0aW9uUGFuZWwucGFyZW50O1xuICAgICAgICAgIEV2ZW50RW1pdHRlci5lbWl0KGV2ZW50cy5vblNjcm9sbFBhZ2VBbmRTbGlkZSwge1xuICAgICAgICAgICAgc2VjdGlvbkFuY2hvcjogZGVzdGluYXRpb25TZWN0aW9uLmluZGV4KCkgKyAxLFxuICAgICAgICAgICAgc2xpZGVBbmNob3I6IGRlc3RpbmF0aW9uUGFuZWwuaXNTZWN0aW9uID8gMCA6IGRlc3RpbmF0aW9uUGFuZWwuaW5kZXgoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdfZWxUb0ZvY3VzID0gZm9jdXNJbmZvLml0ZW1Ub0ZvY3VzO1xuICAgICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25BZnRlclNsaWRlTG9hZHModikge1xuICAgICAgZm9jdXNJdGVtKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWZ0ZXJTZWN0aW9uTG9hZHModikge1xuICAgICAgaWYgKCFjbG9zZXN0KGdfZWxUb0ZvY3VzLCBTTElERV9TRUwpIHx8IGNsb3Nlc3QoZ19lbFRvRm9jdXMsIFNMSURFX0FDVElWRV9TRUwpKSB7XG4gICAgICAgIGZvY3VzSXRlbSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvY3VzSXRlbSgpIHtcbiAgICAgIGlmIChnX2VsVG9Gb2N1cykge1xuICAgICAgICBnX2VsVG9Gb2N1cy5mb2N1cygpO1xuICAgICAgICBnX2VsVG9Gb2N1cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCdzIHRoZSBwYW5lbCBjb250YWluaW5nIHRoZSBlbGVtZW50IHRvIGZvY3VzLlxuICAgICAqXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGdldFBhbmVsV2l0aEZvY3VzYWJsZShpc1ByZXZJdGVtKSB7XG4gICAgICB2YXIgYWN0aW9uID0gaXNQcmV2SXRlbSA/ICdwcmV2UGFuZWwnIDogJ25leHRQYW5lbCc7XG4gICAgICB2YXIgZm9jdXNhYmxlRWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBwYW5lbFdpdGhGb2N1c2FibGVzO1xuICAgICAgdmFyIGN1cnJlbnRQYW5lbCA9IGdldFNsaWRlT3JTZWN0aW9uUGFuZWwoZ2V0QWN0aXZlUGFuZWwoKVthY3Rpb25dKCkpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0Rm9jdXNhYmxlcyhjdXJyZW50UGFuZWwuaXRlbSk7XG5cbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHBhbmVsV2l0aEZvY3VzYWJsZXMgPSB7XG4gICAgICAgICAgICBwYW5lbDogY3VycmVudFBhbmVsLFxuICAgICAgICAgICAgaXRlbVRvRm9jdXM6IGZvY3VzYWJsZUVsZW1lbnRzW2lzUHJldkl0ZW0gPyBmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxIDogMF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFBhbmVsID0gZ2V0U2xpZGVPclNlY3Rpb25QYW5lbChjdXJyZW50UGFuZWxbYWN0aW9uXSgpKTtcbiAgICAgIH0gd2hpbGUgKGN1cnJlbnRQYW5lbCAmJiBmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggPT09IDApO1xuXG4gICAgICByZXR1cm4gcGFuZWxXaXRoRm9jdXNhYmxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBHZXRzIGFsbCB0aGUgZm9jdXNhYmxlIGVsZW1lbnRzIGluc2lkZSB0aGUgcGFzc2VkIGVsZW1lbnQuXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gZ2V0Rm9jdXNhYmxlcyhlbCkge1xuICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoJChmb2N1c2FibGVFbGVtZW50c1N0cmluZywgZWwpKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGdldEF0dHIoaXRlbSwgJ3RhYmluZGV4JykgIT09ICctMScgJiYgLy9hcmUgYWxzbyBub3QgaGlkZGVuIGVsZW1lbnRzIChvciB3aXRoIGhpZGRlbiBwYXJlbnRzKVxuICAgICAgICBpdGVtLm9mZnNldFBhcmVudCAhPT0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZm9jdXMgaXMgb3V0c2lkZSBmdWxscGFnZS5qcyBzZWN0aW9ucy9zbGlkZXMgb3Igbm90LlxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGlzRm9jdXNPdXRzaWRlKGUpIHtcbiAgICAgIHZhciBhbGxGb2N1c2FibGVzID0gZ2V0Rm9jdXNhYmxlcyhkb2MpO1xuICAgICAgdmFyIGN1cnJlbnRGb2N1c0luZGV4ID0gYWxsRm9jdXNhYmxlcy5pbmRleE9mKGRvYy5hY3RpdmVFbGVtZW50KTtcbiAgICAgIHZhciBmb2N1c0Rlc3RpbmF0aW9uSW5kZXggPSBlLnNoaWZ0S2V5ID8gY3VycmVudEZvY3VzSW5kZXggLSAxIDogY3VycmVudEZvY3VzSW5kZXggKyAxO1xuICAgICAgdmFyIGZvY3VzRGVzdGluYXRpb24gPSBhbGxGb2N1c2FibGVzW2ZvY3VzRGVzdGluYXRpb25JbmRleF07XG4gICAgICB2YXIgZGVzdGluYXRpb25JdGVtU2xpZGUgPSBjbG9zZXN0KGZvY3VzRGVzdGluYXRpb24sIFNMSURFX1NFTCk7XG4gICAgICB2YXIgZGVzdGluYXRpb25JdGVtU2VjdGlvbiA9IGNsb3Nlc3QoZm9jdXNEZXN0aW5hdGlvbiwgU0VDVElPTl9TRUwpO1xuICAgICAgcmV0dXJuICFkZXN0aW5hdGlvbkl0ZW1TbGlkZSAmJiAhZGVzdGluYXRpb25JdGVtU2VjdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRDYW5jZWxLZXlib2FyZE5hdmlnYXRpb24oZSkge1xuICAgICAgLy8gaHR0cHM6Ly9rZXljb2RlLmluZm8vZm9yLzM0XG4gICAgICAvLyA0MCA9IGFycm93IGRvd25cbiAgICAgIC8vIDM4ID0gYXJyb3cgdXBcbiAgICAgIC8vIDMyID0gc3BhY2ViYXJcbiAgICAgIC8vIDMzICA9IFBhZ2VVcFxuICAgICAgLy8gMzQgPSBQYWdlRG93blxuICAgICAgdmFyIGtleUNvbnRyb2xzID0gWzQwLCAzOCwgMzIsIDMzLCAzNF07XG4gICAgICByZXR1cm4ga2V5Q29udHJvbHMuaW5kZXhPZihlLmtleUNvZGUpID4gLTEgJiYgIXN0YXRlLmlzQmV5b25kRnVsbHBhZ2U7XG4gICAgfSAvL3ByZXZlbnRpbmcgdGhlIHNjcm9sbCB3aXRoIGFycm93IGtleXMgJiBzcGFjZWJhciAmIFBhZ2UgVXAgJiBEb3duIGtleXNcblxuXG4gICAgZnVuY3Rpb24gY2FuY2VsRGlyZWN0aW9uS2V5RXZlbnRzKGUpIHtcbiAgICAgIGlmIChzaG91bGRDYW5jZWxLZXlib2FyZE5hdmlnYXRpb24oZSkgJiYgIWNsb3Nlc3QoZS50YXJnZXQsIE9WRVJGTE9XX1NFTCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbnRyb2xQcmVzc2VkKCkge1xuICAgICAgcmV0dXJuIGdfY29udHJvbFByZXNzZWQ7XG4gICAgfVxuXG4gICAgdmFyIHByZXZUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIHNjcm9sbGluZ3MgPSBbXTtcbiAgICBGUC5zZXRNb3VzZVdoZWVsU2Nyb2xsaW5nID0gc2V0TW91c2VXaGVlbFNjcm9sbGluZztcbiAgICAvKipcbiAgICAqIEFkZHMgb3IgcmVtb3ZlIHRoZSBwb3NzaWJpbGl0eSBvZiBzY3JvbGxpbmcgdGhyb3VnaCBzZWN0aW9ucyBieSB1c2luZyB0aGUgbW91c2Ugd2hlZWwgb3IgdGhlIHRyYWNrcGFkLlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBzZXRNb3VzZVdoZWVsU2Nyb2xsaW5nKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgYWRkTW91c2VXaGVlbEhhbmRsZXIoKTtcbiAgICAgICAgYWRkTWlkZGxlV2hlZWxIYW5kbGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVNb3VzZVdoZWVsSGFuZGxlcigpO1xuICAgICAgICByZW1vdmVNaWRkbGVXaGVlbEhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBBZGRzIHRoZSBhdXRvIHNjcm9sbGluZyBhY3Rpb24gZm9yIHRoZSBtb3VzZSB3aGVlbCBhbmQgdHJhY2twYWQuXG4gICAgKiBBZnRlciB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIG1vdXNld2hlZWwgYW5kIHRyYWNrcGFkIG1vdmVtZW50cyB3aWxsIHNjcm9sbCB0aHJvdWdoIHNlY3Rpb25zXG4gICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWxcbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBhZGRNb3VzZVdoZWVsSGFuZGxlcigpIHtcbiAgICAgIHZhciBwcmVmaXggPSAnJztcblxuICAgICAgdmFyIF9hZGRFdmVudExpc3RlbmVyO1xuXG4gICAgICBpZiAod2luLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgX2FkZEV2ZW50TGlzdGVuZXIgPSBcImFkZEV2ZW50TGlzdGVuZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRFdmVudExpc3RlbmVyID0gXCJhdHRhY2hFdmVudFwiO1xuICAgICAgICBwcmVmaXggPSAnb24nO1xuICAgICAgfSAvLyBkZXRlY3QgYXZhaWxhYmxlIHdoZWVsIGV2ZW50XG5cblxuICAgICAgdmFyIHN1cHBvcnQgPSAnb253aGVlbCcgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpID8gJ3doZWVsJyA6IC8vIE1vZGVybiBicm93c2VycyBzdXBwb3J0IFwid2hlZWxcIlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZG9jLm9ubW91c2V3aGVlbCAhPT0gdW5kZWZpbmVkID8gJ21vdXNld2hlZWwnIDogLy8gV2Via2l0IGFuZCBJRSBzdXBwb3J0IGF0IGxlYXN0IFwibW91c2V3aGVlbFwiXG4gICAgICAnRE9NTW91c2VTY3JvbGwnOyAvLyBsZXQncyBhc3N1bWUgdGhhdCByZW1haW5pbmcgYnJvd3NlcnMgYXJlIG9sZGVyIEZpcmVmb3hcblxuICAgICAgdmFyIHBhc3NpdmVFdmVudCA9IGdldFBhc3NpdmVPcHRpb25zSWZQb3NzaWJsZSgpO1xuXG4gICAgICBpZiAoc3VwcG9ydCA9PSAnRE9NTW91c2VTY3JvbGwnKSB7XG4gICAgICAgIGRvY1tfYWRkRXZlbnRMaXN0ZW5lcl0ocHJlZml4ICsgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCBNb3VzZVdoZWVsSGFuZGxlciwgcGFzc2l2ZUV2ZW50KTtcbiAgICAgIH0gLy9oYW5kbGUgTW96TW91c2VQaXhlbFNjcm9sbCBpbiBvbGRlciBGaXJlZm94XG4gICAgICBlbHNlIHtcbiAgICAgICAgZG9jW19hZGRFdmVudExpc3RlbmVyXShwcmVmaXggKyBzdXBwb3J0LCBNb3VzZVdoZWVsSGFuZGxlciwgcGFzc2l2ZUV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBCaW5kaW5nIHRoZSBtb3VzZW1vdmUgd2hlbiB0aGUgbW91c2UncyBtaWRkbGUgYnV0dG9uIGlzIHByZXNzZWRcbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBhZGRNaWRkbGVXaGVlbEhhbmRsZXIoKSB7XG4gICAgICBnZXRDb250YWluZXIoKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZURvd25IYW5kbGVyKTtcbiAgICAgIGdldENvbnRhaW5lcigpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmVtb3ZlcyB0aGUgYXV0byBzY3JvbGxpbmcgYWN0aW9uIGZpcmVkIGJ5IHRoZSBtb3VzZSB3aGVlbCBhbmQgdHJhY2twYWQuXG4gICAgKiBBZnRlciB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIG1vdXNld2hlZWwgYW5kIHRyYWNrcGFkIG1vdmVtZW50cyB3b24ndCBzY3JvbGwgdGhyb3VnaCBzZWN0aW9ucy5cbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiByZW1vdmVNb3VzZVdoZWVsSGFuZGxlcigpIHtcbiAgICAgIGlmIChkb2MuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBkb2NSZW1vdmVFdmVudCgnbW91c2V3aGVlbCcsIE1vdXNlV2hlZWxIYW5kbGVyLCBmYWxzZSk7IC8vSUU5LCBDaHJvbWUsIFNhZmFyaSwgT3BlclxuXG4gICAgICAgIGRvY1JlbW92ZUV2ZW50KCd3aGVlbCcsIE1vdXNlV2hlZWxIYW5kbGVyLCBmYWxzZSk7IC8vRmlyZWZveFxuXG4gICAgICAgIGRvY1JlbW92ZUV2ZW50KCdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgTW91c2VXaGVlbEhhbmRsZXIsIGZhbHNlKTsgLy9vbGQgRmlyZWZveFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkb2MuZGV0YWNoRXZlbnQoJ29ubW91c2V3aGVlbCcsIE1vdXNlV2hlZWxIYW5kbGVyKTsgLy9JRSA2LzcvOFxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIFVuYmluZGluZyB0aGUgbW91c2Vtb3ZlIHdoZW4gdGhlIG1vdXNlJ3MgbWlkZGxlIGJ1dHRvbiBpcyByZWxlYXNlZFxuICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHJlbW92ZU1pZGRsZVdoZWVsSGFuZGxlcigpIHtcbiAgICAgIGdldENvbnRhaW5lcigpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkhhbmRsZXIpO1xuICAgICAgZ2V0Q29udGFpbmVyKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlVXBIYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZWN0aW5nIG1vdXNld2hlZWwgc2Nyb2xsaW5nXG4gICAgICpcbiAgICAgKiBodHRwOi8vYmxvZ3Muc2l0ZXBvaW50c3RhdGljLmNvbS9leGFtcGxlcy90ZWNoL21vdXNlLXdoZWVsL2luZGV4Lmh0bWxcbiAgICAgKiBodHRwOi8vd3d3LnNpdGVwb2ludC5jb20vaHRtbDUtamF2YXNjcmlwdC1tb3VzZS13aGVlbC9cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gTW91c2VXaGVlbEhhbmRsZXIoZSkge1xuICAgICAgdmFyIGN1clRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHZhciBpc05vcm1hbFNjcm9sbCA9IGhhc0NsYXNzKCQoQ09NUExFVEVMWV9TRUwpWzBdLCBOT1JNQUxfU0NST0xMKTtcbiAgICAgIHZhciBpc1Njcm9sbEFsbG93ZWRCZXlvbmRGdWxsUGFnZSA9IGJleW9uZEZ1bGxQYWdlSGFuZGxlcihnZXRDb250YWluZXIoKSwgZSk7XG5cbiAgICAgIGlmICghc3RhdGUuaXNVc2luZ1doZWVsKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0dyYWJiaW5nOiBmYWxzZSxcbiAgICAgICAgICBpc1VzaW5nV2hlZWw6IHRydWUsXG4gICAgICAgICAgdG91Y2hEaXJlY3Rpb246ICdub25lJ1xuICAgICAgICB9KTtcbiAgICAgIH0gLy9pcyBzY3JvbGwgYWxsb3dlZD9cblxuXG4gICAgICBpZiAoIWdldElzU2Nyb2xsQWxsb3dlZCgpLm0uZG93biAmJiAhZ2V0SXNTY3JvbGxBbGxvd2VkKCkubS51cCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1Njcm9sbEFsbG93ZWRCZXlvbmRGdWxsUGFnZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTY3JvbGxBbGxvd2VkQmV5b25kRnVsbFBhZ2UgPT09IGZhbHNlKSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vYXV0b3Njcm9sbGluZyBhbmQgbm90IHpvb21pbmc/XG5cblxuICAgICAgaWYgKGdldE9wdGlvbnMoKS5hdXRvU2Nyb2xsaW5nICYmICFnZXRDb250cm9sUHJlc3NlZCgpICYmICFpc05vcm1hbFNjcm9sbCkge1xuICAgICAgICAvLyBjcm9zcy1icm93c2VyIHdoZWVsIGRlbHRhXG4gICAgICAgIGUgPSBlIHx8IHdpbi5ldmVudDtcbiAgICAgICAgdmFyIHZhbHVlID0gZS53aGVlbERlbHRhIHx8IC1lLmRlbHRhWSB8fCAtZS5kZXRhaWw7XG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCB2YWx1ZSkpO1xuICAgICAgICB2YXIgaG9yaXpvbnRhbERldGVjdGlvbiA9IHR5cGVvZiBlLndoZWVsRGVsdGFYICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZS5kZWx0YVggIT09ICd1bmRlZmluZWQnO1xuICAgICAgICB2YXIgaXNTY3JvbGxpbmdWZXJ0aWNhbGx5ID0gTWF0aC5hYnMoZS53aGVlbERlbHRhWCkgPCBNYXRoLmFicyhlLndoZWVsRGVsdGEpIHx8IE1hdGguYWJzKGUuZGVsdGFYKSA8IE1hdGguYWJzKGUuZGVsdGFZKSB8fCAhaG9yaXpvbnRhbERldGVjdGlvbjtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRlbHRhIDwgMCA/ICdkb3duJyA6IGRlbHRhID4gMCA/ICd1cCcgOiAnbm9uZSc7IC8vTGltaXRpbmcgdGhlIGFycmF5IHRvIDE1MCAobGV0cyBub3Qgd2FzdGUgbWVtb3J5ISlcblxuICAgICAgICBpZiAoc2Nyb2xsaW5ncy5sZW5ndGggPiAxNDkpIHtcbiAgICAgICAgICBzY3JvbGxpbmdzLnNoaWZ0KCk7XG4gICAgICAgIH0gLy9rZWVwaW5nIHJlY29yZCBvZiB0aGUgcHJldmlvdXMgc2Nyb2xsaW5nc1xuXG5cbiAgICAgICAgc2Nyb2xsaW5ncy5wdXNoKE1hdGguYWJzKHZhbHVlKSk7IC8vcHJldmVudGluZyB0byBzY3JvbGwgdGhlIHNpdGUgb24gbW91c2Ugd2hlZWwgd2hlbiBzY3JvbGxiYXIgaXMgcHJlc2VudFxuXG4gICAgICAgIGlmIChnZXRPcHRpb25zKCkuc2Nyb2xsQmFyIHx8ICFnZXRPcHRpb25zKCkuc2Nyb2xsT3ZlcmZsb3cpIHtcbiAgICAgICAgICBwcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfSAvL3RpbWUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsYXN0IHNjcm9sbCBhbmQgdGhlIGN1cnJlbnQgb25lXG5cblxuICAgICAgICB2YXIgdGltZURpZmYgPSBjdXJUaW1lIC0gcHJldlRpbWU7XG4gICAgICAgIHByZXZUaW1lID0gY3VyVGltZTsgLy9oYXZlbid0IHRoZXkgc2Nyb2xsZWQgaW4gYSB3aGlsZT9cbiAgICAgICAgLy8oZW5vdWdoIHRvIGJlIGNvbnNpZGVyIGEgZGlmZmVyZW50IHNjcm9sbGluZyBhY3Rpb24gdG8gc2Nyb2xsIGFub3RoZXIgc2VjdGlvbilcblxuICAgICAgICBpZiAodGltZURpZmYgPiAyMDApIHtcbiAgICAgICAgICAvL2VtcHR5aW5nIHRoZSBhcnJheSwgd2UgZG9udCBjYXJlIGFib3V0IG9sZCBzY3JvbGxpbmdzIGZvciBvdXIgYXZlcmFnZXNcbiAgICAgICAgICBzY3JvbGxpbmdzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgd2hlZWxEaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RhdGUuY2FuU2Nyb2xsKSB7XG4gICAgICAgICAgdmFyIGF2ZXJhZ2VFbmQgPSBnZXRBdmVyYWdlKHNjcm9sbGluZ3MsIDEwKTtcbiAgICAgICAgICB2YXIgYXZlcmFnZU1pZGRsZSA9IGdldEF2ZXJhZ2Uoc2Nyb2xsaW5ncywgNzApO1xuICAgICAgICAgIHZhciBpc0FjY2VsZXJhdGluZyA9IGF2ZXJhZ2VFbmQgPj0gYXZlcmFnZU1pZGRsZTsgLy90byBhdm9pZCBkb3VibGUgc3dpcGVzLi4uXG5cbiAgICAgICAgICBpZiAoaXNBY2NlbGVyYXRpbmcgJiYgaXNTY3JvbGxpbmdWZXJ0aWNhbGx5KSB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIHNjcm9sbFRyaWdnZXI6ICd3aGVlbCdcbiAgICAgICAgICAgIH0pOyAvL3Njcm9sbGluZyBkb3duP1xuXG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgIHNjcm9sbGluZygnZG93bicpO1xuICAgICAgICAgICAgfSAvL3Njcm9sbGluZyB1cD9cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBzY3JvbGxpbmcoJ3VwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLmZpdFRvU2VjdGlvbikge1xuICAgICAgICAvL3N0b3BwaW5nIHRoZSBhdXRvIHNjcm9sbCB0byBhZGp1c3QgdG8gYSBzZWN0aW9uXG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3RpdmVBbmltYXRpb246IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy9iaW5kaW5nIHRoZSBtb3VzZW1vdmUgd2hlbiB0aGUgbW91c2UncyBtaWRkbGUgYnV0dG9uIGlzIHJlbGVhc2VkXG5cblxuICAgIGZ1bmN0aW9uIG1vdXNlRG93bkhhbmRsZXIoZSkge1xuICAgICAgLy9taWRkbGUgYnV0dG9uXG4gICAgICBpZiAoZS53aGljaCA9PSAyKSB7XG4gICAgICAgIHNldE9sZFBhZ2VZKGUucGFnZVkpO1xuICAgICAgICBnZXRDb250YWluZXIoKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9IC8vdW5iaW5kaW5nIHRoZSBtb3VzZW1vdmUgd2hlbiB0aGUgbW91c2UncyBtaWRkbGUgYnV0dG9uIGlzIHJlbGVhc2VkXG5cblxuICAgIGZ1bmN0aW9uIG1vdXNlVXBIYW5kbGVyKGUpIHtcbiAgICAgIC8vbWlkZGxlIGJ1dHRvblxuICAgICAgaWYgKGUud2hpY2ggPT0gMikge1xuICAgICAgICBnZXRDb250YWluZXIoKS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBBZGRzIG9yIHJlbW92ZSB0aGUgbW91c2Ugd2hlZWwgaGlqYWNraW5nXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gc2V0TW91c2VIaWphY2sodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBzZXRNb3VzZVdoZWVsU2Nyb2xsaW5nKHRydWUpO1xuICAgICAgICBhZGRUb3VjaEhhbmRsZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1vdXNlV2hlZWxTY3JvbGxpbmcoZmFsc2UpO1xuICAgICAgICByZW1vdmVUb3VjaEhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ19jYW5GaXJlTW91c2VFbnRlck5vcm1hbFNjcm9sbCA9IHRydWU7XG4gICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5iaW5kRXZlbnRzLCBiaW5kRXZlbnRzJDcpO1xuXG4gICAgZnVuY3Rpb24gYmluZEV2ZW50cyQ3KCkge1xuICAgICAgLyoqXG4gICAgICAqIEFwcGx5aW5nIG5vcm1hbFNjcm9sbCBlbGVtZW50cy5cbiAgICAgICogSWdub3JpbmcgdGhlIHNjcm9sbHMgb3ZlciB0aGUgc3BlY2lmaWVkIHNlbGVjdG9ycy5cbiAgICAgICovXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLm5vcm1hbFNjcm9sbEVsZW1lbnRzKSB7XG4gICAgICAgIFsnbW91c2VlbnRlcicsICd0b3VjaHN0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgZm9yTW91c2VMZWF2ZU9yVG91Y2goZXZlbnROYW1lLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBbJ21vdXNlbGVhdmUnLCAndG91Y2hlbmQnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICBmb3JNb3VzZUxlYXZlT3JUb3VjaChldmVudE5hbWUsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5vbkRlc3Ryb3ksIG9uRGVzdHJveSQ0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRlc3Ryb3kkNCgpIHtcbiAgICAgIFsnbW91c2VlbnRlcicsICd0b3VjaHN0YXJ0JywgJ21vdXNlbGVhdmUnLCAndG91Y2hlbmQnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgZG9jUmVtb3ZlRXZlbnQoZXZlbnROYW1lLCBvbk1vdXNlRW50ZXJPckxlYXZlLCB0cnVlKTsgLy90cnVlIGlzIHJlcXVpcmVkIVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9yTW91c2VMZWF2ZU9yVG91Y2goZXZlbnROYW1lLCBhbGxvd1Njcm9sbGluZykge1xuICAgICAgLy9hIHdheSB0byBwYXNzIGFyZ3VtZW50cyB0byB0aGUgb25Nb3VzZUVudGVyT3JMZWF2ZSBmdW5jdGlvblxuICAgICAgZG9jdW1lbnRbJ2ZwXycgKyBldmVudE5hbWVdID0gYWxsb3dTY3JvbGxpbmc7XG4gICAgICBkb2NBZGRFdmVudChldmVudE5hbWUsIG9uTW91c2VFbnRlck9yTGVhdmUsIHRydWUpOyAvL2NhcHR1cmluZyBwaGFzZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VFbnRlck9yTGVhdmUoZSkge1xuICAgICAgdmFyIHR5cGUgPSBlLnR5cGU7XG4gICAgICB2YXIgaXNJbnNpZGVPbmVOb3JtYWxTY3JvbGwgPSBmYWxzZTsgLy9vbk1vdXNlTGVhdmUgd2lsbCB1c2UgdGhlIGRlc3RpbmF0aW9uIHRhcmdldCwgbm90IHRoZSBvbmUgd2UgYXJlIG1vdmluZyBhd2F5IGZyb21cblxuICAgICAgdmFyIHRhcmdldCA9IHR5cGUgPT09ICdtb3VzZWxlYXZlJyA/IGUudG9FbGVtZW50IHx8IGUucmVsYXRlZFRhcmdldCA6IGUudGFyZ2V0OyAvL2NvbWluZyBmcm9tIGNsb3NpbmcgYSBub3JtYWxTY3JvbGxFbGVtZW50cyBtb2RhbCBvciBtb3Zpbmcgb3V0c2lkZSB2aWV3cG9ydD9cblxuICAgICAgaWYgKHRhcmdldCA9PSBkb2N1bWVudCB8fCAhdGFyZ2V0KSB7XG4gICAgICAgIHNldE1vdXNlSGlqYWNrKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgIGdfY2FuRmlyZU1vdXNlRW50ZXJOb3JtYWxTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZ19jYW5GaXJlTW91c2VFbnRlck5vcm1hbFNjcm9sbCA9IHRydWU7XG4gICAgICAgIH0sIDgwMCk7XG4gICAgICB9IC8vcHJldmVudGluZyBtb3VzZWVudGVyIGV2ZW50IHRvIGRvIGFueXRoaW5nIHdoZW4gY29taW5nIGZyb20gYSB0b3VjaEVuZCBldmVudFxuICAgICAgLy9maXhpbmcgaXNzdWUgIzM1NzZcblxuXG4gICAgICBpZiAodHlwZSA9PT0gJ21vdXNlZW50ZXInICYmICFnX2NhbkZpcmVNb3VzZUVudGVyTm9ybWFsU2Nyb2xsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbFNlbGVjdG9ycyA9IGdldE9wdGlvbnMoKS5ub3JtYWxTY3JvbGxFbGVtZW50cy5zcGxpdCgnLCcpO1xuICAgICAgbm9ybWFsU2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKG5vcm1hbFNlbGVjdG9yKSB7XG4gICAgICAgIGlmICghaXNJbnNpZGVPbmVOb3JtYWxTY3JvbGwpIHtcbiAgICAgICAgICB2YXIgaXNOb3JtYWxTY3JvbGxUYXJnZXQgPSBtYXRjaGVzKHRhcmdldCwgbm9ybWFsU2VsZWN0b3IpOyAvL2xlYXZpbmcgYSBjaGlsZCBpbnNpZGUgdGhlIG5vcm1hbFNjb2xsIGVsZW1lbnQgaXMgbm90IGxlYXZpbmcgdGhlIG5vcm1hbFNjcm9sbCAjMzY2MVxuXG4gICAgICAgICAgdmFyIGlzTm9ybWFsU2Nyb2xsQ2hpbGRGb2N1c2VkID0gY2xvc2VzdCh0YXJnZXQsIG5vcm1hbFNlbGVjdG9yKTtcblxuICAgICAgICAgIGlmIChpc05vcm1hbFNjcm9sbFRhcmdldCB8fCBpc05vcm1hbFNjcm9sbENoaWxkRm9jdXNlZCkge1xuICAgICAgICAgICAgaWYgKCFGUC5zaGFyZWQuaXNOb3JtYWxTY3JvbGxFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHNldE1vdXNlSGlqYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgRlAuc2hhcmVkLmlzTm9ybWFsU2Nyb2xsRWxlbWVudCA9IHRydWU7XG4gICAgICAgICAgICBpc0luc2lkZU9uZU5vcm1hbFNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTsgLy9ub3QgaW5zaWRlIGEgc2luZ2xlIG5vcm1hbCBzY3JvbGwgZWxlbWVudCBhbnltb3JlP1xuXG4gICAgICBpZiAoIWlzSW5zaWRlT25lTm9ybWFsU2Nyb2xsICYmIEZQLnNoYXJlZC5pc05vcm1hbFNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgc2V0TW91c2VIaWphY2sodHJ1ZSk7XG4gICAgICAgIEZQLnNoYXJlZC5pc05vcm1hbFNjcm9sbEVsZW1lbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBGUC5zaWxlbnRNb3ZlVG8gPSBzaWxlbnRNb3ZlVG87XG4gICAgLyoqXG4gICAgKiBNb3ZlcyB0aGUgcGFnZSB0byB0aGUgZ2l2ZW4gc2VjdGlvbiBhbmQgc2xpZGUgd2l0aCBubyBhbmltYXRpb24uXG4gICAgKiBBbmNob3JzIG9yIGluZGV4IHBvc2l0aW9ucyBjYW4gYmUgdXNlZCBhcyBwYXJhbXMuXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNpbGVudE1vdmVUbyhzZWN0aW9uQW5jaG9yLCBzbGlkZUFuY2hvcikge1xuICAgICAgc2V0U2Nyb2xsaW5nU3BlZWQoMCwgJ2ludGVybmFsJyk7XG4gICAgICBtb3ZlVG8kMShzZWN0aW9uQW5jaG9yLCBzbGlkZUFuY2hvcik7XG4gICAgICBzZXRTY3JvbGxpbmdTcGVlZChnZXRPcmlnaW5hbHMoKS5zY3JvbGxpbmdTcGVlZCwgJ2ludGVybmFsJyk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzSGVpZ2h0ID0gZ2V0V2luZG93SGVpZ2h0KCk7XG4gICAgdmFyIHdpbmRvd3NXaWR0aCA9IGdldFdpbmRvd1dpZHRoKCk7XG4gICAgdmFyIGdfcmVzaXplSWQ7XG4gICAgdmFyIGdfaXNDb25zZWN1dGl2ZVJlc2l6ZSA9IGZhbHNlO1xuICAgIHZhciBnX3Jlc2l6ZU1vYmlsZUhhbmRsZXJJZDtcbiAgICBGUC5yZUJ1aWxkID0gcmVCdWlsZDtcbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLmJpbmRFdmVudHMsIGJpbmRFdmVudHMkNik7XG5cbiAgICBmdW5jdGlvbiBiaW5kRXZlbnRzJDYoKSB7XG4gICAgICAvLyBTZXR0aW5nIFZIIGNvcnJlY3RseSBpbiBtb2JpbGUgZGV2aWNlc1xuICAgICAgcmVzaXplSGFuZGxlcigpOyAvL3doZW4gcmVzaXppbmcgdGhlIHNpdGUsIHdlIGFkanVzdCB0aGUgaGVpZ2h0cyBvZiB0aGUgc2VjdGlvbnMsIHNsaW1TY3JvbGwuLi5cblxuICAgICAgd2luZG93QWRkRXZlbnQoJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIpO1xuICAgICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5vbkRlc3Ryb3ksIG9uRGVzdHJveSQzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRlc3Ryb3kkMygpIHtcbiAgICAgIGNsZWFyVGltZW91dChnX3Jlc2l6ZUlkKTtcbiAgICAgIGNsZWFyVGltZW91dChnX3Jlc2l6ZU1vYmlsZUhhbmRsZXJJZCk7XG4gICAgICB3aW5kb3dSZW1vdmVFdmVudCgncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgfVxuICAgIC8qXG4gICAgKiBSZXNpemUgZXZlbnQgaGFuZGxlci5cbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiByZXNpemVIYW5kbGVyKCkge1xuICAgICAgaWYgKCFnX2lzQ29uc2VjdXRpdmVSZXNpemUpIHtcbiAgICAgICAgaWYgKGdldE9wdGlvbnMoKS5hdXRvU2Nyb2xsaW5nICYmICFnZXRPcHRpb25zKCkuc2Nyb2xsQmFyIHx8ICFnZXRPcHRpb25zKCkuZml0VG9TZWN0aW9uKSB7XG4gICAgICAgICAgc2V0U2VjdGlvbnNIZWlnaHQoZ2V0V2luZG93SGVpZ2h0KCkpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHdlIHdvbid0IHRyaWdnZXIgZml0IHRvIHNlY3Rpb24gb24gcGFnZSBsb2FkXG4gICAgICAvLyBvdGhlcndpc2UgaXQgd2lsbCBzY3JvbGwgdG8gdGhlIHdvcm5nIHNlY3Rpb24gaWYgdXNpbmcgYW5jaG9ycyAjNDYxM1xuXG5cbiAgICAgIGlmIChzdGF0ZS5pc0Z1bGxwYWdlSW5pdERvbmUpIHtcbiAgICAgICAgZml0VG9BY3RpdmVTZWN0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGdfaXNDb25zZWN1dGl2ZVJlc2l6ZSA9IHRydWU7IC8vaW4gb3JkZXIgdG8gY2FsbCB0aGUgZnVuY3Rpb25zIG9ubHkgd2hlbiB0aGUgcmVzaXplIGlzIGZpbmlzaGVkXG4gICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDI5ODYxMi9qcXVlcnktaG93LXRvLWNhbGwtcmVzaXplLWV2ZW50LW9ubHktb25jZS1pdHMtZmluaXNoZWQtcmVzaXppbmcgICAgXG5cbiAgICAgIGNsZWFyVGltZW91dChnX3Jlc2l6ZUlkKTtcbiAgICAgIGdfcmVzaXplSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9pc3N1ZSAjMzMzNiBcbiAgICAgICAgLy8oc29tZSBhcHBzIG9yIGJyb3dzZXJzLCBsaWtlIENocm9tZS9GaXJlZm94IGZvciBNb2JpbGUgdGFrZSB0aW1lIHRvIHJlcG9ydCB0aGUgcmVhbCBoZWlnaHQpXG4gICAgICAgIC8vc28gd2UgY2hlY2sgaXQgMyB0aW1lcyB3aXRoIGludGVydmFscyBpbiB0aGF0IGNhc2VcbiAgICAgICAgLy8gZm9yKHZhciBpID0gMDsgaTwgNDsgaSsrKXtcbiAgICAgICAgcmVzaXplQWN0aW9ucygpO1xuICAgICAgICBnX2lzQ29uc2VjdXRpdmVSZXNpemUgPSBmYWxzZTsgLy8gfVxuICAgICAgfSwgNDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXRUb0FjdGl2ZVNlY3Rpb24oKSB7XG4gICAgICBpZiAoaXNUb3VjaERldmljZSkge1xuICAgICAgICAvLyBJc3N1ZSAjNDM5MyBhbmQgcHJldmlvdXNseSBpbiB2MywgIzMzMzZcbiAgICAgICAgLy8gKHNvbWUgYXBwcyBvciBicm93c2VycywgbGlrZSBDaHJvbWUvRmlyZWZveCB3aWxsIGRlbGF5IGEgYml0IHRvIHNjcm9sbCBcbiAgICAgICAgLy8gdG8gdGhlIGZvY3VzZWQgaW5wdXRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICBnX3Jlc2l6ZU1vYmlsZUhhbmRsZXJJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIG9uIEFuZHJvaWQgZGV2aWNlcyB0aGUgYnJvd3NlciBzY3JvbGxzIHRvIHRoZSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgICAgICAgLy8gbWVzc2luZyB1cCB0aGUgd2hvbGUgcGFnZSBzdHJ1Y3R1cmUuIFNvIHdlIG5lZWQgdG8gdXBkYXRlIHRoZVxuICAgICAgICAgICAgICAvLyB0cmFuc2xhdGUzZCB2YWx1ZSB3aGVuIHRoZSBrZXlib2FyZCBzaG93cy9oaWRlc1xuICAgICAgICAgICAgICBpZiAoZ2V0T3B0aW9ucygpLmF1dG9TY3JvbGxpbmcgJiYgIWdldE9wdGlvbnMoKS5zY3JvbGxCYXIpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICBpc1Jlc2l6aW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2lsZW50TW92ZVRvKHN0YXRlLmFjdGl2ZVNlY3Rpb24uaW5kZXgoKSArIDEpO1xuICAgICAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgIGlzUmVzaXppbmc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDIwMCAqIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBWSCB1bml0cyBuZWVkIHRvIGJlIHNldCBiYXNlZCBvbiBzY3JvbGxpbmcgY29uZmlndXJhdGlvblxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBzaG91bGRTZXRWaFVuaXRzKCkge1xuICAgICAgcmV0dXJuICFzdGF0ZS5pc0JleW9uZEZ1bGxwYWdlICYmICFnZXRPcHRpb25zKCkuYXV0b1Njcm9sbGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBXaGVuIHJlc2l6aW5nIHRoZSBzaXRlLCB3ZSBhZGp1c3QgdGhlIGhlaWdodHMgb2YgdGhlIHNlY3Rpb25zLCBzbGltU2Nyb2xsLi4uXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gcmVzaXplQWN0aW9ucygpIHtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgaXNSZXNpemluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghaXNUb3VjaERldmljZSB8fCBnZXRPcHRpb25zKCkuYWRqdXN0T25OYXZDaGFuZ2UpIHtcbiAgICAgICAgc2V0U2VjdGlvbnNIZWlnaHQoJycpO1xuXG4gICAgICAgIGlmIChzaG91bGRTZXRWaFVuaXRzKCkpIHtcbiAgICAgICAgICBzZXRWaFVuaXRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRzLmNvbnRlbnRDaGFuZ2VkKTtcbiAgICAgIHVwZGF0ZVN0YXRlKCk7IC8vY2hlY2tpbmcgaWYgaXQgbmVlZHMgdG8gZ2V0IHJlc3BvbnNpdmVcblxuICAgICAgcmVzcG9uc2l2ZSgpOyAvLyByZWJ1aWxkIGltbWVkaWF0ZWx5IG9uIHRvdWNoIGRldmljZXNcblxuICAgICAgaWYgKGlzVG91Y2hEZXZpY2UpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2MuYWN0aXZlRWxlbWVudDsgLy9pZiB0aGUga2V5Ym9hcmQgaXMgTk9UIHZpc2libGVcblxuICAgICAgICBpZiAoIW1hdGNoZXMoYWN0aXZlRWxlbWVudCwgJ3RleHRhcmVhJykgJiYgIW1hdGNoZXMoYWN0aXZlRWxlbWVudCwgJ2lucHV0JykgJiYgIW1hdGNoZXMoYWN0aXZlRWxlbWVudCwgJ3NlbGVjdCcpKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIZWlnaHQgPSBnZXRXaW5kb3dIZWlnaHQoKTsgLy9tYWtpbmcgc3VyZSB0aGUgY2hhbmdlIGluIHRoZSB2aWV3cG9ydCBzaXplIGlzIGVub3VnaCB0byBmb3JjZSBhIHJlYnVpbGQuICgyMCAlIG9mIHRoZSB3aW5kb3cgdG8gYXZvaWQgcHJvYmxlbXMgd2hlbiBoaWRkaW5nIHNjcm9sbCBiYXJzKVxuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGN1cnJlbnRIZWlnaHQgLSBwcmV2aW91c0hlaWdodCkgPiAyMCAqIE1hdGgubWF4KHByZXZpb3VzSGVpZ2h0LCBjdXJyZW50SGVpZ2h0KSAvIDEwMCkge1xuICAgICAgICAgICAgcmVCdWlsZCh0cnVlKTtcbiAgICAgICAgICAgIHByZXZpb3VzSGVpZ2h0ID0gY3VycmVudEhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkanVzdFRvTmV3Vmlld3BvcnQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpc1Jlc2l6aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gcmVzaXppbmcgaXMgZmluaXNoZWQsIHdlIGFkanVzdCB0aGUgc2xpZGVzIHNpemVzIGFuZCBwb3NpdGlvbnNcbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gcmVCdWlsZChyZXNpemluZykge1xuICAgICAgaWYgKGhhc0NsYXNzKGdldENvbnRhaW5lcigpLCBERVNUUk9ZRUQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy9ub3RoaW5nIHRvIGRvIGlmIHRoZSBwbHVnaW4gd2FzIGRlc3Ryb3llZFxuICAgICAgLy91cGRhdGluZyBnbG9iYWwgdmFyc1xuXG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgaXNSZXNpemluZzogdHJ1ZSxcbiAgICAgICAgd2luZG93c0hlaWdodDogZ2V0V2luZG93SGVpZ2h0KCksXG4gICAgICAgIHdpbmRvd3NXaWR0aDogZ2V0V2luZG93V2lkdGgoKVxuICAgICAgfSk7XG4gICAgICB2YXIgc2VjdGlvbnMgPSBnZXRTdGF0ZSgpLnNlY3Rpb25zO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gc2VjdGlvbnNbaV07XG4gICAgICAgIHZhciBzbGlkZXNXcmFwID0gJChTTElERVNfV1JBUFBFUl9TRUwsIHNlY3Rpb24uaXRlbSlbMF07XG4gICAgICAgIHZhciBzbGlkZXMgPSBzZWN0aW9uLnNsaWRlczsgLy9hZGp1c3RpbmcgdGhlIHBvc2l0aW9uIGZvIHRoZSBGVUxMIFdJRFRIIHNsaWRlcy4uLlxuXG4gICAgICAgIGlmIChzbGlkZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGxhbmRzY2FwZVNjcm9sbChzbGlkZXNXcmFwLCBzZWN0aW9uLmFjdGl2ZVNsaWRlLml0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRPcHRpb25zKCkuc2Nyb2xsT3ZlcmZsb3cpIHtcbiAgICAgICAgc2Nyb2xsT3ZlcmZsb3dIYW5kbGVyLm1ha2VTY3JvbGxhYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWN0aW9uSW5kZXggPSBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uaW5kZXgoKTtcblxuICAgICAgaWYgKCFzdGF0ZS5pc0JleW9uZEZ1bGxwYWdlKSB7XG4gICAgICAgIC8vaXNuJ3QgaXQgdGhlIGZpcnN0IHNlY3Rpb24/XG4gICAgICAgIGlmIChzZWN0aW9uSW5kZXgpIHtcbiAgICAgICAgICAvL2FkanVzdGluZyB0aGUgcG9zaXRpb24gZm9yIHRoZSBjdXJyZW50IHNlY3Rpb25cbiAgICAgICAgICBzaWxlbnRNb3ZlVG8oc2VjdGlvbkluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpc1Jlc2l6aW5nOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGdldE9wdGlvbnMoKS5hZnRlclJlc2l6ZSkgJiYgcmVzaXppbmcpIHtcbiAgICAgICAgZ2V0T3B0aW9ucygpLmFmdGVyUmVzaXplLmNhbGwoZ2V0Q29udGFpbmVyKCksIHdpbi5pbm5lcldpZHRoLCB3aW4uaW5uZXJIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihnZXRPcHRpb25zKCkuYWZ0ZXJSZUJ1aWxkKSAmJiAhcmVzaXppbmcpIHtcbiAgICAgICAgZ2V0T3B0aW9ucygpLmFmdGVyUmVCdWlsZC5jYWxsKGdldENvbnRhaW5lcigpKTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlcihnZXRDb250YWluZXIoKSwgJ2FmdGVyUmVidWlsZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFkanVzdHMgYSBzZWN0aW9uIHRvIHRoZSB2aWV3cG9ydCBpZiBpdCBoYXMgY2hhbmdlZC5cbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBhZGp1c3RUb05ld1ZpZXdwb3J0KCkge1xuICAgICAgdmFyIG5ld1dpbmRvd0hlaWdodCA9IGdldFdpbmRvd0hlaWdodCgpO1xuICAgICAgdmFyIG5ld1dpbmRvd1dpZHRoID0gZ2V0V2luZG93V2lkdGgoKTtcblxuICAgICAgaWYgKHN0YXRlLndpbmRvd3NIZWlnaHQgIT09IG5ld1dpbmRvd0hlaWdodCB8fCB3aW5kb3dzV2lkdGggIT09IG5ld1dpbmRvd1dpZHRoKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICB3aW5kb3dzSGVpZ2h0OiBuZXdXaW5kb3dIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvd3NXaWR0aCA9IG5ld1dpbmRvd1dpZHRoO1xuICAgICAgICByZUJ1aWxkKHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFNlY3Rpb25zSGVpZ2h0KHZhbHVlKSB7XG4gICAgICB2YXIgcHJvcGVydHlWYWx1ZSA9IHZhbHVlID09PSAnJyA/ICcnIDogdmFsdWUgKyAncHgnO1xuICAgICAgZ2V0U3RhdGUoKS5zZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgIGNzcyhzZWN0aW9uLml0ZW0sIHtcbiAgICAgICAgICAnaGVpZ2h0JzogcHJvcGVydHlWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZpbmluZyB0aGUgdmFsdWUgaW4gcHggb2YgYSBWSCB1bml0LiAoVXNlZCBmb3IgYXV0b1Njcm9sbGluZzogZmFsc2UpXG4gICAgICogVG8gZml4IHRoZSBoZWlnaHQgaXNzdWUgb24gbW9iaWxlIGRldmljZXMgd2hlbiB1c2luZyBWSCB1bml0cy5cbiAgICAgKiBodHRwczovL2Nzcy10cmlja3MuY29tL3RoZS10cmljay10by12aWV3cG9ydC11bml0cy1vbi1tb2JpbGUvXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHNldFZoVW5pdHMoKSB7XG4gICAgICAvLyBGaXJzdCB3ZSBnZXQgdGhlIHZpZXdwb3J0IGhlaWdodCBhbmQgd2UgbXVsdGlwbGUgaXQgYnkgMSUgdG8gZ2V0IGEgdmFsdWUgZm9yIGEgdmggdW5pdFxuICAgICAgdmFyIHZoID0gd2luLmlubmVySGVpZ2h0ICogMC4wMTsgLy8gVGhlbiB3ZSBzZXQgdGhlIHZhbHVlIGluIHRoZSAtLXZoIGN1c3RvbSBwcm9wZXJ0eSB0byB0aGUgcm9vdCBvZiB0aGUgZG9jdW1lbnRcblxuICAgICAgZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12aCcsIFwiXCIuY29uY2F0KHZoLCBcInB4XCIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBbmNob3JzVVJMKCkge1xuICAgICAgdmFyIHNlY3Rpb247XG4gICAgICB2YXIgc2xpZGU7XG4gICAgICB2YXIgaGFzaCA9IHdpbi5sb2NhdGlvbi5oYXNoO1xuXG4gICAgICBpZiAoaGFzaC5sZW5ndGgpIHtcbiAgICAgICAgLy9nZXR0aW5nIHRoZSBhbmNob3IgbGluayBpbiB0aGUgVVJMIGFuZCBkZWxldGluZyB0aGUgYCNgXG4gICAgICAgIHZhciBhbmNob3JzUGFydHMgPSBoYXNoLnJlcGxhY2UoJyMnLCAnJykuc3BsaXQoJy8nKTsgLy91c2luZyAvIGZvciB2aXN1YWwgcmVhc29ucyBhbmQgbm90IGFzIGEgc2VjdGlvbi9zbGlkZSBzZXBhcmF0b3IgIzI4MDNcblxuICAgICAgICB2YXIgaXNGdW5reUFuY2hvciA9IGhhc2guaW5kZXhPZignIy8nKSA+IC0xO1xuICAgICAgICBzZWN0aW9uID0gaXNGdW5reUFuY2hvciA/ICcvJyArIGFuY2hvcnNQYXJ0c1sxXSA6IGRlY29kZVVSSUNvbXBvbmVudChhbmNob3JzUGFydHNbMF0pO1xuICAgICAgICB2YXIgc2xpZGVBbmNob3IgPSBpc0Z1bmt5QW5jaG9yID8gYW5jaG9yc1BhcnRzWzJdIDogYW5jaG9yc1BhcnRzWzFdO1xuXG4gICAgICAgIGlmIChzbGlkZUFuY2hvciAmJiBzbGlkZUFuY2hvci5sZW5ndGgpIHtcbiAgICAgICAgICBzbGlkZSA9IGRlY29kZVVSSUNvbXBvbmVudChzbGlkZUFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VjdGlvbjogc2VjdGlvbixcbiAgICAgICAgc2xpZGU6IHNsaWRlXG4gICAgICB9O1xuICAgIH1cblxuICAgIEZQLnNldExvY2tBbmNob3JzID0gc2V0TG9ja0FuY2hvcnM7XG4gICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5iaW5kRXZlbnRzLCBiaW5kRXZlbnRzJDUpO1xuXG4gICAgZnVuY3Rpb24gYmluZEV2ZW50cyQ1KCkge1xuICAgICAgLy9kZXRlY3RpbmcgYW55IGNoYW5nZSBvbiB0aGUgVVJMIHRvIHNjcm9sbCB0byB0aGUgZ2l2ZW4gYW5jaG9yIGxpbmtcbiAgICAgIC8vKGEgd2F5IHRvIGRldGVjdCBiYWNrIGhpc3RvcnkgYnV0dG9uIGFzIHdlIHBsYXkgd2l0aCB0aGUgaGFzaGVzIG9uIHRoZSBVUkwpXG4gICAgICB3aW5kb3dBZGRFdmVudCgnaGFzaGNoYW5nZScsIGhhc2hDaGFuZ2VIYW5kbGVyKTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMub25EZXN0cm95LCBvbkRlc3Ryb3kkMik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EZXN0cm95JDIoKSB7XG4gICAgICB3aW5kb3dSZW1vdmVFdmVudCgnaGFzaGNoYW5nZScsIGhhc2hDaGFuZ2VIYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXRzIGxvY2tBbmNob3JzXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gc2V0TG9ja0FuY2hvcnModmFsdWUpIHtcbiAgICAgIGdldE9wdGlvbnMoKS5sb2NrQW5jaG9ycyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAqIERldGVjdGluZyBhbnkgY2hhbmdlIG9uIHRoZSBVUkwgdG8gc2Nyb2xsIHRvIHRoZSBnaXZlbiBhbmNob3IgbGlua1xuICAgICogKGEgd2F5IHRvIGRldGVjdCBiYWNrIGhpc3RvcnkgYnV0dG9uIGFzIHdlIHBsYXkgd2l0aCB0aGUgaGFzaGVzIG9uIHRoZSBVUkwpXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gaGFzaENoYW5nZUhhbmRsZXIoKSB7XG4gICAgICBpZiAoIXN0YXRlLmlzU2Nyb2xsaW5nICYmICFnZXRPcHRpb25zKCkubG9ja0FuY2hvcnMpIHtcbiAgICAgICAgdmFyIGFuY2hvcnMgPSBnZXRBbmNob3JzVVJMKCk7XG4gICAgICAgIHZhciBzZWN0aW9uQW5jaG9yID0gYW5jaG9ycy5zZWN0aW9uO1xuICAgICAgICB2YXIgc2xpZGVBbmNob3IgPSBhbmNob3JzLnNsaWRlOyAvL3doZW4gbW92aW5nIHRvIGEgc2xpZGUgaW4gdGhlIGZpcnN0IHNlY3Rpb24gZm9yIHRoZSBmaXJzdCB0aW1lIChmaXJzdCB0aW1lIHRvIGFkZCBhbiBhbmNob3IgdG8gdGhlIFVSTClcblxuICAgICAgICB2YXIgaXNGaXJzdFNsaWRlTW92ZSA9IHR5cGVvZiBzdGF0ZS5sYXN0U2Nyb2xsZWREZXN0aW55ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgdmFyIGlzRmlyc3RTY3JvbGxNb3ZlID0gdHlwZW9mIHN0YXRlLmxhc3RTY3JvbGxlZERlc3RpbnkgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBzbGlkZUFuY2hvciA9PT0gJ3VuZGVmaW5lZCcgJiYgIXN0YXRlLnNsaWRlTW92aW5nO1xuXG4gICAgICAgIGlmIChzZWN0aW9uQW5jaG9yICYmIHNlY3Rpb25BbmNob3IubGVuZ3RoKSB7XG4gICAgICAgICAgLyppbiBvcmRlciB0byBjYWxsIHNjcm9sbHBhZ2UoKSBvbmx5IG9uY2UgZm9yIGVhY2ggZGVzdGluYXRpb24gYXQgYSB0aW1lXG4gICAgICAgICAgSXQgaXMgY2FsbGVkIHR3aWNlIGZvciBlYWNoIHNjcm9sbCBvdGhlcndpc2UsIGFzIGluIGNhc2Ugb2YgdXNpbmcgYW5jaG9ybGlua3MgYGhhc2hDaGFuZ2VgXG4gICAgICAgICAgZXZlbnQgaXMgZmlyZWQgb24gZXZlcnkgc2Nyb2xsIHRvby4qL1xuICAgICAgICAgIGlmIChzZWN0aW9uQW5jaG9yICYmIHNlY3Rpb25BbmNob3IgIT09IHN0YXRlLmxhc3RTY3JvbGxlZERlc3RpbnkgJiYgIWlzRmlyc3RTbGlkZU1vdmUgfHwgaXNGaXJzdFNjcm9sbE1vdmUgfHwgIXN0YXRlLnNsaWRlTW92aW5nICYmIHN0YXRlLmxhc3RTY3JvbGxlZFNsaWRlICE9IHNsaWRlQW5jaG9yKSB7XG4gICAgICAgICAgICBFdmVudEVtaXR0ZXIuZW1pdChldmVudHMub25TY3JvbGxQYWdlQW5kU2xpZGUsIHtcbiAgICAgICAgICAgICAgc2VjdGlvbkFuY2hvcjogc2VjdGlvbkFuY2hvcixcbiAgICAgICAgICAgICAgc2xpZGVBbmNob3I6IHNsaWRlQW5jaG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLmJpbmRFdmVudHMsIGJpbmRFdmVudHMkNCk7XG5cbiAgICBmdW5jdGlvbiBiaW5kRXZlbnRzJDQoKSB7XG4gICAgICBkb2NBZGRFdmVudCgnd2hlZWwnLCB3aGVlbERhdGFIYW5kbGVyLnJlZ2lzdGVyRXZlbnQsIGdldFBhc3NpdmVPcHRpb25zSWZQb3NzaWJsZSgpKTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuc2Nyb2xsQmV5b25kRnVsbHBhZ2UsIHNjcm9sbEJleW9uZEZ1bGxQYWdlKTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMub25LZXlEb3duLCBvbktleURvd24pO1xuICAgIH1cblxuICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYmluZEV2ZW50cywgYmluZEV2ZW50cyQzKTtcblxuICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMkMygpIHtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMub25DbGlja09yVG91Y2gsIG9uQ2xpY2tPclRvdWNoJDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2tPclRvdWNoJDEocGFyYW1zKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gcGFyYW1zLnRhcmdldDtcblxuICAgICAgaWYgKGNsb3Nlc3QodGFyZ2V0LCBnZXRPcHRpb25zKCkubWVudSArICcgW2RhdGEtbWVudWFuY2hvcl0nKSkge1xuICAgICAgICBtZW51SXRlbXNIYW5kbGVyLmNhbGwodGFyZ2V0LCBwYXJhbXMuZSk7XG4gICAgICB9XG4gICAgfSAvL01lbnUgaXRlbSBoYW5kbGVyIHdoZW4gbm90IHVzaW5nIGFuY2hvcnMgb3IgdXNpbmcgbG9ja0FuY2hvcnM6dHJ1ZVxuXG5cbiAgICBmdW5jdGlvbiBtZW51SXRlbXNIYW5kbGVyKGUpIHtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgc2Nyb2xsVHJpZ2dlcjogJ21lbnUnXG4gICAgICB9KTtcblxuICAgICAgaWYgKCQoZ2V0T3B0aW9ucygpLm1lbnUpWzBdICYmIChnZXRPcHRpb25zKCkubG9ja0FuY2hvcnMgfHwgIWdldE9wdGlvbnMoKS5hbmNob3JzLmxlbmd0aCkpIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIHZhciBtZW51QW5jaG9yRWwgPSBjbG9zZXN0KHRoaXMsICdbZGF0YS1tZW51YW5jaG9yXScpO1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuXG4gICAgICAgIEV2ZW50RW1pdHRlci5lbWl0KGV2ZW50cy5vbk1lbnVDbGljaywge1xuICAgICAgICAgIGFuY2hvcjogZ2V0QXR0cihtZW51QW5jaG9yRWwsICdkYXRhLW1lbnVhbmNob3InKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLmJpbmRFdmVudHMsIGJpbmRFdmVudHMkMik7XG5cbiAgICBmdW5jdGlvbiBiaW5kRXZlbnRzJDIoKSB7XG4gICAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uQ2xpY2tPclRvdWNoLCBvbkNsaWNrT3JUb3VjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbGlja09yVG91Y2gocGFyYW1zKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gcGFyYW1zLnRhcmdldDtcblxuICAgICAgaWYgKHRhcmdldCAmJiBjbG9zZXN0KHRhcmdldCwgU0VDVElPTl9OQVZfU0VMICsgJyBhJykpIHtcbiAgICAgICAgc2VjdGlvbkJ1bGxldEhhbmRsZXIuY2FsbCh0YXJnZXQsIHBhcmFtcy5lKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hlcyh0YXJnZXQsIFNFQ1RJT05fTkFWX1RPT0xUSVBfU0VMKSkge1xuICAgICAgICB0b29sdGlwVGV4dEhhbmRsZXIuY2FsbCh0YXJnZXQpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaGVzKHRhcmdldCwgU0xJREVTX05BVl9MSU5LX1NFTCkgfHwgY2xvc2VzdCh0YXJnZXQsIFNMSURFU19OQVZfTElOS19TRUwpICE9IG51bGwpIHtcbiAgICAgICAgc2xpZGVCdWxsZXRIYW5kbGVyLmNhbGwodGFyZ2V0LCBwYXJhbXMuZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhc3RTY3JvbGwgPSAwO1xuICAgIHZhciBnX3Njcm9sbElkO1xuICAgIHZhciBnX3Njcm9sbElkMjtcbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uRGVzdHJveSwgb25EZXN0cm95JDEpOyAvL3doZW4gc2Nyb2xsaW5nLi4uXG5cbiAgICBmdW5jdGlvbiBzY3JvbGxIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBjdXJyZW50U2VjdGlvbjtcbiAgICAgIHZhciBjdXJyZW50U2VjdGlvbkVsZW07XG5cbiAgICAgIGlmIChzdGF0ZS5pc1Jlc2l6aW5nIHx8ICFnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBnZXRMYXN0KGdldFN0YXRlKCkuc2VjdGlvbnMpO1xuXG4gICAgICBpZiAoZ2V0U3RhdGUoKS5pc0JleW9uZEZ1bGxwYWdlIHx8IGdldFN0YXRlKCkuaXNBYm91dFRvU2Nyb2xsVG9GdWxsUGFnZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2V0T3B0aW9ucygpLmF1dG9TY3JvbGxpbmcgfHwgZ2V0T3B0aW9ucygpLnNjcm9sbEJhcikge1xuICAgICAgICB2YXIgY3VycmVudFNjcm9sbCA9IGdldFNjcm9sbFRvcCgpO1xuICAgICAgICB2YXIgc2Nyb2xsRGlyZWN0aW9uID0gZ2V0U2Nyb2xsRGlyZWN0aW9uKGN1cnJlbnRTY3JvbGwpO1xuICAgICAgICB2YXIgdmlzaWJsZVNlY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIHZhciBzY3JlZW5fbWlkID0gY3VycmVudFNjcm9sbCArIGdldFdpbmRvd0hlaWdodCgpIC8gMi4wO1xuICAgICAgICB2YXIgaXNBdEJvdHRvbSA9ICRib2R5LnNjcm9sbEhlaWdodCAtIGdldFdpbmRvd0hlaWdodCgpID09PSBjdXJyZW50U2Nyb2xsO1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBnZXRTdGF0ZSgpLnNlY3Rpb25zO1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgc2Nyb2xsWTogY3VycmVudFNjcm9sbFxuICAgICAgICB9KTsgLy93aGVuIHVzaW5nIGBhdXRvLWhlaWdodGAgZm9yIGEgc21hbGwgbGFzdCBzZWN0aW9uIGl0IHdvbid0IGJlIGNlbnRlcmVkIGluIHRoZSB2aWV3cG9ydFxuXG4gICAgICAgIGlmIChpc0F0Qm90dG9tKSB7XG4gICAgICAgICAgdmlzaWJsZVNlY3Rpb25JbmRleCA9IHNlY3Rpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gLy9pcyBhdCB0b3A/IHdoZW4gdXNpbmcgYGF1dG8taGVpZ2h0YCBmb3IgYSBzbWFsbCBmaXJzdCBzZWN0aW9uIGl0IHdvbid0IGJlIGNlbnRlcmVkIGluIHRoZSB2aWV3cG9ydFxuICAgICAgICBlbHNlIGlmICghY3VycmVudFNjcm9sbCkge1xuICAgICAgICAgIHZpc2libGVTZWN0aW9uSW5kZXggPSAwO1xuICAgICAgICB9IC8vdGFraW5nIHRoZSBzZWN0aW9uIHdoaWNoIGlzIHNob3dpbmcgbW9yZSBjb250ZW50IGluIHRoZSB2aWV3cG9ydFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc2VjdGlvbiA9IHNlY3Rpb25zW2ldLml0ZW07IC8vIFBpY2sgdGhlIHRoZSBsYXN0IHNlY3Rpb24gd2hpY2ggcGFzc2VzIHRoZSBtaWRkbGUgbGluZSBvZiB0aGUgc2NyZWVuLlxuXG4gICAgICAgICAgICBpZiAoc2VjdGlvbi5vZmZzZXRUb3AgPD0gc2NyZWVuX21pZCkge1xuICAgICAgICAgICAgICB2aXNpYmxlU2VjdGlvbkluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDb21wbGV0ZWx5SW5WaWV3UG9ydChzY3JvbGxEaXJlY3Rpb24pKSB7XG4gICAgICAgICAgaWYgKCFoYXNDbGFzcyhnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uaXRlbSwgQ09NUExFVEVMWSkpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtLCBDT01QTEVURUxZKTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNpYmxpbmdzKGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtKSwgQ09NUExFVEVMWSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vZ2V0aW5nIHRoZSBsYXN0IG9uZSwgdGhlIGN1cnJlbnQgb25lIG9uIHRoZSBzY3JlZW5cblxuXG4gICAgICAgIGN1cnJlbnRTZWN0aW9uID0gc2VjdGlvbnNbdmlzaWJsZVNlY3Rpb25JbmRleF07XG4gICAgICAgIGN1cnJlbnRTZWN0aW9uRWxlbSA9IGN1cnJlbnRTZWN0aW9uLml0ZW07IC8vc2V0dGluZyB0aGUgdmlzaWJsZSBzZWN0aW9uIGFzIGFjdGl2ZSB3aGVuIG1hbnVhbGx5IHNjcm9sbGluZ1xuICAgICAgICAvL2V4ZWN1dGluZyBvbmx5IG9uY2UgdGhlIGZpcnN0IHRpbWUgd2UgcmVhY2ggdGhlIHNlY3Rpb25cblxuICAgICAgICBpZiAoIWN1cnJlbnRTZWN0aW9uLmlzQWN0aXZlKSB7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgbGVhdmluZ1NlY3Rpb24gPSBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uaXRlbTtcbiAgICAgICAgICB2YXIgbGVhdmluZ1NlY3Rpb25JbmRleCA9IGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pbmRleCgpICsgMTtcbiAgICAgICAgICB2YXIgeU1vdmVtZW50ID0gZ2V0WW1vdmVtZW50KGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbiwgY3VycmVudFNlY3Rpb25FbGVtKTtcbiAgICAgICAgICB2YXIgYW5jaG9yTGluayA9IGN1cnJlbnRTZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgICB2YXIgc2VjdGlvbkluZGV4ID0gY3VycmVudFNlY3Rpb24uaW5kZXgoKSArIDE7XG4gICAgICAgICAgdmFyIGFjdGl2ZVNsaWRlID0gY3VycmVudFNlY3Rpb24uYWN0aXZlU2xpZGU7XG4gICAgICAgICAgdmFyIHNsaWRlSW5kZXg7XG4gICAgICAgICAgdmFyIHNsaWRlQW5jaG9yTGluaztcbiAgICAgICAgICB2YXIgY2FsbGJhY2tzUGFyYW1zID0ge1xuICAgICAgICAgICAgYWN0aXZlU2VjdGlvbjogbGVhdmluZ1NlY3Rpb24sXG4gICAgICAgICAgICBzZWN0aW9uSW5kZXg6IHNlY3Rpb25JbmRleCAtIDEsXG4gICAgICAgICAgICBhbmNob3JMaW5rOiBhbmNob3JMaW5rLFxuICAgICAgICAgICAgZWxlbWVudDogY3VycmVudFNlY3Rpb25FbGVtLFxuICAgICAgICAgICAgbGVhdmluZ1NlY3Rpb246IGxlYXZpbmdTZWN0aW9uSW5kZXgsXG4gICAgICAgICAgICBkaXJlY3Rpb246IHlNb3ZlbWVudCxcbiAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgIG9yaWdpbjogZ2V0U3RhdGUoKS5hY3RpdmVTZWN0aW9uLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogY3VycmVudFNlY3Rpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZVNsaWRlKSB7XG4gICAgICAgICAgICBzbGlkZUFuY2hvckxpbmsgPSBhY3RpdmVTbGlkZS5hbmNob3I7XG4gICAgICAgICAgICBzbGlkZUluZGV4ID0gYWN0aXZlU2xpZGUuaW5kZXgoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUuY2FuU2Nyb2xsKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhjdXJyZW50U2VjdGlvbkVsZW0sIEFDVElWRSk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhzaWJsaW5ncyhjdXJyZW50U2VjdGlvbkVsZW0pLCBBQ1RJVkUpO1xuXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihnZXRPcHRpb25zKCkuYmVmb3JlTGVhdmUpKSB7XG4gICAgICAgICAgICAgIGZpcmVDYWxsYmFja09uY2VQZXJTY3JvbGwoJ2JlZm9yZUxlYXZlJywgY2FsbGJhY2tzUGFyYW1zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZ2V0T3B0aW9ucygpLm9uTGVhdmUpKSB7XG4gICAgICAgICAgICAgIGZpcmVDYWxsYmFjaygnb25MZWF2ZScsIGNhbGxiYWNrc1BhcmFtcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGdldE9wdGlvbnMoKS5hZnRlckxvYWQpKSB7XG4gICAgICAgICAgICAgIGZpcmVDYWxsYmFjaygnYWZ0ZXJMb2FkJywgY2FsbGJhY2tzUGFyYW1zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcE1lZGlhKGxlYXZpbmdTZWN0aW9uKTtcbiAgICAgICAgICAgIGxhenlMb2FkUGFuZWxzKGN1cnJlbnRTZWN0aW9uKTtcbiAgICAgICAgICAgIHBsYXlNZWRpYShjdXJyZW50U2VjdGlvbkVsZW0pO1xuICAgICAgICAgICAgYWN0aXZhdGVNZW51QW5kTmF2KGFuY2hvckxpbmssIHNlY3Rpb25JbmRleCAtIDEpO1xuXG4gICAgICAgICAgICBpZiAoZ2V0T3B0aW9ucygpLmFuY2hvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vbmVlZGVkIHRvIGVudGVyIGluIGhhc2hDaGFuZ2UgZXZlbnQgd2hlbiB1c2luZyB0aGUgbWVudSB3aXRoIGFuY2hvciBsaW5rc1xuICAgICAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgbGFzdFNjcm9sbGVkRGVzdGlueTogYW5jaG9yTGlua1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIHNldFBhZ2VTdGF0dXMoc2xpZGVJbmRleCwgc2xpZGVBbmNob3JMaW5rLCBhbmNob3JMaW5rKTtcbiAgICAgICAgICB9IC8vc21hbGwgdGltZW91dCBpbiBvcmRlciB0byBhdm9pZCBlbnRlcmluZyBpbiBoYXNoQ2hhbmdlIGV2ZW50IHdoZW4gc2Nyb2xsaW5nIGlzIG5vdCBmaW5pc2hlZCB5ZXRcblxuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGdfc2Nyb2xsSWQpO1xuICAgICAgICAgIGdfc2Nyb2xsSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgaXNTY3JvbGxpbmc6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdldE9wdGlvbnMoKS5maXRUb1NlY3Rpb24gJiYgc3RhdGUuY2FuU2Nyb2xsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGdfc2Nyb2xsSWQyKTtcbiAgICAgICAgICBnX3Njcm9sbElkMiA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZpeGVkU2VjdGlvbnMgPSBzdGF0ZS5zZWN0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdmFyIHNlY3Rpb25WYWx1ZXMgPSBzZWN0aW9uLml0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNlY3Rpb25WYWx1ZXMuYm90dG9tKSA9PT0gTWF0aC5yb3VuZChnZXRXaW5kb3dIZWlnaHQoKSkgfHwgTWF0aC5yb3VuZChzZWN0aW9uVmFsdWVzLnRvcCkgPT09IDA7XG4gICAgICAgICAgICB9KTsgLy8gTm8gc2VjdGlvbiBpcyBmaXR0aW5nIHRoZSB2aWV3cG9ydD8gTGV0J3MgZml4IHRoYXQhXG5cbiAgICAgICAgICAgIGlmICghZml4ZWRTZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVG91Y2hEZXZpY2UgJiYgaXNGb3JtRWxlbWVudEZvY3VzZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgdG8gYXZvaWQgZml4aW5nIHRoZSBzZWN0aW9uIHdoaWxlIGludGVyYWN0aW5nIHdpdGggZm9ybSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXRUb1NlY3Rpb24oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGdldE9wdGlvbnMoKS5maXRUb1NlY3Rpb25EZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0Zvcm1FbGVtZW50Rm9jdXNlZCgpIHtcbiAgICAgIHZhciBmb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBpZiAoIWZvY3VzZWRFbGVtZW50KSByZXR1cm4gZmFsc2U7IC8vIEluY2x1ZGUgb25seSBlbGVtZW50cyB0aGF0IHRyaWdnZXIgdGhlIGtleWJvYXJkIG9uIG1vYmlsZVxuXG4gICAgICByZXR1cm4gZm9jdXNlZEVsZW1lbnQubWF0Y2hlcygnaW5wdXQsIHRleHRhcmVhJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EZXN0cm95JDEoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZ19zY3JvbGxJZCk7XG4gICAgICBjbGVhclRpbWVvdXQoZ19zY3JvbGxJZDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIGRpcmVjdG9uIG9mIHRoZSB0aGUgc2Nyb2xsaW5nIGZpcmVkIGJ5IHRoZSBzY3JvbGwgZXZlbnQuXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsRGlyZWN0aW9uKGN1cnJlbnRTY3JvbGwpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBjdXJyZW50U2Nyb2xsID4gbGFzdFNjcm9sbCA/ICdkb3duJyA6ICd1cCc7XG4gICAgICBsYXN0U2Nyb2xsID0gY3VycmVudFNjcm9sbDsgLy9uZWVkZWQgZm9yIGF1dG8taGVpZ2h0IHNlY3Rpb25zIHRvIGRldGVybWluZSBpZiB3ZSB3YW50IHRvIHNjcm9sbCB0byB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgZGVzdGluYXRpb25cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBwcmV2aW91c0Rlc3RUb3A6IGN1cnJlbnRTY3JvbGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFjdGl2ZSBzZWN0aW9uIGhhcyBzZWVuIGluIGl0cyB3aG9sZSBvciBub3QuXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gaXNDb21wbGV0ZWx5SW5WaWV3UG9ydChtb3ZlbWVudCkge1xuICAgICAgdmFyIHRvcCA9IGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtLm9mZnNldFRvcDtcbiAgICAgIHZhciBib3R0b20gPSB0b3AgKyBnZXRXaW5kb3dIZWlnaHQoKTtcblxuICAgICAgaWYgKG1vdmVtZW50ID09ICd1cCcpIHtcbiAgICAgICAgcmV0dXJuIGJvdHRvbSA+PSBnZXRTY3JvbGxUb3AoKSArIGdldFdpbmRvd0hlaWdodCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9wIDw9IGdldFNjcm9sbFRvcCgpO1xuICAgIH1cblxuICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYmluZEV2ZW50cywgYmluZEV2ZW50cyQxKTtcbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uRGVzdHJveSwgb25EZXN0cm95KTtcblxuICAgIGZ1bmN0aW9uIG9uRGVzdHJveSgpIHtcbiAgICAgIHdpbmRvd1JlbW92ZUV2ZW50KCdzY3JvbGwnLCBzY3JvbGxIYW5kbGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5kRXZlbnRzJDEoKSB7XG4gICAgICB3aW5kb3dBZGRFdmVudCgnc2Nyb2xsJywgc2Nyb2xsSGFuZGxlcik7XG4gICAgICBkb2MuYm9keS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxIYW5kbGVyKTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMub25TY3JvbGxQYWdlQW5kU2xpZGUsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgc2Nyb2xsUGFnZUFuZFNsaWRlKHBhcmFtcy5zZWN0aW9uQW5jaG9yLCBwYXJhbXMuc2xpZGVBbmNob3IpO1xuICAgICAgfSk7XG4gICAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uTWVudUNsaWNrLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIG1vdmVUbyQxKHBhcmFtcy5hbmNob3IsIHVuZGVmaW5lZCk7XG4gICAgICB9KTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMub25TY3JvbGxPdmVyZmxvd1Njcm9sbGVkLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBzY3JvbGxTZWN0aW9uID0gcGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2Rvd24nID8gbW92ZVNlY3Rpb25Eb3duIDogbW92ZVNlY3Rpb25VcDtcbiAgICAgICAgc2Nyb2xsU2VjdGlvbigpO1xuICAgICAgfSk7XG4gICAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLnNjcm9sbFBhZ2UsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgc2Nyb2xsUGFnZShwYXJhbXMuZGVzdGluYXRpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgRlAuZ2V0QWN0aXZlU2xpZGUgPSBnZXRBY3RpdmVTbGlkZTtcblxuICAgIEZQLmdldFNjcm9sbFggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3RhdGUuc2Nyb2xsWDtcbiAgICB9O1xuXG4gICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5iaW5kRXZlbnRzLCBiaW5kRXZlbnRzKTtcblxuICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XG4gICAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uRGVzdHJveSwgb25EZXN0cm95JDYpO1xuICAgICAgRXZlbnRFbWl0dGVyLm9uKGV2ZW50cy5sYW5kc2NhcGVTY3JvbGwsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgbGFuZHNjYXBlU2Nyb2xsKHBhcmFtcy5zbGlkZXMsIHBhcmFtcy5kZXN0aW5hdGlvbik7XG4gICAgICB9KTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMubW92ZVNsaWRlUmlnaHQsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgbW92ZVNsaWRlUmlnaHQocGFyYW1zLnNlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm1vdmVTbGlkZUxlZnQsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgbW92ZVNsaWRlTGVmdChwYXJhbXMuc2VjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYWZ0ZXJTZWN0aW9uTG9hZHMsIHVwZGF0ZVNjcm9sbFgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbFgocGFyYW1zKSB7XG4gICAgICB2YXIgYWN0aXZlU2xpZGUgPSBwYXJhbXMuaXRlbXMuZGVzdGluYXRpb24uYWN0aXZlU2xpZGU7XG4gICAgICB2YXIgc2Nyb2xsWCA9IGFjdGl2ZVNsaWRlID8gTWF0aC5yb3VuZChhY3RpdmVTbGlkZS5vZmZzZXRMZWZ0KSA6IDA7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHNjcm9sbFg6IHNjcm9sbFhcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEdldHMgdGhlIGFjdGl2ZSBzbGlkZS5cbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBnZXRBY3RpdmVTbGlkZSgpIHtcbiAgICAgIHJldHVybiBudWxsT3JTbGlkZShnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb24uYWN0aXZlU2xpZGUpO1xuICAgIH1cblxuICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYmluZEV2ZW50cywgaW5pdCQxKTtcblxuICAgIGZ1bmN0aW9uIGluaXQkMSgpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGdldE9wdGlvbnMoKS5jcmVkaXRzLnBvc2l0aW9uIHx8ICdyaWdodCc7XG4gICAgICB2YXIgcG9zaXRpb25TdHlsZSA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocG9zaXRpb24pID4gLTEgPyBcIlwiLmNvbmNhdChwb3NpdGlvbiwgXCI6IDA7XCIpIDogJyc7XG4gICAgICB2YXIgd2F0ZXJNYXJrID0gXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLmNvbmNhdChXQVRFUk1BUkssIFwiXFxcIiBzdHlsZT1cXFwiXCIpLmNvbmNhdChwb3NpdGlvblN0eWxlLCBcIlxcXCI+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9hbHZhcm90cmlnby5jb20vZnVsbFBhZ2UvXFxcIiBcXG4gICAgICAgICAgICAgICAgcmVsPVxcXCJub2ZvbGxvdyBub29wZW5lclxcXCIgXFxuICAgICAgICAgICAgICAgIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBcXG4gICAgICAgICAgICAgICAgc3R5bGU9XFxcInRleHQtZGVjb3JhdGlvbjpub25lOyBjb2xvcjogIzAwMDtcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgXCIpLmNvbmNhdChnZXRPcHRpb25zKCkuY3JlZGl0cy5sYWJlbCB8fCAnTWFkZSB3aXRoIGZ1bGxQYWdlLmpzJywgXCJcXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgXCIpO1xuICAgICAgdmFyIGxhc3RTZWN0aW9uID0gZ2V0TGFzdChzdGF0ZS5zZWN0aW9ucyk7XG4gICAgICB2YXIgc2hvdWxkVXNlV2F0ZXJNYXJrID0gIXN0YXRlLmlzVmFsaWQgfHwgZ2V0T3B0aW9ucygpLmNyZWRpdHMuZW5hYmxlZDtcblxuICAgICAgaWYgKGxhc3RTZWN0aW9uICYmIGxhc3RTZWN0aW9uLml0ZW0gJiYgc2hvdWxkVXNlV2F0ZXJNYXJrKSB7XG4gICAgICAgIGxhc3RTZWN0aW9uLml0ZW0uaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCB3YXRlck1hcmspO1xuICAgICAgfVxuICAgIH1cblxuICAgICFmdW5jdGlvbiAoKSB7XG4gICAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uSW5pdGlhbGlzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiwgYSwgbDtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzVmFsaWQ6IChnZXRPcHRpb25zKCkubGljZW5zZUtleSwgbiA9IGdldE9wdGlvbnMoKS5saWNlbnNlS2V5LCBhID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciBlID0gcGFyc2VJbnQoXCJcXHgzNVxceDMxXFx4MzRcIikudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKCFuIHx8IG4ubGVuZ3RoIDwgMjkgfHwgNCA9PT0gbi5zcGxpdCh0WzBdKS5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHIgPSBbXCJcXHg0NVxceDYxXFx4NjNcXHg2OFwiLCBcIlxceDY2XFx4NmZcXHg3MlwiXVtpKCldKCkuam9pbihcIlwiKSxcbiAgICAgICAgICAgICAgICBhID0gbltbXCJcXHg3M1xceDcwXFx4NmNcXHg2OVxceDc0XCJdXShcIi1cIiksXG4gICAgICAgICAgICAgICAgbCA9IFtdO1xuICAgICAgICAgICAgYVtyXShmdW5jdGlvbiAodCwgbikge1xuICAgICAgICAgICAgICBpZiAobiA8IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbiA9IHRbdC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICBlID0gW1wiXFx4NGVcXHg2MVxceDRlXCIsIFwiXFx4NjlcXHg3M1wiXVtpKCldKCkuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dbZV0obikgPyBvKG4pIDogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgLSBBQ1RJVkUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfShuKTtcbiAgICAgICAgICAgICAgICB9KHQpO1xuXG4gICAgICAgICAgICAgICAgbC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgIHZhciBzID0gbyh0W3JdKTtcblxuICAgICAgICAgICAgICAgIGlmICgxID09PSBuKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYSA9IFtcIlxceDcwXFx4NjFcIiwgXCJcXHg2NFxceDUzXCIsIFwiXFx4NzRcIiwgXCJcXHg2MVxceDcyXFx4NzRcIl0uam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgIHMgPSBzLnRvU3RyaW5nKClbYV0oMiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGUgKz0gcywgMCAhPT0gbiAmJiAxICE9PSBuIHx8IChlICs9IFwiLVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZiA9IDAsXG4gICAgICAgICAgICAgICAgbSA9IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gbi5zcGxpdChcIi1cIikuZm9yRWFjaChmdW5jdGlvbiAodCwgbikge1xuICAgICAgICAgICAgICBpZiAobiA8IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2kgPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCA0OyBlKyspIHtcbiAgICAgICAgICAgICAgICAgIGUgIT09IGxbbl0gJiYgKF9pICs9IE1hdGguYWJzKG8odFtlXSkpLCBpc05hTih0W2VdKSB8fCBmKyspO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByID0gcyhfaSk7XG4gICAgICAgICAgICAgICAgbSArPSByO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgbSArPSBzKGYpLCB7XG4gICAgICAgICAgICAgIHY6IG5ldyBEYXRlKGUgKyBcIlQwMDowMFwiKSxcbiAgICAgICAgICAgICAgbzogZS5zcGxpdChcIi1cIilbMl0gPT09IDggKiAoQUNUSVZFLmxlbmd0aCAtIDIpICsgXCJcIixcbiAgICAgICAgICAgICAgbDogbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KG4pLCBsID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciBuID0gcltpKCldKCkuam9pbihcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0ICYmIDAgPT09IG4uaW5kZXhPZih0KSAmJiB0Lmxlbmd0aCA9PT0gbi5sZW5ndGg7XG4gICAgICAgICAgfShuKSB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD89Lio/W0EtWV0pKD89Lio/W2EteV0pKD89Lio/WzAtOF0pKD89Lio/WyM/IUAkJV4mKi1dKS57OCx9JFwiKS50ZXN0KHQpO1xuICAgICAgICAgIH0obiksIChhIHx8IGwpICYmIChhICYmIGUgPD0gYS52ICYmIGEubCA9PT0gbi5zcGxpdCh0WzBdKVs0XSB8fCBsIHx8IGEubykgfHwgITEpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgdCA9IFtcIi1cIl07XG4gICAgICB2YXIgbiA9IFwiXFx4MzJcXHgzMFxceDMyXFx4MzVcXHgyZFxceDM1XFx4MmRcXHgzMlxceDM2XCIuc3BsaXQoXCItXCIpLFxuICAgICAgICAgIGUgPSBuZXcgRGF0ZShuWzBdLCBuWzFdLCBuWzJdKSxcbiAgICAgICAgICByID0gW1wic2VcIiwgXCJsaWNlblwiLCBcIi1cIiwgXCJ2M1wiLCBcImxcIiwgXCJncFwiXTtcblxuICAgICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgcmV0dXJuIFtbXCJcXHg3MlxceDY1XCIsIFwiXFx4NzZcXHg2NVxceDcyXFx4NzNcXHg2NVwiXS5qb2luKFwiXCIpXVtcIlwiLmxlbmd0aF07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG8odCkge1xuICAgICAgICByZXR1cm4gdCA/IGlzTmFOKHQpID8gdC5jaGFyQ29kZUF0KDApIC0gNzIgOiB0IDogXCJcIjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcyh0KSB7XG4gICAgICAgIHZhciBuID0gNzIgKyB0O1xuICAgICAgICByZXR1cm4gbiA+IDkwICYmIG4gPCA5NyAmJiAobiArPSAxNSksIFN0cmluZy5mcm9tQ2hhckNvZGUobikudG9VcHBlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9KCk7XG5cbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uUGVyZm9ybU1vdmVtZW50LCBvblNsaWRlT3JTY3JvbGwpO1xuICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYWZ0ZXJTZWN0aW9uTG9hZHMsIGFmdGVyUGFuZWxMb2FkKTtcbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLm9uU2xpZGVMZWF2ZSwgb25TbGlkZU9yU2Nyb2xsKTtcbiAgICBFdmVudEVtaXR0ZXIub24oZXZlbnRzLmFmdGVyU2xpZGVMb2FkcywgYWZ0ZXJQYW5lbExvYWQpO1xuXG4gICAgZnVuY3Rpb24gb25TbGlkZU9yU2Nyb2xsKHBhcmFtcykge1xuICAgICAgdmFyIHNraXBWYWx1ZSA9IGdldE9wdGlvbnMoKS5za2lwSW50ZXJtZWRpYXRlSXRlbXM7XG4gICAgICB2YXIgc2Nyb2xsVHlwZSA9IHBhcmFtcy5pdGVtcy5vcmlnaW4uaXNTZWN0aW9uID8gJ3NlY3Rpb25zJyA6ICdzbGlkZXMnO1xuICAgICAgdmFyIGFyZUNvbnNlY3V0aXZlUGFuZWxzID0gTWF0aC5hYnMocGFyYW1zLml0ZW1zLm9yaWdpbi5pbmRleCgpIC0gcGFyYW1zLml0ZW1zLmRlc3RpbmF0aW9uLmluZGV4KCkpID4gMTtcbiAgICAgIHZhciBkb2VzQXBwbHkgPSAoc2tpcFZhbHVlID09PSB0cnVlIHx8IHNraXBWYWx1ZSA9PT0gc2Nyb2xsVHlwZSkgJiYgYXJlQ29uc2VjdXRpdmVQYW5lbHM7XG5cbiAgICAgIGlmIChkb2VzQXBwbHkpIHtcbiAgICAgICAgc2V0U2Nyb2xsaW5nU3BlZWQoMCwgJ2ludGVybmFsJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWZ0ZXJQYW5lbExvYWQocGFyYW1zKSB7XG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLnNraXBJbnRlcm1lZGlhdGVJdGVtcykge1xuICAgICAgICBzZXRWYXJpYWJsZVN0YXRlKCdzY3JvbGxpbmdTcGVlZCcsIGdldE9yaWdpbmFscygpLnNjcm9sbGluZ1NwZWVkLCAnaW50ZXJuYWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0B0cy1jaGVja1xuICAgIEV2ZW50RW1pdHRlci5vbihldmVudHMuYmVmb3JlSW5pdCwgYmVmb3JlSW5pdCk7XG4gICAgRlAuc2V0S2V5Ym9hcmRTY3JvbGxpbmcgPSBzZXRLZXlib2FyZFNjcm9sbGluZztcblxuICAgIGZ1bmN0aW9uIGJlZm9yZUluaXQoKSB7XG4gICAgICBzZXRLZXlib2FyZFNjcm9sbGluZyh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBZGRzIG9yIHJlbW92ZSB0aGUgcG9zc2liaWxpdHkgb2Ygc2Nyb2xsaW5nIHRocm91Z2ggc2VjdGlvbnMgYnkgdXNpbmcgdGhlIGtleWJvYXJkIGFycm93IGtleXNcbiAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBzZXRLZXlib2FyZFNjcm9sbGluZyh2YWx1ZSwgZGlyZWN0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBkaXJlY3Rpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkaXJlY3Rpb25zID0gZGlyZWN0aW9ucy5yZXBsYWNlKC8gL2csICcnKS5zcGxpdCgnLCcpO1xuICAgICAgICBkaXJlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICAgIHNldElzU2Nyb2xsQWxsb3dlZCh2YWx1ZSwgZGlyZWN0aW9uLCAnaycpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldElzU2Nyb2xsQWxsb3dlZCh2YWx1ZSwgJ2FsbCcsICdrJyk7XG4gICAgICAgIGdldE9wdGlvbnMoKS5rZXlib2FyZFNjcm9sbGluZyA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogU2V0cyB0aGUgZGF0YS1hbmNob3IgYXR0cmlidXRlcyB0byB0aGUgbWVudSBlbGVtZW50cyBhbmQgYWN0aXZhdGVzIHRoZSBjdXJyZW50IG9uZS5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gc3R5bGVNZW51KHNlY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IHNlY3Rpb24uaW5kZXgoKTtcblxuICAgICAgaWYgKHR5cGVvZiBnZXRPcHRpb25zKCkuYW5jaG9yc1tpbmRleF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vYWN0aXZhdGluZyB0aGUgbWVudSAvIG5hdiBlbGVtZW50IG9uIGxvYWRcbiAgICAgICAgaWYgKHNlY3Rpb24uaXNBY3RpdmUpIHtcbiAgICAgICAgICBhY3RpdmF0ZU1lbnVBbmROYXYoZ2V0T3B0aW9ucygpLmFuY2hvcnNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy9tb3ZpbmcgdGhlIG1lbnUgb3V0c2lkZSB0aGUgbWFpbiBjb250YWluZXIgaWYgaXQgaXMgaW5zaWRlIChhdm9pZCBwcm9ibGVtcyB3aXRoIGZpeGVkIHBvc2l0aW9ucyB3aGVuIHVzaW5nIENTUzMgdHJhbmZvcm1zKVxuXG5cbiAgICAgIGlmIChnZXRPcHRpb25zKCkubWVudSAmJiBnZXRPcHRpb25zKCkuY3NzMyAmJiBjbG9zZXN0KCQoZ2V0T3B0aW9ucygpLm1lbnUpWzBdLCBXUkFQUEVSX1NFTCkgIT0gbnVsbCkge1xuICAgICAgICAkKGdldE9wdGlvbnMoKS5tZW51KS5mb3JFYWNoKGZ1bmN0aW9uIChtZW51KSB7XG4gICAgICAgICAgJGJvZHkuYXBwZW5kQ2hpbGQobWVudSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogV29ya3Mgb3ZlciB0aGUgRE9NIHN0cnVjdHVyZSB0byBzZXQgaXQgdXAgZm9yIHRoZSBjdXJyZW50IGZ1bGxwYWdlIGdldE9wdGlvbnMoKS5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gcHJlcGFyZURvbSgpIHtcbiAgICAgIGNzcyhnZXRQYXJlbnRzVW50aWwoZ2V0Q29udGFpbmVyKCksICdib2R5JyksIHtcbiAgICAgICAgJ2hlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgJ3Bvc2l0aW9uJzogJ3JlbGF0aXZlJ1xuICAgICAgfSk7IC8vYWRkaW5nIGEgY2xhc3MgdG8gcmVjb2duaXplIHRoZSBjb250YWluZXIgaW50ZXJuYWxseSBpbiB0aGUgY29kZVxuXG4gICAgICBhZGRDbGFzcyhnZXRDb250YWluZXIoKSwgV1JBUFBFUik7XG4gICAgICBhZGRDbGFzcygkaHRtbCwgRU5BQkxFRCk7IC8vZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9hbHZhcm90cmlnby9mdWxsUGFnZS5qcy9pc3N1ZXMvMTUwMlxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHdpbmRvd3NIZWlnaHQ6IGdldFdpbmRvd0hlaWdodCgpXG4gICAgICB9KTtcbiAgICAgIHJlbW92ZUNsYXNzKGdldENvbnRhaW5lcigpLCBERVNUUk9ZRUQpOyAvL2luIGNhc2UgaXQgd2FzIGRlc3Ryb3llZCBiZWZvcmUgaW5pdGlhbGl6aW5nIGl0IGFnYWluXG5cbiAgICAgIGFkZEludGVybmFsU2VsZWN0b3JzKCk7XG4gICAgICB2YXIgc2VjdGlvbnMgPSBnZXRTdGF0ZSgpLnNlY3Rpb25zSW5jbHVkaW5nSGlkZGVuOyAvL3N0eWxpbmcgdGhlIHNlY3Rpb25zIC8gc2xpZGVzIC8gbWVudVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gc2VjdGlvbnNbaV07XG4gICAgICAgIHZhciBzbGlkZXMgPSBzZWN0aW9uLmFsbFNsaWRlc0l0ZW1zOyAvL2NhY2hpbmcgdGhlIG9yaWdpbmFsIHN0eWxlcyB0byBhZGQgdGhlbSBiYWNrIG9uIGRlc3Ryb3koJ2FsbCcpXG5cbiAgICAgICAgdmFyIG9yaWdpbmFsU3R5bGVzID0gZ2V0QXR0cihzZWN0aW9uLml0ZW0sICdzdHlsZScpO1xuXG4gICAgICAgIGlmIChvcmlnaW5hbFN0eWxlcykge1xuICAgICAgICAgIHNlY3Rpb24uaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZnAtc3R5bGVzJywgb3JpZ2luYWxTdHlsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVTZWN0aW9uKHNlY3Rpb24pO1xuICAgICAgICBzdHlsZU1lbnUoc2VjdGlvbik7IC8vIGlmIHRoZXJlJ3MgYW55IHNsaWRlXG5cbiAgICAgICAgaWYgKHNsaWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3R5bGVTbGlkZXMoc2VjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gLy9maXhlZCBlbGVtZW50cyBuZWVkIHRvIGJlIG1vdmVkIG91dCBvZiB0aGUgcGx1Z2luIGNvbnRhaW5lciBkdWUgdG8gcHJvYmxlbXMgd2l0aCBDU1MzLlxuXG5cbiAgICAgIGlmIChnZXRPcHRpb25zKCkuZml4ZWRFbGVtZW50cyAmJiBnZXRPcHRpb25zKCkuY3NzMykge1xuICAgICAgICAkKGdldE9wdGlvbnMoKS5maXhlZEVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgJGJvZHkuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvL3ZlcnRpY2FsIGNlbnRlcmVkIG9mIHRoZSBuYXZpZ2F0aW9uICsgYWN0aXZlIGJ1bGxldFxuXG5cbiAgICAgIGlmIChnZXRPcHRpb25zKCkubmF2aWdhdGlvbikge1xuICAgICAgICBhZGRWZXJ0aWNhbE5hdmlnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgZW5hYmxlWW91dHViZUFQSSgpO1xuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLnNjcm9sbE92ZXJmbG93KSB7XG4gICAgICAgIHNjcm9sbE92ZXJmbG93SGFuZGxlci5tYWtlU2Nyb2xsYWJsZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEZQLnNoYXJlZC5hZnRlclJlbmRlckFjdGlvbnMgPSBhZnRlclJlbmRlckFjdGlvbnM7XG4gICAgLyoqXG4gICAgKiBBY3Rpb25zIGFuZCBjYWxsYmFja3MgdG8gZmlyZSBhZnRlclJlbmRlclxuICAgICovXG5cbiAgICBmdW5jdGlvbiBhZnRlclJlbmRlckFjdGlvbnMoKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbjtcbiAgICAgIHZhciBzZWN0aW9uRWxlbSA9IGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbi5pdGVtO1xuICAgICAgYWRkQ2xhc3Moc2VjdGlvbkVsZW0sIENPTVBMRVRFTFkpO1xuICAgICAgbGF6eUxvYWRQYW5lbHMoZ2V0U3RhdGUoKS5hY3RpdmVTZWN0aW9uKTtcbiAgICAgIGxhenlMb2FkT3RoZXJzKCk7XG4gICAgICBwbGF5TWVkaWEoc2VjdGlvbkVsZW0pO1xuXG4gICAgICBpZiAoaXNEZXN0aW55VGhlU3RhcnRpbmdTZWN0aW9uKCkgJiYgaXNGdW5jdGlvbihnZXRPcHRpb25zKCkuYWZ0ZXJMb2FkKSkge1xuICAgICAgICBmaXJlQ2FsbGJhY2soJ2FmdGVyTG9hZCcsIHtcbiAgICAgICAgICBhY3RpdmVTZWN0aW9uOiBzZWN0aW9uRWxlbSxcbiAgICAgICAgICBlbGVtZW50OiBzZWN0aW9uRWxlbSxcbiAgICAgICAgICBkaXJlY3Rpb246IG51bGwsXG4gICAgICAgICAgLy9mb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgY2FsbGJhY2sgKHRvIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUhKVxuICAgICAgICAgIGFuY2hvckxpbms6IHNlY3Rpb24uYW5jaG9yLFxuICAgICAgICAgIHNlY3Rpb25JbmRleDogc2VjdGlvbi5pbmRleCgpLFxuICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICBvcmlnaW46IGdldFN0YXRlKCkuYWN0aXZlU2VjdGlvbixcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBnZXRTdGF0ZSgpLmFjdGl2ZVNlY3Rpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihnZXRPcHRpb25zKCkuYWZ0ZXJSZW5kZXIpKSB7XG4gICAgICAgIGZpcmVDYWxsYmFjaygnYWZ0ZXJSZW5kZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBVUkwgYW5jaG9yIGRlc3RpbnkgaXMgdGhlIHN0YXJ0aW5nIHNlY3Rpb24gKHRoZSBvbmUgdXNpbmcgJ2FjdGl2ZScgY2xhc3MgYmVmb3JlIGluaXRpYWxpemF0aW9uKVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBpc0Rlc3RpbnlUaGVTdGFydGluZ1NlY3Rpb24oKSB7XG4gICAgICB2YXIgYW5jaG9yID0gZ2V0QW5jaG9yc1VSTCgpO1xuICAgICAgdmFyIGRlc3RpbmF0aW9uU2VjdGlvbiA9IGdldFNlY3Rpb25CeUFuY2hvcihhbmNob3Iuc2VjdGlvbik7XG4gICAgICByZXR1cm4gIWFuY2hvci5zZWN0aW9uIHx8ICFkZXN0aW5hdGlvblNlY3Rpb24gfHwgdHlwZW9mIGRlc3RpbmF0aW9uU2VjdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVzdGluYXRpb25TZWN0aW9uLmluZGV4KCkgPT09IGluZGV4KGdldFN0YXJ0aW5nU2VjdGlvbigpKTtcbiAgICB9XG5cbiAgICBGUC5zZXRBbGxvd1Njcm9sbGluZyA9IHNldEFsbG93U2Nyb2xsaW5nO1xuICAgIC8qKlxuICAgICogQWRkcyBvciByZW1vdmUgdGhlIHBvc3NpYmlsaXR5IG9mIHNjcm9sbGluZyB0aHJvdWdoIHNlY3Rpb25zIGJ5IHVzaW5nIHRoZSBtb3VzZSB3aGVlbC90cmFja3BhZCBvciB0b3VjaCBnZXN0dXJlcy5cbiAgICAqIE9wdGlvbmFsbHkgYSBzZWNvbmQgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGRpcmVjdGlvbiBmb3Igd2hpY2ggdGhlIGFjdGlvbiB3aWxsIGJlIGFwcGxpZWQuXG4gICAgKlxuICAgICogQHBhcmFtIGRpcmVjdGlvbnMgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGRpcmVjdGlvbiBvciBkaXJlY3Rpb25zIHNlcGFyYXRlZCBieSBjb21tYS5cbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2V0QWxsb3dTY3JvbGxpbmcodmFsdWUsIGRpcmVjdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgZGlyZWN0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGlyZWN0aW9ucyA9IGRpcmVjdGlvbnMucmVwbGFjZSgvIC9nLCAnJykuc3BsaXQoJywnKTtcbiAgICAgICAgZGlyZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICBzZXRJc1Njcm9sbEFsbG93ZWQodmFsdWUsIGRpcmVjdGlvbiwgJ20nKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRJc1Njcm9sbEFsbG93ZWQodmFsdWUsICdhbGwnLCAnbScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogU2Nyb2xscyB0byB0aGUgYW5jaG9yIGluIHRoZSBVUkwgd2hlbiBsb2FkaW5nIHRoZSBzaXRlXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIHNjcm9sbFRvQW5jaG9yKCkge1xuICAgICAgdmFyIGFuY2hvcnMgPSBnZXRBbmNob3JzVVJMKCk7XG4gICAgICB2YXIgc2VjdGlvbkFuY2hvciA9IGFuY2hvcnMuc2VjdGlvbjtcbiAgICAgIHZhciBzbGlkZUFuY2hvciA9IGFuY2hvcnMuc2xpZGU7XG5cbiAgICAgIGlmIChzZWN0aW9uQW5jaG9yKSB7XG4gICAgICAgIC8vaWYgdGhlcmVzIGFueSAjXG4gICAgICAgIGlmIChnZXRPcHRpb25zKCkuYW5pbWF0ZUFuY2hvcikge1xuICAgICAgICAgIHNjcm9sbFBhZ2VBbmRTbGlkZShzZWN0aW9uQW5jaG9yLCBzbGlkZUFuY2hvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2lsZW50TW92ZVRvKHNlY3Rpb25BbmNob3IsIHNsaWRlQW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRzLm9uQWZ0ZXJSZW5kZXJOb0FuY2hvciwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAqIFJlbW92ZXMgaW5saW5lIHN0eWxlcyBhZGRlZCBieSBmdWxscGFnZS5qc1xuICAgICovXG5cbiAgICBmdW5jdGlvbiBkZXN0cm95U3RydWN0dXJlKCkge1xuICAgICAgLy9yZXNldGluZyB0aGUgYHRvcGAgb3IgYHRyYW5zbGF0ZWAgcHJvcGVydGllcyB0byAwXG4gICAgICBzaWxlbnRTY3JvbGwoMCk7IC8vbG9hZGluZyBhbGwgdGhlIGxhenkgbG9hZCBjb250ZW50XG5cbiAgICAgICQoJ2ltZ1tkYXRhLXNyY10sIHNvdXJjZVtkYXRhLXNyY10sIGF1ZGlvW2RhdGEtc3JjXSwgaWZyYW1lW2RhdGEtc3JjXScsIGdldENvbnRhaW5lcigpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHNldFNyYyhpdGVtLCAnc3JjJyk7XG4gICAgICB9KTtcbiAgICAgICQoJ2ltZ1tkYXRhLXNyY3NldF0nKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHNldFNyYyhpdGVtLCAnc3Jjc2V0Jyk7XG4gICAgICB9KTtcbiAgICAgIHJlbW92ZSgkKFNFQ1RJT05fTkFWX1NFTCArICcsICcgKyBTTElERVNfTkFWX1NFTCArICcsICcgKyBTTElERVNfQVJST1dfU0VMICsgJywgJyArIFdBVEVSTUFSS19TRUwpKTsgLy9yZW1vdmluZyBpbmxpbmUgc3R5bGVzXG5cbiAgICAgIGNzcyhnZXROb2RlcyhnZXRTdGF0ZSgpLnNlY3Rpb25zKSwge1xuICAgICAgICAnaGVpZ2h0JzogJycsXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJycsXG4gICAgICAgICdwYWRkaW5nJzogJydcbiAgICAgIH0pO1xuICAgICAgY3NzKGdldE5vZGVzKGdldFN0YXRlKCkuc2xpZGVzKSwge1xuICAgICAgICAnd2lkdGgnOiAnJ1xuICAgICAgfSk7XG4gICAgICBjc3MoZ2V0Q29udGFpbmVyKCksIHtcbiAgICAgICAgJ2hlaWdodCc6ICcnLFxuICAgICAgICAncG9zaXRpb24nOiAnJyxcbiAgICAgICAgJy1tcy10b3VjaC1hY3Rpb24nOiAnJyxcbiAgICAgICAgJ3RvdWNoLWFjdGlvbic6ICcnXG4gICAgICB9KTtcbiAgICAgIGNzcygkaHRtbEJvZHksIHtcbiAgICAgICAgJ292ZXJmbG93JzogJycsXG4gICAgICAgICdoZWlnaHQnOiAnJ1xuICAgICAgfSk7IC8vIHJlbW92ZSAuZnAtZW5hYmxlZCBjbGFzc1xuXG4gICAgICByZW1vdmVDbGFzcygkaHRtbCwgRU5BQkxFRCk7IC8vIHJlbW92ZSAuZnAtcmVzcG9uc2l2ZSBjbGFzcyAmIC5mcC1zY3JvbGxhYmxlXG5cbiAgICAgIHJlbW92ZUNsYXNzKCRib2R5LCBSRVNQT05TSVZFICsgJyAnICsgU0NST0xMQUJMRSk7IC8vIHJlbW92ZSBhbGwgb2YgdGhlIC5mcC12aWV3aW5nLSBjbGFzc2VzXG5cbiAgICAgICRib2R5LmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoVklFV0lOR19QUkVGSVgpID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoJGJvZHksIGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvL3JlbW92aW5nIGFkZGVkIGNsYXNzZXNcblxuICAgICAgZ2V0Tm9kZXMoZ2V0U3RhdGUoKS5wYW5lbHMpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGdldE9wdGlvbnMoKS5zY3JvbGxPdmVyZmxvdykge1xuICAgICAgICAgIHNjcm9sbE92ZXJmbG93SGFuZGxlci5kZXN0cm95V3JhcHBlcihpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZUNsYXNzKGl0ZW0sIFRBQkxFICsgJyAnICsgQUNUSVZFICsgJyAnICsgQ09NUExFVEVMWSArICcgJyArIElTX09WRVJGTE9XICsgJyAnICsgTE9BREVEKTtcbiAgICAgICAgdmFyIHByZXZpb3VzU3R5bGVzID0gZ2V0QXR0cihpdGVtLCAnZGF0YS1mcC1zdHlsZXMnKTtcblxuICAgICAgICBpZiAocHJldmlvdXNTdHlsZXMpIHtcbiAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBwcmV2aW91c1N0eWxlcyk7XG4gICAgICAgIH0gLy9yZW1vdmluZyBhbmNob3JzIGlmIHRoZXkgd2VyZSBub3Qgc2V0IHVzaW5nIHRoZSBIVE1MIG1hcmt1cFxuXG5cbiAgICAgICAgaWYgKGhhc0NsYXNzKGl0ZW0sIFNFQ1RJT04pICYmICFnZXRJbml0aWFsQW5jaG9yc0luRG9tKCkpIHtcbiAgICAgICAgICBpdGVtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbmNob3InKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vcmVtb3ZpbmcgdGhlIGFwcGxpZWQgdHJhbnNpdGlvbiBmcm9tIHRoZSBmdWxscGFnZSB3cmFwcGVyXG5cbiAgICAgIHJlbW92ZUFuaW1hdGlvbihnZXRDb250YWluZXIoKSk7IC8vVW53cmFwcGluZyBjb250ZW50XG5cbiAgICAgIFtUQUJMRV9DRUxMX1NFTCwgU0xJREVTX0NPTlRBSU5FUl9TRUwsIFNMSURFU19XUkFQUEVSX1NFTF0uZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgJChzZWxlY3RvciwgZ2V0Q29udGFpbmVyKCkpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAvL3Vud3JhcCBub3QgYmVpbmcgdXNlIGluIGNhc2UgdGhlcmUncyBubyBjaGlsZCBlbGVtZW50IGluc2lkZSBhbmQgaXRzIGp1c3QgdGV4dFxuICAgICAgICAgIHVud3JhcChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy9yZW1vdmluZyB0aGUgYXBwbGllZCB0cmFuc2l0aW9uIGZyb20gdGhlIGZ1bGxwYWdlIHdyYXBwZXJcblxuICAgICAgY3NzKGdldENvbnRhaW5lcigpLCB7XG4gICAgICAgICctd2Via2l0LXRyYW5zaXRpb24nOiAnbm9uZScsXG4gICAgICAgICd0cmFuc2l0aW9uJzogJ25vbmUnXG4gICAgICB9KTtcbiAgICAgIHJlbW92ZUNsYXNzKGdldENvbnRhaW5lcigpLCBXUkFQUEVSKTsgLy9zY3JvbGxpbmcgdGhlIHBhZ2UgdG8gdGhlIHRvcCB3aXRoIG5vIGFuaW1hdGlvblxuXG4gICAgICB3aW4uc2Nyb2xsVG8oMCwgMCk7IC8vcmVtb3Zpbmcgc2VsZWN0b3JzXG5cbiAgICAgIHZhciB1c2VkU2VsZWN0b3JzID0gW1NFQ1RJT04sIFNMSURFLCBTTElERVNfQ09OVEFJTkVSXTtcbiAgICAgIHVzZWRTZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZW1vdmVDbGFzcygkKCcuJyArIGl0ZW0pLCBpdGVtKTtcbiAgICAgIH0pO1xuICAgICAgcmVzZXRTdGF0ZSgpO1xuICAgICAgRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRzLm9uRGVzdHJveUFsbCk7XG4gICAgfVxuXG4gICAgRlAuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHVwZGF0ZVN0cnVjdHVyYWxTdGF0ZSgpO1xuICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgIGdldE9wdGlvbnMoKS5zY3JvbGxCYXIgPSBnZXRPcHRpb25zKCkuc2Nyb2xsQmFyIHx8IGdldE9wdGlvbnMoKS5oeWJyaWQ7XG4gICAgICBzZXRPcHRpb25zRnJvbURPTSgpO1xuICAgICAgcHJlcGFyZURvbSgpO1xuICAgICAgc2V0QWxsb3dTY3JvbGxpbmcodHJ1ZSk7XG4gICAgICBzZXRNb3VzZUhpamFjayh0cnVlKTtcbiAgICAgIHNldEF1dG9TY3JvbGxpbmcoZ2V0T3B0aW9ucygpLmF1dG9TY3JvbGxpbmcsICdpbnRlcm5hbCcpO1xuICAgICAgcmVzcG9uc2l2ZSgpOyAvL3NldHRpbmcgdGhlIGNsYXNzIGZvciB0aGUgYm9keSBlbGVtZW50XG5cbiAgICAgIHNldEJvZHlDbGFzcygpO1xuXG4gICAgICBpZiAoZG9jLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgc2Nyb2xsVG9BbmNob3IoKTtcbiAgICAgIH1cblxuICAgICAgd2luZG93QWRkRXZlbnQoJ2xvYWQnLCBzY3JvbGxUb0FuY2hvcik7XG4gICAgICBhZnRlclJlbmRlckFjdGlvbnMoKTsgLy8gVXBkYXRpbmcgdGhlIHN0YXRlIGFnYWluIHdpdGggdGhlIG5ldyBET01cblxuICAgICAgdXBkYXRlU3RydWN0dXJhbFN0YXRlKCk7XG4gICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgIH1cbiAgICAvKlxuICAgICogRGVzdHJveXMgZnVsbHBhZ2UuanMgcGx1Z2luIGV2ZW50cyBhbmQgb3B0aW5hbGx5IGl0cyBodG1sIG1hcmt1cCBhbmQgc3R5bGVzXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koYWxsKSB7XG4gICAgICBzZXRBdXRvU2Nyb2xsaW5nKGZhbHNlLCAnaW50ZXJuYWwnKTtcbiAgICAgIHNldEFsbG93U2Nyb2xsaW5nKHRydWUpO1xuICAgICAgc2V0TW91c2VIaWphY2soZmFsc2UpO1xuICAgICAgc2V0S2V5Ym9hcmRTY3JvbGxpbmcoZmFsc2UpO1xuICAgICAgYWRkQ2xhc3MoZ2V0Q29udGFpbmVyKCksIERFU1RST1lFRCk7XG4gICAgICBFdmVudEVtaXR0ZXIuZW1pdChldmVudHMub25EZXN0cm95KTsgLy9sZXRzIG1ha2UgYSBtZXNzIVxuXG4gICAgICBpZiAoYWxsKSB7XG4gICAgICAgIGRlc3Ryb3lTdHJ1Y3R1cmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXNPSyA9IGZ1bmN0aW9uIGlzT0soKSB7XG4gICAgICByZXR1cm4gZ2V0T3B0aW9ucygpICYmIHN0YXRlLmlzVmFsaWQgfHwgZG9jLmRvbWFpbi5pbmRleE9mKCdhbCcgKyAndmFyb3RyaScgKyAnZ28nICsgJy4nICsgJ2NvbScpID4gLTE7XG4gICAgfTtcbiAgICAvKipcbiAgICAqIERpc3BsYXlzIHdhcm5pbmdzXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gZGlzcGxheVdhcm5pbmdzKCkge1xuICAgICAgdmFyIGwgPSBnZXRPcHRpb25zKClbJ2xpJyArICdjJyArICdlbnNlSycgKyAnZScgKyAneSddO1xuICAgICAgdmFyIG1zZ1N0eWxlID0gJ2ZvbnQtc2l6ZTogMTVweDtiYWNrZ3JvdW5kOnllbGxvdzsnO1xuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLmxpY2Vuc2VLZXkudHJpbSgpID09PSAnJykge1xuICAgICAgICBzaG93RXJyb3IoJ2Vycm9yJywgJ0Z1bGxwYWdlLmpzIHJlcXVpcmVzIGEgYGxpY2Vuc2VLZXlgIG9wdGlvbi4gUmVhZCBhYm91dCBpdCBvbiB0aGUgZm9sbG93aW5nIHdlYnNpdGU6Jyk7XG4gICAgICAgIHNob3dFcnJvcignZXJyb3InLCAnaHR0cHM6Ly9hbHZhcm90cmlnby5jb20vZnVsbFBhZ2UvZG9jcy8jbGljZW5zZWtleScpO1xuICAgICAgfSBlbHNlIGlmICghaXNPSygpKSB7XG4gICAgICAgIHNob3dFcnJvcignZXJyb3InLCAnSW5jb3JyZWN0IGBsaWNlbnNlS2V5YC4gR2V0IG9uZSBmb3IgZnVsbFBhZ2UuanMgdmVyc2lvbiA0IGhlcmU6Jyk7XG4gICAgICAgIHNob3dFcnJvcignZXJyb3InLCAnaHR0cHM6Ly9hbHZhcm90cmlnby5jb20vZnVsbFBhZ2UvcHJpY2luZycpO1xuICAgICAgfSBlbHNlIGlmIChsICYmIGwubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCclYyBUaGlzIHdlYnNpdGUgd2FzIG1hZGUgdXNpbmcgZnVsbFBhZ2UuanMgc2xpZGVyLiBMZWFybiBtb3JlIG9uIHRoZSBmb2xsb3dpbmcgd2Vic2l0ZTonLCBtc2dTdHlsZSk7XG4gICAgICAgIGNvbnNvbGUud2FybignJWMgaHR0cHM6Ly9hbHZhcm90cmlnby5jb20vZnVsbFBhZ2UvJywgbXNnU3R5bGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzQ2xhc3MoJGh0bWwsIEVOQUJMRUQpKSB7XG4gICAgICAgIHNob3dFcnJvcignZXJyb3InLCAnRnVsbHBhZ2UuanMgY2FuIG9ubHkgYmUgaW5pdGlhbGl6ZWQgb25jZSBhbmQgeW91IGFyZSBkb2luZyBpdCBtdWx0aXBsZSB0aW1lcyEnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBEaXNhYmxlIG11dHVhbGx5IGV4Y2x1c2l2ZSBzZXR0aW5nc1xuXG5cbiAgICAgIGlmIChnZXRPcHRpb25zKCkuY29udGludW91c1ZlcnRpY2FsICYmIChnZXRPcHRpb25zKCkubG9vcFRvcCB8fCBnZXRPcHRpb25zKCkubG9vcEJvdHRvbSkpIHtcbiAgICAgICAgZ2V0T3B0aW9ucygpLmNvbnRpbnVvdXNWZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICBzaG93RXJyb3IoJ3dhcm4nLCAnT3B0aW9uIGBsb29wVG9wL2xvb3BCb3R0b21gIGlzIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGBjb250aW51b3VzVmVydGljYWxgOyBgY29udGludW91c1ZlcnRpY2FsYCBkaXNhYmxlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0T3B0aW9ucygpLnNjcm9sbE92ZXJmbG93ICYmIChnZXRPcHRpb25zKCkuc2Nyb2xsQmFyIHx8ICFnZXRPcHRpb25zKCkuYXV0b1Njcm9sbGluZykpIHtcbiAgICAgICAgc2hvd0Vycm9yKCd3YXJuJywgJ09wdGlvbnMgc2Nyb2xsQmFyOnRydWUgYW5kIGF1dG9TY3JvbGxpbmc6ZmFsc2UgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIHNjcm9sbE92ZXJmbG93OnRydWUuIFNlY3Rpb25zIHdpdGggc2Nyb2xsT3ZlcmZsb3cgbWlnaHQgbm90IHdvcmsgd2VsbCBpbiBGaXJlZm94Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRPcHRpb25zKCkuY29udGludW91c1ZlcnRpY2FsICYmIChnZXRPcHRpb25zKCkuc2Nyb2xsQmFyIHx8ICFnZXRPcHRpb25zKCkuYXV0b1Njcm9sbGluZykpIHtcbiAgICAgICAgZ2V0T3B0aW9ucygpLmNvbnRpbnVvdXNWZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICBzaG93RXJyb3IoJ3dhcm4nLCAnU2Nyb2xsIGJhcnMgKGBzY3JvbGxCYXI6dHJ1ZWAgb3IgYGF1dG9TY3JvbGxpbmc6ZmFsc2VgKSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggYGNvbnRpbnVvdXNWZXJ0aWNhbGA7IGBjb250aW51b3VzVmVydGljYWxgIGRpc2FibGVkJyk7XG4gICAgICB9IC8vdXNpbmcgZXh0ZW5zaW9ucz8gV3JvbmcgZmlsZSFcblxuXG4gICAgICBleHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgICAgICAvL2lzIHRoZSBvcHRpb24gc2V0IHRvIHRydWU/XG4gICAgICAgIGlmIChnZXRPcHRpb25zKClbZXh0ZW5zaW9uXSkge1xuICAgICAgICAgIHNob3dFcnJvcignd2FybicsICdmdWxscGFnZS5qcyBleHRlbnNpb25zIHJlcXVpcmUgZnVsbHBhZ2UuZXh0ZW5zaW9ucy5taW4uanMgZmlsZSBpbnN0ZWFkIG9mIHRoZSB1c3VhbCBmdWxscGFnZS5qcy4gUmVxdWVzdGVkOiAnICsgZXh0ZW5zaW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vYW5jaG9ycyBjYW4gbm90IGhhdmUgdGhlIHNhbWUgdmFsdWUgYXMgYW55IGVsZW1lbnQgSUQgb3IgTkFNRVxuXG4gICAgICBnZXRPcHRpb25zKCkuYW5jaG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIC8vY2FzZSBpbnNlbnNpdGl2ZSBzZWxlY3RvcnMgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NDY1MTg3LzEwODEzOTYpXG4gICAgICAgIHZhciBuYW1lQXR0ciA9IFtdLnNsaWNlLmNhbGwoJCgnW25hbWVdJykpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBnZXRBdHRyKGl0ZW0sICduYW1lJykgJiYgZ2V0QXR0cihpdGVtLCAnbmFtZScpLnRvTG93ZXJDYXNlKCkgPT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlkQXR0ciA9IFtdLnNsaWNlLmNhbGwoJCgnW2lkXScpKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gZ2V0QXR0cihpdGVtLCAnaWQnKSAmJiBnZXRBdHRyKGl0ZW0sICdpZCcpLnRvTG93ZXJDYXNlKCkgPT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaWRBdHRyLmxlbmd0aCB8fCBuYW1lQXR0ci5sZW5ndGgpIHtcbiAgICAgICAgICBzaG93RXJyb3IoJ2Vycm9yJywgJ2RhdGEtYW5jaG9yIHRhZ3MgY2FuIG5vdCBoYXZlIHRoZSBzYW1lIHZhbHVlIGFzIGFueSBgaWRgIGVsZW1lbnQgb24gdGhlIHNpdGUgKG9yIGBuYW1lYCBlbGVtZW50IGZvciBJRSkuJyk7XG4gICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGlkQXR0ci5sZW5ndGggPyAnaWQnIDogJ25hbWUnO1xuXG4gICAgICAgICAgaWYgKGlkQXR0ci5sZW5ndGggfHwgbmFtZUF0dHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBzaG93RXJyb3IoJ2Vycm9yJywgJ1wiJyArIG5hbWUgKyAnXCIgaXMgaXMgYmVpbmcgdXNlZCBieSBhbm90aGVyIGVsZW1lbnQgYCcgKyBwcm9wZXJ0eU5hbWUgKyAnYCBwcm9wZXJ0eScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnVsbHBhZ2UoY29udGFpbmVyU2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgIHNldENhY2hlKCk7IC8vb25seSBvbmNlIG15IGZyaWVuZCFcblxuICAgICAgaWYgKGhhc0NsYXNzKCRodG1sLCBFTkFCTEVEKSkge1xuICAgICAgICBkaXNwbGF5V2FybmluZ3MoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXRPcHRpb24oJ3RvdWNoV3JhcHBlcicsIHR5cGVvZiBjb250YWluZXJTZWxlY3RvciA9PT0gJ3N0cmluZycgPyAkKGNvbnRhaW5lclNlbGVjdG9yKVswXSA6IGNvbnRhaW5lclNlbGVjdG9yKTsgLy8gQ3JlYXRpbmcgc29tZSBkZWZhdWx0cywgZXh0ZW5kaW5nIHRoZW0gd2l0aCBhbnkgb3B0aW9ucyB0aGF0IHdlcmUgcHJvdmlkZWRcblxuICAgICAgc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHNldENvbnRhaW5lcih0eXBlb2YgY29udGFpbmVyU2VsZWN0b3IgPT09ICdzdHJpbmcnID8gJChjb250YWluZXJTZWxlY3RvcilbMF0gOiBjb250YWluZXJTZWxlY3Rvcik7XG4gICAgICBFdmVudEVtaXR0ZXIuZW1pdChldmVudHMub25Jbml0aWFsaXNlKTtcbiAgICAgIGRpc3BsYXlXYXJuaW5ncygpO1xuICAgICAgc2V0QVBJKCk7XG5cbiAgICAgIGlmIChnZXRDb250YWluZXIoKSkge1xuICAgICAgICBFdmVudEVtaXR0ZXIuZW1pdChldmVudHMuYmVmb3JlSW5pdCk7XG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgRXZlbnRFbWl0dGVyLmVtaXQoZXZlbnRzLmJpbmRFdmVudHMpO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGlzRnVsbHBhZ2VJbml0RG9uZTogdHJ1ZVxuICAgICAgfSk7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgcmV0dXJuIHdpbi5mdWxscGFnZV9hcGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QVBJKCkge1xuICAgICAgRlAuZ2V0RnVsbHBhZ2VEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wdGlvbnM6IGdldE9wdGlvbnMoKVxuICAgICAgICB9O1xuICAgICAgfTsgLy9wdWJsaWMgZnVuY3Rpb25zXG5cblxuICAgICAgRlAudmVyc2lvbiA9ICc0LjAuMzcnO1xuICAgICAgRlAudGVzdCA9IE9iamVjdC5hc3NpZ24oRlAudGVzdCwge1xuICAgICAgICB0b3A6ICcwcHgnLFxuICAgICAgICB0cmFuc2xhdGUzZDogJ3RyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgdHJhbnNsYXRlM2RIOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGEgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJChnZXRPcHRpb25zKCkuc2VjdGlvblNlbGVjdG9yLCBnZXRDb250YWluZXIoKSkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGEucHVzaCgndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSgpLFxuICAgICAgICBsZWZ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGEgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJChnZXRPcHRpb25zKCkuc2VjdGlvblNlbGVjdG9yLCBnZXRDb250YWluZXIoKSkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGEucHVzaCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSgpLFxuICAgICAgICBvcHRpb25zOiBnZXRPcHRpb25zKCksXG4gICAgICAgIHNldEF1dG9TY3JvbGxpbmc6IG51bGxcbiAgICAgIH0pOyAvL2Z1bmN0aW9ucyB3ZSB3YW50IHRvIHNoYXJlIGFjcm9zcyBmaWxlcyBidXQgd2hpY2ggYXJlIG5vdFxuICAgICAgLy9tZWFuIHRvIGJlIHVzZWQgb24gdGhlaXIgb3duIGJ5IGRldmVsb3BlcnNcblxuICAgICAgRlAuc2hhcmVkID0gT2JqZWN0LmFzc2lnbihGUC5zaGFyZWQsIHtcbiAgICAgICAgYWZ0ZXJSZW5kZXJBY3Rpb25zOiBudWxsLFxuICAgICAgICBpc05vcm1hbFNjcm9sbEVsZW1lbnQ6IGZhbHNlXG4gICAgICB9KTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgICB3aW4uZnVsbHBhZ2VfYXBpID0gRlA7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuXG4gICAgd2luLmZwX2Vhc2luZ3MgPSBkZWVwRXh0ZW5kKHdpbi5mcF9lYXNpbmdzLCB7XG4gICAgICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWModCwgYiwgYywgZCkge1xuICAgICAgICBpZiAoKHQgLz0gZCAvIDIpIDwgMSkgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICsgYjtcbiAgICAgICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKyAyKSArIGI7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBqUXVlcnkgYWRhcHRlciBmb3IgZnVsbFBhZ2UuanMgMy4wLjBcbiAgICAgKi9cbiAgICAvLyBAdHMtaWdub3JlXG5cbiAgICBpZiAod2luLmpRdWVyeSkge1xuICAgICAgKGZ1bmN0aW9uICgkLCBmdWxscGFnZSkge1xuXG4gICAgICAgIGlmICghJCB8fCAhZnVsbHBhZ2UpIHtcbiAgICAgICAgICBzaG93RXJyb3IoJ2Vycm9yJywgJ2pRdWVyeSBpcyByZXF1aXJlZCB0byB1c2UgdGhlIGpRdWVyeSBmdWxscGFnZSBhZGFwdGVyIScpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgICQuZm4uZnVsbHBhZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgJyQnOiAkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbmV3IGZ1bGxwYWdlKHRoaXNbMF0sIG9wdGlvbnMpOyAvLyBDcmVhdGluZyB0aGUgJC5mbi5mdWxscGFnZSBvYmplY3RcblxuICAgICAgICAgIE9iamVjdC5rZXlzKEZQKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGdldE9wdGlvbnMoKS4kLmZuLmZ1bGxwYWdlW2tleV0gPSBGUFtrZXldO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9OyAvLyBAdHMtaWdub3JlXG5cbiAgICAgIH0pKHdpbi5qUXVlcnksIGZ1bGxwYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbHBhZ2U7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/fullpage.js/dist/fullpage.js\n"));

/***/ })

}]);